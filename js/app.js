!function (t) { var e = {}; function n(i) { if (e[i]) return e[i].exports; var r = e[i] = { i: i, l: !1, exports: {} }; return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports } n.m = t, n.c = e, n.d = function (t, e, i) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i }) }, n.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var i = Object.create(null); if (n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var r in t) n.d(i, r, function (e) { return t[e] }.bind(null, r)); return i }, n.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return n.d(e, "a", e), e }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, n.p = "js/", n(n.s = 16) }([function (t, e, n) {
    "use strict"; (function (t, i) {
        n.d(e, "k", (function () { return r })), n.d(e, "m", (function () { return s })), n.d(e, "l", (function () { return o })), n.d(e, "i", (function () { return c })), n.d(e, "a", (function () { return l })), n.d(e, "b", (function () { return u })), n.d(e, "c", (function () { return h })), n.d(e, "d", (function () { return d })), n.d(e, "e", (function () { return f })), n.d(e, "f", (function () { return p })), n.d(e, "g", (function () { return m })), n.d(e, "h", (function () { return g })), n.d(e, "j", (function () { return v }));
      
        var r = "undefined" != typeof window ? window : t.exports && void 0 !== i ? i : {}, o = function (t) { var e = {}, n = t.document, i = t.GreenSockGlobals = t.GreenSockGlobals || t; if (i.TweenLite) return i.TweenLite; var r, o, s, a, c, l, u, h = function (t) { var e, n = t.split("."), r = i; for (e = 0; e < n.length; e++)r[n[e]] = r = r[n[e]] || {}; return r }, d = h("com.greensock"), f = function (t) { var e, n = [], i = t.length; for (e = 0; e !== i; n.push(t[e++])); return n }, p = function () { }, m = (l = Object.prototype.toString, u = l.call([]), function (t) { return null != t && (t instanceof Array || "object" == typeof t && !!t.push && l.call(t) === u) }), g = {}, v = function (t, n, r, o) { this.sc = g[t] ? g[t].sc : [], g[t] = this, this.gsClass = null, this.func = r; var s = []; this.check = function (a) { for (var c, l, u, d, f = n.length, p = f; --f > -1;)(c = g[n[f]] || new v(n[f], [])).gsClass ? (s[f] = c.gsClass, p--) : a && c.sc.push(this); if (0 === p && r) for (u = (l = ("com.greensock." + t).split(".")).pop(), d = h(l.join("."))[u] = this.gsClass = r.apply(r, s), o && (i[u] = e[u] = d), f = 0; f < this.sc.length; f++)this.sc[f].check() }, this.check(!0) }, y = t._gsDefine = function (t, e, n, i) { return new v(t, e, n, i) }, _ = d._class = function (t, e, n) { return e = e || function () { }, y(t, [], (function () { return e }), n), e }; y.globals = i; var x = [0, 0, 1, 1], b = _("easing.Ease", (function (t, e, n, i) { this._func = t, this._type = n || 0, this._power = i || 0, this._params = e ? x.concat(e) : x }), !0), w = b.map = {}, M = b.register = function (t, e, n, i) { for (var r, o, s, a, c = e.split(","), l = c.length, u = (n || "easeIn,easeOut,easeInOut").split(","); --l > -1;)for (o = c[l], r = i ? _("easing." + o, null, !0) : d.easing[o] || {}, s = u.length; --s > -1;)a = u[s], w[o + "." + a] = w[a + o] = r[a] = t.getRatio ? t : t[a] || new t }; for ((s = b.prototype)._calcEnd = !1, s.getRatio = function (t) { if (this._func) return this._params[0] = t, this._func.apply(null, this._params); var e = this._type, n = this._power, i = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t); return 1 === n ? i *= i : 2 === n ? i *= i * i : 3 === n ? i *= i * i * i : 4 === n && (i *= i * i * i * i), 1 === e ? 1 - i : 2 === e ? i : t < .5 ? i / 2 : 1 - i / 2 }, o = (r = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --o > -1;)s = r[o] + ",Power" + o, M(new b(null, null, 1, o), s, "easeOut", !0), M(new b(null, null, 2, o), s, "easeIn" + (0 === o ? ",easeNone" : "")), M(new b(null, null, 3, o), s, "easeInOut"); w.linear = d.easing.Linear.easeIn, w.swing = d.easing.Quad.easeInOut; var T = _("events.EventDispatcher", (function (t) { this._listeners = {}, this._eventTarget = t || this })); (s = T.prototype).addEventListener = function (t, e, n, i, r) { r = r || 0; var o, s, l = this._listeners[t], u = 0; for (this !== a || c || a.wake(), null == l && (this._listeners[t] = l = []), s = l.length; --s > -1;)(o = l[s]).c === e && o.s === n ? l.splice(s, 1) : 0 === u && o.pr < r && (u = s + 1); l.splice(u, 0, { c: e, s: n, up: i, pr: r }) }, s.removeEventListener = function (t, e) { var n, i = this._listeners[t]; if (i) for (n = i.length; --n > -1;)if (i[n].c === e) return void i.splice(n, 1) }, s.dispatchEvent = function (t) { var e, n, i, r = this._listeners[t]; if (r) for ((e = r.length) > 1 && (r = r.slice(0)), n = this._eventTarget; --e > -1;)(i = r[e]) && (i.up ? i.c.call(i.s || n, { type: t, target: n }) : i.c.call(i.s || n)) }; var S = t.requestAnimationFrame, E = t.cancelAnimationFrame, A = Date.now || function () { return (new Date).getTime() }, P = A(); for (o = (r = ["ms", "moz", "webkit", "o"]).length; --o > -1 && !S;)S = t[r[o] + "RequestAnimationFrame"], E = t[r[o] + "CancelAnimationFrame"] || t[r[o] + "CancelRequestAnimationFrame"]; _("Ticker", (function (t, e) { var i, r, o, s, l, u = this, h = A(), d = !(!1 === e || !S) && "auto", f = 500, m = 33, g = function (t) { var e, n, a = A() - P; a > f && (h += a - m), P += a, u.time = (P - h) / 1e3, e = u.time - l, (!i || e > 0 || !0 === t) && (u.frame++, l += e + (e >= s ? .004 : s - e), n = !0), !0 !== t && (o = r(g)), n && u.dispatchEvent("tick") }; T.call(u), u.time = u.frame = 0, u.tick = function () { g(!0) }, u.lagSmoothing = function (t, e) { if (!arguments.length) return f < 1e8; f = t || 1e8, m = Math.min(e, f, 0) }, u.sleep = function () { null != o && (d && E ? E(o) : clearTimeout(o), r = p, o = null, u === a && (c = !1)) }, u.wake = function (t) { null !== o ? u.sleep() : t ? h += -P + (P = A()) : u.frame > 10 && (P = A() - f + 5), r = 0 === i ? p : d && S ? S : function (t) { return setTimeout(t, 1e3 * (l - u.time) + 1 | 0) }, u === a && (c = !0), g(2) }, u.fps = function (t) { if (!arguments.length) return i; s = 1 / ((i = t) || 60), l = this.time + s, u.wake() }, u.useRAF = function (t) { if (!arguments.length) return d; u.sleep(), d = t, u.fps(i) }, u.fps(t), setTimeout((function () { "auto" === d && u.frame < 5 && "hidden" !== (n || {}).visibilityState && u.useRAF(!1) }), 1500) })), (s = d.Ticker.prototype = new d.events.EventDispatcher).constructor = d.Ticker; var L = _("core.Animation", (function (t, e) { if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !!e.immediateRender, this.data = e.data, this._reversed = !!e.reversed, Z) { c || a.wake(); var n = this.vars.useFrames ? Y : Z; n.add(this, n._time), this.vars.paused && this.paused(!0) } })); a = L.ticker = new d.Ticker, (s = L.prototype)._dirty = s._gc = s._initted = s._paused = !1, s._totalTime = s._time = 0, s._rawPrevTime = -1, s._next = s._last = s._onUpdate = s._timeline = s.timeline = null, s._paused = !1; var R = function () { c && A() - P > 2e3 && ("hidden" !== (n || {}).visibilityState || !a.lagSmoothing()) && a.wake(); var t = setTimeout(R, 2e3); t.unref && t.unref() }; R(), s.play = function (t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, s.pause = function (t, e) { return null != t && this.seek(t, e), this.paused(!0) }, s.resume = function (t, e) { return null != t && this.seek(t, e), this.paused(!1) }, s.seek = function (t, e) { return this.totalTime(Number(t), !1 !== e) }, s.restart = function (t, e) { return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0) }, s.reverse = function (t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, s.render = function (t, e, n) { }, s.invalidate = function () { return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this }, s.isActive = function () { var t, e = this._timeline, n = this._startTime; return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= n && t < n + this.totalDuration() / this._timeScale - 1e-8 }, s._enabled = function (t, e) { return c || a.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1 }, s._kill = function (t, e) { return this._enabled(!1, !1) }, s.kill = function (t, e) { return this._kill(t, e), this }, s._uncache = function (t) { for (var e = t ? this : this.timeline; e;)e._dirty = !0, e = e.timeline; return this }, s._swapSelfInParams = function (t) { for (var e = t.length, n = t.concat(); --e > -1;)"{self}" === t[e] && (n[e] = this); return n }, s._callback = function (t) { var e = this.vars, n = e[t], i = e[t + "Params"], r = e[t + "Scope"] || e.callbackScope || this; switch (i ? i.length : 0) { case 0: n.call(r); break; case 1: n.call(r, i[0]); break; case 2: n.call(r, i[0], i[1]); break; default: n.apply(r, i) } }, s.eventCallback = function (t, e, n, i) { if ("on" === (t || "").substr(0, 2)) { var r = this.vars; if (1 === arguments.length) return r[t]; null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = m(n) && -1 !== n.join("").indexOf("{self}") ? this._swapSelfInParams(n) : n, r[t + "Scope"] = i), "onUpdate" === t && (this._onUpdate = e) } return this }, s.delay = function (t) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay }, s.duration = function (t) { return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration) }, s.totalDuration = function (t) { return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration }, s.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time }, s.totalTime = function (t, e, n) { if (c || a.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (t < 0 && !n && (t += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); var i = this._totalDuration, r = this._timeline; if (t > i && !n && (t = i), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? i - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline) for (; r._timeline;)r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline } this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (D.length && Q(), this.render(t, e, !1), D.length && Q()) } return this }, s.progress = s.totalProgress = function (t, e) { var n = this.duration(); return arguments.length ? this.totalTime(n * t, e) : n ? this._time / n : this.ratio }, s.startTime = function (t) { return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime }, s.endTime = function (t) { return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale }, s.timeScale = function (t) { if (!arguments.length) return this._timeScale; var e, n; for (t = t || 1e-8, this._timeline && this._timeline.smoothChildTiming && (n = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = n - (n - this._startTime) * this._timeScale / t), this._timeScale = t, n = this.timeline; n && n.timeline;)n._dirty = !0, n.totalDuration(), n = n.timeline; return this }, s.reversed = function (t) { return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed }, s.paused = function (t) { if (!arguments.length) return this._paused; var e, n, i = this._timeline; return t != this._paused && i && (c || t || a.wake(), n = (e = i.rawTime()) - this._pauseTime, !t && i.smoothChildTiming && (this._startTime += n, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== n && this._initted && this.duration() && (e = i.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this }; var O = _("core.SimpleTimeline", (function (t) { L.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0 })); (s = O.prototype = new L).constructor = O, s.kill()._gc = !1, s._first = s._last = s._recent = null, s._sortChildren = !1, s.add = s.insert = function (t, e, n, i) { var r, o; if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren) for (o = t._startTime; r && r._startTime > o;)r = r._prev; return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this }, s._remove = function (t, e) { return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this }, s.render = function (t, e, n) { var i, r = this._first; for (this._totalTime = this._time = this._rawPrevTime = t; r;)i = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, n) : r.render((t - r._startTime) * r._timeScale, e, n)), r = i }, s.rawTime = function () { return c || a.wake(), this._totalTime }; var C = _("TweenLite", (function (e, n, i) { if (L.call(this, n, i), this.render = C.prototype.render, null == e) throw "Cannot tween a null target."; this.target = e = "string" != typeof e ? e : C.selector(e) || e; var r, o, s, a = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType), c = this.vars.overwrite; if (this._overwrite = c = null == c ? X[C.defaultOverwrite] : "number" == typeof c ? c >> 0 : X[c], (a || e instanceof Array || e.push && m(e)) && "number" != typeof e[0]) for (this._targets = s = f(e), this._propLookup = [], this._siblings = [], r = 0; r < s.length; r++)(o = s[r]) ? "string" != typeof o ? o.length && o !== t && o[0] && (o[0] === t || o[0].nodeType && o[0].style && !o.nodeType) ? (s.splice(r--, 1), this._targets = s = s.concat(f(o))) : (this._siblings[r] = $(o, this, !1), 1 === c && this._siblings[r].length > 1 && tt(o, this, null, 1, this._siblings[r])) : "string" == typeof (o = s[r--] = C.selector(o)) && s.splice(r + 1, 1) : s.splice(r--, 1); else this._propLookup = {}, this._siblings = $(e, this, !1), 1 === c && this._siblings.length > 1 && tt(e, this, null, 1, this._siblings); (this.vars.immediateRender || 0 === n && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-8, this.render(Math.min(0, -this._delay))) }), !0), I = function (e) { return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType) }; (s = C.prototype = new L).constructor = C, s.kill()._gc = !1, s.ratio = 0, s._firstPT = s._targets = s._overwrittenProps = s._startAt = null, s._notifyPluginsOfEnabled = s._lazy = !1, C.version = "2.1.3", C.defaultEase = s._ease = new b(null, null, 1, 1), C.defaultOverwrite = "auto", C.ticker = a, C.autoSleep = 120, C.lagSmoothing = function (t, e) { a.lagSmoothing(t, e) }, C.selector = t.$ || t.jQuery || function (e) { var i = t.$ || t.jQuery; return i ? (C.selector = i, i(e)) : (n || (n = t.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e) }; var D = [], N = {}, k = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, B = /[\+-]=-?[\.\d]/, z = function (t) { for (var e, n = this._firstPT; n;)e = n.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : n.c * t + n.s, n.m ? e = n.m.call(this._tween, e, this._target || n.t, this._tween) : e < 1e-6 && e > -1e-6 && !n.blob && (e = 0), n.f ? n.fp ? n.t[n.p](n.fp, e) : n.t[n.p](e) : n.t[n.p] = e, n = n._next }, F = function (t) { return (1e3 * t | 0) / 1e3 + "" }, U = function (t, e, n, i) { var r, o, s, a, c, l, u, h = [], d = 0, f = "", p = 0; for (h.start = t, h.end = e, t = h[0] = t + "", e = h[1] = e + "", n && (n(h), t = h[0], e = h[1]), h.length = 0, r = t.match(k) || [], o = e.match(k) || [], i && (i._next = null, i.blob = 1, h._firstPT = h._applyPT = i), c = o.length, a = 0; a < c; a++)u = o[a], f += (l = e.substr(d, e.indexOf(u, d) - d)) || !a ? l : ",", d += l.length, p ? p = (p + 1) % 5 : "rgba(" === l.substr(-5) && (p = 1), u === r[a] || r.length <= a ? f += u : (f && (h.push(f), f = ""), s = parseFloat(r[a]), h.push(s), h._firstPT = { _next: h._firstPT, t: h, p: h.length - 1, s: s, c: ("=" === u.charAt(1) ? parseInt(u.charAt(0) + "1", 10) * parseFloat(u.substr(2)) : parseFloat(u) - s) || 0, f: 0, m: p && p < 4 ? Math.round : F }), d += u.length; return (f += e.substr(d)) && h.push(f), h.setRatio = z, B.test(e) && (h.end = null), h }, H = function (t, e, n, i, r, o, s, a, c) { "function" == typeof i && (i = i(c || 0, t)); var l = typeof t[e], u = "function" !== l ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3), h = "get" !== n ? n : u ? s ? t[u](s) : t[u]() : t[e], d = "string" == typeof i && "=" === i.charAt(1), f = { t: t, p: e, s: h, f: "function" === l, pg: 0, n: r || e, m: o ? "function" == typeof o ? o : Math.round : 0, pr: 0, c: d ? parseInt(i.charAt(0) + "1", 10) * parseFloat(i.substr(2)) : parseFloat(i) - h || 0 }; if (("number" != typeof h || "number" != typeof i && !d) && (s || isNaN(h) || !d && isNaN(i) || "boolean" == typeof h || "boolean" == typeof i ? (f.fp = s, f = { t: U(h, d ? parseFloat(f.s) + f.c + (f.s + "").replace(/[0-9\-\.]/g, "") : i, a || C.defaultStringFilter, f), p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: r || e, pr: 0, m: 0 }) : (f.s = parseFloat(h), d || (f.c = parseFloat(i) - f.s || 0))), f.c) return (f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f }, G = C._internals = { isArray: m, isSelector: I, lazyTweens: D, blobDif: U }, j = C._plugins = {}, V = G.tweenLookup = {}, W = 0, q = G.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1, id: 1, yoyoEase: 1, stagger: 1 }, X = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0 }, Y = L._rootFramesTimeline = new O, Z = L._rootTimeline = new O, J = 30, Q = G.lazyRender = function () { var t, e, n = D.length; for (N = {}, t = 0; t < n; t++)(e = D[t]) && !1 !== e._lazy && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1); D.length = 0 }; Z._startTime = a.time, Y._startTime = a.frame, Z._active = Y._active = !0, setTimeout(Q, 1), L._updateRoot = C.render = function () { var t, e, n; if (D.length && Q(), Z.render((a.time - Z._startTime) * Z._timeScale, !1, !1), Y.render((a.frame - Y._startTime) * Y._timeScale, !1, !1), D.length && Q(), a.frame >= J) { for (n in J = a.frame + (parseInt(C.autoSleep, 10) || 120), V) { for (t = (e = V[n].tweens).length; --t > -1;)e[t]._gc && e.splice(t, 1); 0 === e.length && delete V[n] } if ((!(n = Z._first) || n._paused) && C.autoSleep && !Y._first && 1 === a._listeners.tick.length) { for (; n && n._paused;)n = n._next; n || a.sleep() } } }, a.addEventListener("tick", L._updateRoot); var $ = function (t, e, n) { var i, r, o = t._gsTweenID; if (V[o || (t._gsTweenID = o = "t" + W++)] || (V[o] = { target: t, tweens: [] }), e && ((i = V[o].tweens)[r = i.length] = e, n)) for (; --r > -1;)i[r] === e && i.splice(r, 1); return V[o].tweens }, K = function (t, e, n, i) { var r, o, s = t.vars.onOverwrite; return s && (r = s(t, e, n, i)), (s = C.onOverwrite) && (o = s(t, e, n, i)), !1 !== r && !1 !== o }, tt = function (t, e, n, i, r) { var o, s, a, c; if (1 === i || i >= 4) { for (c = r.length, o = 0; o < c; o++)if ((a = r[o]) !== e) a._gc || a._kill(null, t, e) && (s = !0); else if (5 === i) break; return s } var l, u = e._startTime + 1e-8, h = [], d = 0, f = 0 === e._duration; for (o = r.length; --o > -1;)(a = r[o]) === e || a._gc || a._paused || (a._timeline !== e._timeline ? (l = l || et(e, 0, f), 0 === et(a, l, f) && (h[d++] = a)) : a._startTime <= u && a._startTime + a.totalDuration() / a._timeScale > u && ((f || !a._initted) && u - a._startTime <= 2e-8 || (h[d++] = a))); for (o = d; --o > -1;)if (c = (a = h[o])._firstPT, 2 === i && a._kill(n, t, e) && (s = !0), 2 !== i || !a._firstPT && a._initted && c) { if (2 !== i && !K(a, e)) continue; a._enabled(!1, !1) && (s = !0) } return s }, et = function (t, e, n) { for (var i = t._timeline, r = i._timeScale, o = t._startTime; i._timeline;) { if (o += i._startTime, r *= i._timeScale, i._paused) return -100; i = i._timeline } return (o /= r) > e ? o - e : n && o === e || !t._initted && o - e < 2e-8 ? 1e-8 : (o += t.totalDuration() / t._timeScale / r) > e + 1e-8 ? 0 : o - e - 1e-8 }; s._init = function () { var t, e, n, i, r, o, s = this.vars, a = this._overwrittenProps, c = this._duration, l = !!s.immediateRender, u = s.ease, h = this._startAt; if (s.startAt) { for (i in h && (h.render(-1, !0), h.kill()), r = {}, s.startAt) r[i] = s.startAt[i]; if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== s.lazy, r.startAt = r.delay = null, r.onUpdate = s.onUpdate, r.onUpdateParams = s.onUpdateParams, r.onUpdateScope = s.onUpdateScope || s.callbackScope || this, this._startAt = C.to(this.target || {}, 0, r), l) if (this._time > 0) this._startAt = null; else if (0 !== c) return } else if (s.runBackwards && 0 !== c) if (h) h.render(-1, !0), h.kill(), this._startAt = null; else { for (i in 0 !== this._time && (l = !1), n = {}, s) q[i] && "autoCSS" !== i || (n[i] = s[i]); if (n.overwrite = 0, n.data = "isFromStart", n.lazy = l && !1 !== s.lazy, n.immediateRender = l, this._startAt = C.to(this.target, 0, n), l) { if (0 === this._time) return } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null) } if (this._ease = u = u ? u instanceof b ? u : "function" == typeof u ? new b(u, s.easeParams) : w[u] || C.defaultEase : C.defaultEase, s.easeParams instanceof Array && u.config && (this._ease = u.config.apply(u, s.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (o = this._targets.length, t = 0; t < o; t++)this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null, t) && (e = !0); else e = this._initProps(this.target, this._propLookup, this._siblings, a, 0); if (e && C._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards) for (n = this._firstPT; n;)n.s += n.c, n.c = -n.c, n = n._next; this._onUpdate = s.onUpdate, this._initted = !0 }, s._initProps = function (e, n, i, r, o) { var s, a, c, l, u, h; if (null == e) return !1; for (s in N[e._gsTweenID] && Q(), this.vars.css || e.style && e !== t && e.nodeType && j.css && !1 !== this.vars.autoCSS && function (t, e) { var n, i = {}; for (n in t) q[n] || n in e && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!j[n] || j[n] && j[n]._autoCSS) || (i[n] = t[n], delete t[n]); t.css = i }(this.vars, e), this.vars) if (h = this.vars[s], q[s]) h && (h instanceof Array || h.push && m(h)) && -1 !== h.join("").indexOf("{self}") && (this.vars[s] = h = this._swapSelfInParams(h, this)); else if (j[s] && (l = new j[s])._onInitTween(e, this.vars[s], this, o)) { for (this._firstPT = u = { _next: this._firstPT, t: l, p: "setRatio", s: 0, c: 1, f: 1, n: s, pg: 1, pr: l._priority, m: 0 }, a = l._overwriteProps.length; --a > -1;)n[l._overwriteProps[a]] = this._firstPT; (l._priority || l._onInitAllProps) && (c = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), u._next && (u._next._prev = u) } else n[s] = H.call(this, e, s, "get", h, s, 0, null, this.vars.stringFilter, o); return r && this._kill(r, e) ? this._initProps(e, n, i, r, o) : this._overwrite > 1 && this._firstPT && i.length > 1 && tt(e, this, n, this._overwrite, i) ? (this._kill(n, e), this._initProps(e, n, i, r, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (N[e._gsTweenID] = !0), c) }, s.render = function (t, e, n) { var i, r, o, s, a = this._time, c = this._duration, l = this._rawPrevTime; if (t >= c - 1e-8 && t >= 0) this._totalTime = this._time = c, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (i = !0, r = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === c && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (l < 0 || t <= 0 && t >= -1e-8 || 1e-8 === l && "isPause" !== this.data) && l !== t && (n = !0, l > 1e-8 && (r = "onReverseComplete")), this._rawPrevTime = s = !e || t || l === t ? t : 1e-8); else if (t < 1e-8) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== a || 0 === c && l > 0) && (r = "onReverseComplete", i = this._reversed), t > -1e-8 ? t = 0 : t < 0 && (this._active = !1, 0 === c && (this._initted || !this.vars.lazy || n) && (l >= 0 && (1e-8 !== l || "isPause" !== this.data) && (n = !0), this._rawPrevTime = s = !e || t || l === t ? t : 1e-8)), (!this._initted || this._startAt && this._startAt.progress()) && (n = !0); else if (this._totalTime = this._time = t, this._easeType) { var u = t / c, h = this._easeType, d = this._easePower; (1 === h || 3 === h && u >= .5) && (u = 1 - u), 3 === h && (u *= 2), 1 === d ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u), this.ratio = 1 === h ? 1 - u : 2 === h ? u : t / c < .5 ? u / 2 : 1 - u / 2 } else this.ratio = this._ease.getRatio(t / c); if (this._time !== a || n) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = a, this._rawPrevTime = l, D.push(this), void (this._lazy = [t, e]); this._time && !i ? this.ratio = this._ease.getRatio(this._time / c) : i && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== a && t >= 0 && (this._active = !0), 0 === a && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, n) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== c || e || this._callback("onStart"))), o = this._firstPT; o;)o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next; this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, n), e || (this._time !== a || i || n) && this._callback("onUpdate")), r && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, n), i && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === c && 1e-8 === this._rawPrevTime && 1e-8 !== s && (this._rawPrevTime = 0))) } }, s._kill = function (t, e, n) { if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1); e = "string" != typeof e ? e || this._targets || this.target : C.selector(e) || e; var i, r, o, s, a, c, l, u, h, d = n && this._time && n._startTime === this._startTime && this._timeline === n._timeline, f = this._firstPT; if ((m(e) || I(e)) && "number" != typeof e[0]) for (i = e.length; --i > -1;)this._kill(t, e[i], n) && (c = !0); else { if (this._targets) { for (i = this._targets.length; --i > -1;)if (e === this._targets[i]) { a = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all"; break } } else { if (e !== this.target) return !1; a = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all" } if (a) { if (l = t || a, u = t !== r && "all" !== r && t !== a && ("object" != typeof t || !t._tempKill), n && (C.onOverwrite || this.vars.onOverwrite)) { for (o in l) a[o] && (h || (h = []), h.push(o)); if ((h || !t) && !K(this, n, e, h)) return !1 } for (o in l) (s = a[o]) && (d && (s.f ? s.t[s.p](s.s) : s.t[s.p] = s.s, c = !0), s.pg && s.t._kill(l) && (c = !0), s.pg && 0 !== s.t._overwriteProps.length || (s._prev ? s._prev._next = s._next : s === this._firstPT && (this._firstPT = s._next), s._next && (s._next._prev = s._prev), s._next = s._prev = null), delete a[o]), u && (r[o] = 1); !this._firstPT && this._initted && f && this._enabled(!1, !1) } } return c }, s.invalidate = function () { this._notifyPluginsOfEnabled && C._onPluginEvent("_onDisable", this); var t = this._time; return this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], L.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-8, this.render(t, !1, !1 !== this.vars.lazy)), this }, s._enabled = function (t, e) { if (c || a.wake(), t && this._gc) { var n, i = this._targets; if (i) for (n = i.length; --n > -1;)this._siblings[n] = $(i[n], this, !0); else this._siblings = $(this.target, this, !0) } return L.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && C._onPluginEvent(t ? "_onEnable" : "_onDisable", this) }, C.to = function (t, e, n) { return new C(t, e, n) }, C.from = function (t, e, n) { return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new C(t, e, n) }, C.fromTo = function (t, e, n, i) { return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, new C(t, e, i) }, C.delayedCall = function (t, e, n, i, r) { return new C(e, 0, { delay: t, onComplete: e, onCompleteParams: n, callbackScope: i, onReverseComplete: e, onReverseCompleteParams: n, immediateRender: !1, lazy: !1, useFrames: r, overwrite: 0 }) }, C.set = function (t, e) { return new C(t, 0, e) }, C.getTweensOf = function (t, e) { if (null == t) return []; var n, i, r, o; if (t = "string" != typeof t ? t : C.selector(t) || t, (m(t) || I(t)) && "number" != typeof t[0]) { for (n = t.length, i = []; --n > -1;)i = i.concat(C.getTweensOf(t[n], e)); for (n = i.length; --n > -1;)for (o = i[n], r = n; --r > -1;)o === i[r] && i.splice(n, 1) } else if (t._gsTweenID) for (n = (i = $(t).concat()).length; --n > -1;)(i[n]._gc || e && !i[n].isActive()) && i.splice(n, 1); return i || [] }, C.killTweensOf = C.killDelayedCallsTo = function (t, e, n) { "object" == typeof e && (n = e, e = !1); for (var i = C.getTweensOf(t, e), r = i.length; --r > -1;)i[r]._kill(n, t) }; var nt = _("plugins.TweenPlugin", (function (t, e) { this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = nt.prototype }), !0); if (s = nt.prototype, nt.version = "1.19.0", nt.API = 2, s._firstPT = null, s._addTween = H, s.setRatio = z, s._kill = function (t) { var e, n = this._overwriteProps, i = this._firstPT; if (null != t[this._propName]) this._overwriteProps = []; else for (e = n.length; --e > -1;)null != t[n[e]] && n.splice(e, 1); for (; i;)null != t[i.n] && (i._next && (i._next._prev = i._prev), i._prev ? (i._prev._next = i._next, i._prev = null) : this._firstPT === i && (this._firstPT = i._next)), i = i._next; return !1 }, s._mod = s._roundProps = function (t) { for (var e, n = this._firstPT; n;)(e = t[this._propName] || null != n.n && t[n.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === n.f ? n.t._applyPT.m = e : n.m = e), n = n._next }, C._onPluginEvent = function (t, e) { var n, i, r, o, s, a = e._firstPT; if ("_onInitAllProps" === t) { for (; a;) { for (s = a._next, i = r; i && i.pr > a.pr;)i = i._next; (a._prev = i ? i._prev : o) ? a._prev._next = a : r = a, (a._next = i) ? i._prev = a : o = a, a = s } a = e._firstPT = r } for (; a;)a.pg && "function" == typeof a.t[t] && a.t[t]() && (n = !0), a = a._next; return n }, nt.activate = function (t) { for (var e = t.length; --e > -1;)t[e].API === nt.API && (j[(new t[e])._propName] = t[e]); return !0 }, y.plugin = function (t) { if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition."; var e, n = t.propName, i = t.priority || 0, r = t.overwriteProps, o = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_mod", mod: "_mod", initAll: "_onInitAllProps" }, s = _("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin", (function () { nt.call(this, n, i), this._overwriteProps = r || [] }), !0 === t.global), a = s.prototype = new nt(n); for (e in a.constructor = s, s.API = t.API, o) "function" == typeof t[e] && (a[o[e]] = t[e]); return s.version = t.version, nt.activate([s]), s }, r = t._gsQueue) { for (o = 0; o < r.length; o++)r[o](); for (s in g) g[s].func || t.console.log("GSAP encountered missing dependency: " + s) } return c = !1, C }(r), s = r.GreenSockGlobals, a = s.com.greensock, c = a.core.SimpleTimeline, l = a.core.Animation, u = s.Ease, h = s.Linear, d = h, f = s.Power1, p = s.Power2, m = s.Power3, g = s.Power4, v = s.TweenPlugin; a.events.EventDispatcher
    }).call(this, n(18)(t), n(19))
}, function (t, e, n) {
    "use strict"; n.r(e); var i = n(0);
/*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */i.k._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], (function () { var t = function (t) { i.i.call(this, t); var e, n, r = this.vars; for (n in this._labels = {}, this.autoRemoveChildren = !!r.autoRemoveChildren, this.smoothChildTiming = !!r.smoothChildTiming, this._sortChildren = !0, this._onUpdate = r.onUpdate, r) e = r[n], o(e) && -1 !== e.join("").indexOf("{self}") && (r[n] = this._swapSelfInParams(e)); o(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger) }, e = i.l._internals, n = t._internals = {}, r = e.isSelector, o = e.isArray, s = e.lazyTweens, a = e.lazyRender, c = i.k._gsDefine.globals, l = function (t) { var e, n = {}; for (e in t) n[e] = t[e]; return n }, u = function (t, e, n) { var i, r, o = t.cycle; for (i in o) r = o[i], t[i] = "function" == typeof r ? r(n, e[n], e) : r[n % r.length]; delete t.cycle }, h = n.pauseCallback = function () { }, d = function (t, e, n, i) { var r = "immediateRender"; return r in e || (e[r] = !(n && !1 === n[r] || i)), e }, f = function (t) { if ("function" == typeof t) return t; var e = "object" == typeof t ? t : { each: t }, n = e.ease, i = e.from || 0, r = e.base || 0, o = {}, s = isNaN(i), a = e.axis, c = { center: .5, end: 1 }[i] || 0; return function (t, l, u) { var h, d, f, p, m, g, v, y, _, x = (u || e).length, b = o[x]; if (!b) { if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1 / 0])[0])) { for (v = -1 / 0; v < (v = u[_++].getBoundingClientRect().left) && _ < x;); _-- } for (b = o[x] = [], h = s ? Math.min(_, x) * c - .5 : i % _, d = s ? x * c / _ - .5 : i / _ | 0, v = 0, y = 1 / 0, g = 0; g < x; g++)f = g % _ - h, p = d - (g / _ | 0), b[g] = m = a ? Math.abs("y" === a ? p : f) : Math.sqrt(f * f + p * p), m > v && (v = m), m < y && (y = m); b.max = v - y, b.min = y, b.v = x = e.amount || e.each * (_ > x ? x - 1 : a ? "y" === a ? x / _ : _ : Math.max(_, x / _)) || 0, b.b = x < 0 ? r - x : r } return x = (b[t] - b.min) / b.max, b.b + (n ? n.getRatio(x) : x) * b.v } }, p = t.prototype = new i.i; return t.version = "2.1.3", t.distribute = f, p.constructor = t, p.kill()._gc = p._forcingPlayhead = p._hasPause = !1, p.to = function (t, e, n, r) { var o = n.repeat && c.TweenMax || i.l; return e ? this.add(new o(t, e, n), r) : this.set(t, n, r) }, p.from = function (t, e, n, r) { return this.add((n.repeat && c.TweenMax || i.l).from(t, e, d(0, n)), r) }, p.fromTo = function (t, e, n, r, o) { var s = r.repeat && c.TweenMax || i.l; return r = d(0, r, n), e ? this.add(s.fromTo(t, e, n, r), o) : this.set(t, r, o) }, p.staggerTo = function (e, n, o, s, a, c, h, d) { var p, m, g = new t({ onComplete: c, onCompleteParams: h, callbackScope: d, smoothChildTiming: this.smoothChildTiming }), v = f(o.stagger || s), y = o.startAt, _ = o.cycle; for ("string" == typeof e && (e = i.l.selector(e) || e), r(e = e || []) && (e = function (t) { var e, n = [], i = t.length; for (e = 0; e !== i; n.push(t[e++])); return n }(e)), m = 0; m < e.length; m++)p = l(o), y && (p.startAt = l(y), y.cycle && u(p.startAt, e, m)), _ && (u(p, e, m), null != p.duration && (n = p.duration, delete p.duration)), g.to(e[m], n, p, v(m, e[m], e)); return this.add(g, a) }, p.staggerFrom = function (t, e, n, i, r, o, s, a) { return n.runBackwards = !0, this.staggerTo(t, e, d(0, n), i, r, o, s, a) }, p.staggerFromTo = function (t, e, n, i, r, o, s, a, c) { return i.startAt = n, this.staggerTo(t, e, d(0, i, n), r, o, s, a, c) }, p.call = function (t, e, n, r) { return this.add(i.l.delayedCall(0, t, e, n), r) }, p.set = function (t, e, n) { return this.add(new i.l(t, 0, d(0, e, null, !0)), n) }, t.exportRoot = function (e, n) { null == (e = e || {}).smoothChildTiming && (e.smoothChildTiming = !0); var r, o, s, a, c = new t(e), l = c._timeline; for (null == n && (n = !0), l._remove(c, !0), c._startTime = 0, c._rawPrevTime = c._time = c._totalTime = l._time, s = l._first; s;)a = s._next, n && s instanceof i.l && s.target === s.vars.onComplete || ((o = s._startTime - s._delay) < 0 && (r = 1), c.add(s, o)), s = a; return l.add(c, 0), r && c.totalDuration(), c }, p.add = function (e, n, r, s) { var a, c, l, u, h, d; if ("number" != typeof n && (n = this._parseTimeOrLabel(n, 0, !0, e)), !(e instanceof i.a)) { if (e instanceof Array || e && e.push && o(e)) { for (r = r || "normal", s = s || 0, a = n, c = e.length, l = 0; l < c; l++)o(u = e[l]) && (u = new t({ tweens: u })), this.add(u, a), "string" != typeof u && "function" != typeof u && ("sequence" === r ? a = u._startTime + u.totalDuration() / u._timeScale : "start" === r && (u._startTime -= u.delay())), a += s; return this._uncache(!0) } if ("string" == typeof e) return this.addLabel(e, n); if ("function" != typeof e) throw "Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string."; e = i.l.delayedCall(0, e) } if (i.i.prototype.add.call(this, e, n), (e._time || !e._duration && e._initted) && (a = (this.rawTime() - e._startTime) * e._timeScale, (!e._duration || Math.abs(Math.max(0, Math.min(e.totalDuration(), a))) - e._totalTime > 1e-5) && e.render(a, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (d = (h = this).rawTime() > e._startTime; h._timeline;)d && h._timeline.smoothChildTiming ? h.totalTime(h._totalTime, !0) : h._gc && h._enabled(!0, !1), h = h._timeline; return this }, p.remove = function (t) { if (t instanceof i.a) { this._remove(t, !1); var e = t._timeline = t.vars.useFrames ? i.a._rootFramesTimeline : i.a._rootTimeline; return t._startTime = (t._paused ? t._pauseTime : e._time) - (t._reversed ? t.totalDuration() - t._totalTime : t._totalTime) / t._timeScale, this } if (t instanceof Array || t && t.push && o(t)) { for (var n = t.length; --n > -1;)this.remove(t[n]); return this } return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t) }, p._remove = function (t, e) { return i.i.prototype._remove.call(this, t, e), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this }, p.append = function (t, e) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t)) }, p.insert = p.insertMultiple = function (t, e, n, i) { return this.add(t, e || 0, n, i) }, p.appendMultiple = function (t, e, n, i) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t), n, i) }, p.addLabel = function (t, e) { return this._labels[t] = this._parseTimeOrLabel(e), this }, p.addPause = function (t, e, n, r) { var o = i.l.delayedCall(0, h, n, r || this); return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t) }, p.removeLabel = function (t) { return delete this._labels[t], this }, p.getLabelTime = function (t) { return null != this._labels[t] ? this._labels[t] : -1 }, p._parseTimeOrLabel = function (t, e, n, r) { var s, a; if (r instanceof i.a && r.timeline === this) this.remove(r); else if (r && (r instanceof Array || r.push && o(r))) for (a = r.length; --a > -1;)r[a] instanceof i.a && r[a].timeline === this && this.remove(r[a]); if (s = "number" != typeof t || e ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof e) return this._parseTimeOrLabel(e, n && "number" == typeof t && null == this._labels[e] ? t - s : 0, n); if (e = e || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = s); else { if (-1 === (a = t.indexOf("="))) return null == this._labels[t] ? n ? this._labels[t] = s + e : e : this._labels[t] + e; e = parseInt(t.charAt(a - 1) + "1", 10) * Number(t.substr(a + 1)), t = a > 1 ? this._parseTimeOrLabel(t.substr(0, a - 1), 0, n) : s } return Number(t) + e }, p.seek = function (t, e) { return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e) }, p.stop = function () { return this.paused(!0) }, p.gotoAndPlay = function (t, e) { return this.play(t, e) }, p.gotoAndStop = function (t, e) { return this.pause(t, e) }, p.render = function (t, e, n) { this._gc && this._enabled(!0, !1); var i, r, o, c, l, u, h, d, f = this._time, p = this._dirty ? this.totalDuration() : this._totalDuration, m = this._startTime, g = this._timeScale, v = this._paused; if (f !== this._time && (t += this._time - f), this._hasPause && !this._forcingPlayhead && !e) { if (t > f) for (i = this._first; i && i._startTime <= t && !u;)i._duration || "isPause" !== i.data || i.ratio || 0 === i._startTime && 0 === this._rawPrevTime || (u = i), i = i._next; else for (i = this._last; i && i._startTime >= t && !u;)i._duration || "isPause" === i.data && i._rawPrevTime > 0 && (u = i), i = i._prev; u && (this._time = this._totalTime = t = u._startTime, d = this._startTime + (this._reversed ? this._duration - t : t) / this._timeScale) } if (t >= p - 1e-8 && t >= 0) this._totalTime = this._time = p, this._reversed || this._hasPausedChild() || (r = !0, c = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-8 || this._rawPrevTime < 0 || 1e-8 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (l = !0, this._rawPrevTime > 1e-8 && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-8, t = p + 1e-4; else if (t < 1e-8) if (this._totalTime = this._time = 0, t > -1e-8 && (t = 0), (0 !== f || 0 === this._duration && 1e-8 !== this._rawPrevTime && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (c = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = r = !0, c = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = t; else { if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-8, 0 === t && r) for (i = this._first; i && 0 === i._startTime;)i._duration || (r = !1), i = i._next; t = 0, this._initted || (l = !0) } else this._totalTime = this._time = this._rawPrevTime = t; if (this._time !== f && this._first || n || l || u) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== f && t > 0 && (this._active = !0), 0 === f && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (h = this._time) >= f) for (i = this._first; i && (o = i._next, h === this._time && (!this._paused || v));)(i._active || i._startTime <= h && !i._paused && !i._gc) && (u === i && (this.pause(), this._pauseTime = d), i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)), i = o; else for (i = this._last; i && (o = i._prev, h === this._time && (!this._paused || v));) { if (i._active || i._startTime <= f && !i._paused && !i._gc) { if (u === i) { for (u = i._prev; u && u.endTime() > this._time;)u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, n), u = u._prev; u = null, this.pause(), this._pauseTime = d } i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n) } i = o } this._onUpdate && (e || (s.length && a(), this._callback("onUpdate"))), c && (this._gc || m !== this._startTime && g === this._timeScale || (0 === this._time || p >= this.totalDuration()) && (r && (s.length && a(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c))) } }, p._hasPausedChild = function () { for (var e = this._first; e;) { if (e._paused || e instanceof t && e._hasPausedChild()) return !0; e = e._next } return !1 }, p.getChildren = function (t, e, n, r) { r = r || -9999999999; for (var o = [], s = this._first, a = 0; s;)s._startTime < r || (s instanceof i.l ? !1 !== e && (o[a++] = s) : (!1 !== n && (o[a++] = s), !1 !== t && (a = (o = o.concat(s.getChildren(!0, e, n))).length))), s = s._next; return o }, p.getTweensOf = function (t, e) { var n, r, o = this._gc, s = [], a = 0; for (o && this._enabled(!0, !0), r = (n = i.l.getTweensOf(t)).length; --r > -1;)(n[r].timeline === this || e && this._contains(n[r])) && (s[a++] = n[r]); return o && this._enabled(!1, !0), s }, p.recent = function () { return this._recent }, p._contains = function (t) { for (var e = t.timeline; e;) { if (e === this) return !0; e = e.timeline } return !1 }, p.shiftChildren = function (t, e, n) { n = n || 0; for (var i, r = this._first, o = this._labels; r;)r._startTime >= n && (r._startTime += t), r = r._next; if (e) for (i in o) o[i] >= n && (o[i] += t); return this._uncache(!0) }, p._kill = function (t, e) { if (!t && !e) return this._enabled(!1, !1); for (var n = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), i = n.length, r = !1; --i > -1;)n[i]._kill(t, e) && (r = !0); return r }, p.clear = function (t) { var e = this.getChildren(!1, !0, !0), n = e.length; for (this._time = this._totalTime = 0; --n > -1;)e[n]._enabled(!1, !1); return !1 !== t && (this._labels = {}), this._uncache(!0) }, p.invalidate = function () { for (var t = this._first; t;)t.invalidate(), t = t._next; return i.a.prototype.invalidate.call(this) }, p._enabled = function (t, e) { if (t === this._gc) for (var n = this._first; n;)n._enabled(t, !0), n = n._next; return i.i.prototype._enabled.call(this, t, e) }, p.totalTime = function (t, e, n) { this._forcingPlayhead = !0; var r = i.a.prototype.totalTime.apply(this, arguments); return this._forcingPlayhead = !1, r }, p.duration = function (t) { return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration) }, p.totalDuration = function (t) { if (!arguments.length) { if (this._dirty) { for (var e, n, i = 0, r = this, o = r._last, s = 999999999999; o;)e = o._prev, o._dirty && o.totalDuration(), o._startTime > s && r._sortChildren && !o._paused && !r._calculatingDuration ? (r._calculatingDuration = 1, r.add(o, o._startTime - o._delay), r._calculatingDuration = 0) : s = o._startTime, o._startTime < 0 && !o._paused && (i -= o._startTime, r._timeline.smoothChildTiming && (r._startTime += o._startTime / r._timeScale, r._time -= o._startTime, r._totalTime -= o._startTime, r._rawPrevTime -= o._startTime), r.shiftChildren(-o._startTime, !1, -9999999999), s = 0), (n = o._startTime + o._totalDuration / o._timeScale) > i && (i = n), o = e; r._duration = r._totalDuration = i, r._dirty = !1 } return this._totalDuration } return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this }, p.paused = function (t) { if (!1 === t && this._paused) for (var e = this._first; e;)e._startTime === this._time && "isPause" === e.data && (e._rawPrevTime = 0), e = e._next; return i.a.prototype.paused.apply(this, arguments) }, p.usesFrames = function () { for (var t = this._timeline; t._timeline;)t = t._timeline; return t === i.a._rootFramesTimeline }, p.rawTime = function (t) { return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale }, t }), !0); var r = i.m.TimelineLite;
/*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */i.k._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], (function () { var t = function (t) { r.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !!this.vars.yoyo, this._dirty = !0 }, e = i.l._internals, n = e.lazyTweens, o = e.lazyRender, s = i.k._gsDefine.globals, a = new i.b(null, null, 1, 0), c = t.prototype = new r; return c.constructor = t, c.kill()._gc = !1, t.version = "2.1.3", c.invalidate = function () { return this._yoyo = !!this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), r.prototype.invalidate.call(this) }, c.addCallback = function (t, e, n, r) { return this.add(i.l.delayedCall(0, t, n, r), e) }, c.removeCallback = function (t, e) { if (t) if (null == e) this._kill(null, t); else for (var n = this.getTweensOf(t, !1), i = n.length, r = this._parseTimeOrLabel(e); --i > -1;)n[i]._startTime === r && n[i]._enabled(!1, !1); return this }, c.removePause = function (t) { return this.removeCallback(r._internals.pauseCallback, t) }, c.tweenTo = function (t, e) { e = e || {}; var n, r, o, c = { ease: a, useFrames: this.usesFrames(), immediateRender: !1, lazy: !1 }, l = e.repeat && s.TweenMax || i.l; for (r in e) c[r] = e[r]; return c.time = this._parseTimeOrLabel(t), n = Math.abs(Number(c.time) - this._time) / this._timeScale || .001, o = new l(this, n, c), c.onStart = function () { o.target.paused(!0), o.vars.time === o.target.time() || n !== o.duration() || o.isFromTo || o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale).render(o.time(), !0, !0), e.onStart && e.onStart.apply(e.onStartScope || e.callbackScope || o, e.onStartParams || []) }, o }, c.tweenFromTo = function (t, e, n) { n = n || {}, t = this._parseTimeOrLabel(t), n.startAt = { onComplete: this.seek, onCompleteParams: [t], callbackScope: this }, n.immediateRender = !1 !== n.immediateRender; var i = this.tweenTo(e, n); return i.isFromTo = 1, i.duration(Math.abs(i.vars.time - t) / this._timeScale || .001) }, c.render = function (t, e, i) { this._gc && this._enabled(!0, !1); var r, s, a, c, l, u, h, d, f, p = this._time, m = this._dirty ? this.totalDuration() : this._totalDuration, g = this._duration, v = this._totalTime, y = this._startTime, _ = this._timeScale, x = this._rawPrevTime, b = this._paused, w = this._cycle; if (p !== this._time && (t += this._time - p), t >= m - 1e-8 && t >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (s = !0, c = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-8 || x < 0 || 1e-8 === x) && x !== t && this._first && (l = !0, x > 1e-8 && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-8, this._yoyo && 1 & this._cycle ? this._time = t = 0 : (this._time = g, t = g + 1e-4); else if (t < 1e-8) if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, t > -1e-8 && (t = 0), (0 !== p || 0 === g && 1e-8 !== x && (x > 0 || t < 0 && x >= 0) && !this._locked) && (c = "onReverseComplete", s = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = s = !0, c = "onReverseComplete") : x >= 0 && this._first && (l = !0), this._rawPrevTime = t; else { if (this._rawPrevTime = g || !e || t || this._rawPrevTime === t ? t : 1e-8, 0 === t && s) for (r = this._first; r && 0 === r._startTime;)r._duration || (s = !1), r = r._next; t = 0, this._initted || (l = !0) } else 0 === g && x < 0 && (l = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (u = g + this._repeatDelay, this._cycle = this._totalTime / u >> 0, this._cycle && this._cycle === this._totalTime / u && v <= t && this._cycle--, this._time = this._totalTime - this._cycle * u, this._yoyo && 1 & this._cycle && (this._time = g - this._time), this._time > g ? (this._time = g, t = g + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)); if (this._hasPause && !this._forcingPlayhead && !e) { if ((t = this._time) > p || this._repeat && w !== this._cycle) for (r = this._first; r && r._startTime <= t && !h;)r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (h = r), r = r._next; else for (r = this._last; r && r._startTime >= t && !h;)r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (h = r), r = r._prev; h && (f = this._startTime + (this._reversed ? this._duration - h._startTime : h._startTime) / this._timeScale, h._startTime < g && (this._time = this._rawPrevTime = t = h._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))) } if (this._cycle !== w && !this._locked) { var M = this._yoyo && 0 != (1 & w), T = M === (this._yoyo && 0 != (1 & this._cycle)), S = this._totalTime, E = this._cycle, A = this._rawPrevTime, P = this._time; if (this._totalTime = w * g, this._cycle < w ? M = !M : this._totalTime += g, this._time = p, this._rawPrevTime = 0 === g ? x - 1e-4 : x, this._cycle = w, this._locked = !0, p = M ? 0 : g, this.render(p, e, 0 === g), e || this._gc || this.vars.onRepeat && (this._cycle = E, this._locked = !1, this._callback("onRepeat")), p !== this._time) return; if (T && (this._cycle = w, this._locked = !0, p = M ? g + 1e-4 : -1e-4, this.render(p, !0, !1)), this._locked = !1, this._paused && !b) return; this._time = P, this._totalTime = S, this._cycle = E, this._rawPrevTime = A } if (this._time !== p && this._first || i || l || h) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== v && t > 0 && (this._active = !0), 0 === v && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (d = this._time) >= p) for (r = this._first; r && (a = r._next, d === this._time && (!this._paused || b));)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (h === r && (this.pause(), this._pauseTime = f), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = a; else for (r = this._last; r && (a = r._prev, d === this._time && (!this._paused || b));) { if (r._active || r._startTime <= p && !r._paused && !r._gc) { if (h === r) { for (h = r._prev; h && h.endTime() > this._time;)h.render(h._reversed ? h.totalDuration() - (t - h._startTime) * h._timeScale : (t - h._startTime) * h._timeScale, e, i), h = h._prev; h = null, this.pause(), this._pauseTime = f } r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i) } r = a } this._onUpdate && (e || (n.length && o(), this._callback("onUpdate"))), c && (this._locked || this._gc || y !== this._startTime && _ === this._timeScale || (0 === this._time || m >= this.totalDuration()) && (s && (n.length && o(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c))) } else v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")) }, c.getActive = function (t, e, n) { var i, r, o = [], s = this.getChildren(t || null == t, e || null == t, !!n), a = 0, c = s.length; for (i = 0; i < c; i++)(r = s[i]).isActive() && (o[a++] = r); return o }, c.getLabelAfter = function (t) { t || 0 !== t && (t = this._time); var e, n = this.getLabelsArray(), i = n.length; for (e = 0; e < i; e++)if (n[e].time > t) return n[e].name; return null }, c.getLabelBefore = function (t) { null == t && (t = this._time); for (var e = this.getLabelsArray(), n = e.length; --n > -1;)if (e[n].time < t) return e[n].name; return null }, c.getLabelsArray = function () { var t, e = [], n = 0; for (t in this._labels) e[n++] = { time: this._labels[t], name: t }; return e.sort((function (t, e) { return t.time - e.time })), e }, c.invalidate = function () { return this._locked = !1, r.prototype.invalidate.call(this) }, c.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0 }, c.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0 }, c.totalDuration = function (t) { return arguments.length ? -1 !== this._repeat && t ? this.timeScale(this.totalDuration() / t) : this : (this._dirty && (r.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration) }, c.time = function (t, e) { if (!arguments.length) return this._time; this._dirty && this.totalDuration(); var n = this._duration, i = this._cycle, r = i * (n + this._repeatDelay); return t > n && (t = n), this.totalTime(this._yoyo && 1 & i ? n - t + r : this._repeat ? t + r : t, e) }, c.repeat = function (t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, c.repeatDelay = function (t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, c.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, c.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8) }, t }), !0); var o = i.m.TimelineMax;
/*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/i.k._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], (function () { var t = function (t) { var e, n = [], i = t.length; for (e = 0; e !== i; n.push(t[e++])); return n }, e = function (t, e, n) { var i, r, o = t.cycle; for (i in o) r = o[i], t[i] = "function" == typeof r ? r(n, e[n], e) : r[n % r.length]; delete t.cycle }, n = function (t) { if ("function" == typeof t) return t; var e = "object" == typeof t ? t : { each: t }, n = e.ease, i = e.from || 0, r = e.base || 0, o = {}, s = isNaN(i), a = e.axis, c = { center: .5, end: 1 }[i] || 0; return function (t, l, u) { var h, d, f, p, m, g, v, y, _, x = (u || e).length, b = o[x]; if (!b) { if (!(_ = "auto" === e.grid ? 0 : (e.grid || [1 / 0])[0])) { for (v = -1 / 0; v < (v = u[_++].getBoundingClientRect().left) && _ < x;); _-- } for (b = o[x] = [], h = s ? Math.min(_, x) * c - .5 : i % _, d = s ? x * c / _ - .5 : i / _ | 0, v = 0, y = 1 / 0, g = 0; g < x; g++)f = g % _ - h, p = d - (g / _ | 0), b[g] = m = a ? Math.abs("y" === a ? p : f) : Math.sqrt(f * f + p * p), m > v && (v = m), m < y && (y = m); b.max = v - y, b.min = y, b.v = x = e.amount || e.each * (_ > x ? x - 1 : a ? "y" === a ? x / _ : _ : Math.max(_, x / _)) || 0, b.b = x < 0 ? r - x : r } return x = (b[t] - b.min) / b.max, b.b + (n ? n.getRatio(x) : x) * b.v } }, r = function (t, e, n) { i.l.call(this, t, e, n), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = r.prototype.render }, o = i.l._internals, s = o.isSelector, a = o.isArray, c = r.prototype = i.l.to({}, .1, {}), l = []; r.version = "2.1.3", c.constructor = r, c.kill()._gc = !1, r.killTweensOf = r.killDelayedCallsTo = i.l.killTweensOf, r.getTweensOf = i.l.getTweensOf, r.lagSmoothing = i.l.lagSmoothing, r.ticker = i.l.ticker, r.render = i.l.render, r.distribute = n, c.invalidate = function () { return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), i.l.prototype.invalidate.call(this) }, c.updateTo = function (t, e) { var n, r = this.ratio, o = this.vars.immediateRender || t.immediateRender; for (n in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[n] = t[n]; if (this._initted || o) if (e) this._initted = !1, o && this.render(0, !0, !0); else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i.l._onPluginEvent("_onDisable", this), this._time / this._duration > .998) { var s = this._totalTime; this.render(0, !0, !1), this._initted = !1, this.render(s, !0, !1) } else if (this._initted = !1, this._init(), this._time > 0 || o) for (var a, c = 1 / (1 - r), l = this._firstPT; l;)a = l.s + l.c, l.c *= c, l.s = a - l.c, l = l._next; return this }, c.render = function (t, e, n) { this._initted || 0 === this._duration && this.vars.repeat && this.invalidate(); var r, s, a, c, l, u, h, d, f, p = this._dirty ? this.totalDuration() : this._totalDuration, m = this._time, g = this._totalTime, v = this._cycle, y = this._duration, _ = this._rawPrevTime; if (t >= p - 1e-8 && t >= 0 ? (this._totalTime = p, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, s = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (_ < 0 || t <= 0 && t >= -1e-8 || 1e-8 === _ && "isPause" !== this.data) && _ !== t && (n = !0, _ > 1e-8 && (s = "onReverseComplete")), this._rawPrevTime = d = !e || t || _ === t ? t : 1e-8)) : t < 1e-8 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== g || 0 === y && _ > 0) && (s = "onReverseComplete", r = this._reversed), t > -1e-8 ? t = 0 : t < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || n) && (_ >= 0 && (n = !0), this._rawPrevTime = d = !e || t || _ === t ? t : 1e-8)), this._initted || (n = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (c = y + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && g <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 != (1 & this._cycle) && (this._time = y - this._time, (f = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== f || this._initted ? this._yoyoEase = f = !0 === f ? this._ease : f instanceof i.b ? f : i.b.map[f] : (f = this.vars.ease, this._yoyoEase = f = f ? f instanceof i.b ? f : "function" == typeof f ? new i.b(f, this.vars.easeParams) : i.b.map[f] || i.l.defaultEase : i.l.defaultEase)), this.ratio = f ? 1 - f.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !f ? (l = this._time / y, (1 === (u = this._easeType) || 3 === u && l >= .5) && (l = 1 - l), 3 === u && (l *= 2), 1 === (h = this._easePower) ? l *= l : 2 === h ? l *= l * l : 3 === h ? l *= l * l * l : 4 === h && (l *= l * l * l * l), this.ratio = 1 === u ? 1 - l : 2 === u ? l : this._time / y < .5 ? l / 2 : 1 - l / 2) : f || (this.ratio = this._ease.getRatio(this._time / y))), m !== this._time || n || v !== this._cycle) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = g, this._rawPrevTime = _, this._cycle = v, o.lazyTweens.push(this), void (this._lazy = [t, e]); !this._time || r || f ? r && this._ease._calcEnd && !f && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y) } for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== m && t >= 0 && (this._active = !0), 0 === g && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, n) : s || (s = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || e || this._callback("onStart"))), a = this._firstPT; a;)a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next; this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, n), e || (this._totalTime !== g || s) && this._callback("onUpdate")), this._cycle !== v && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), s && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[s] && this._callback(s), 0 === y && 1e-8 === this._rawPrevTime && 1e-8 !== d && (this._rawPrevTime = 0))) } else g !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")) }, r.to = function (t, e, n) { return new r(t, e, n) }, r.from = function (t, e, n) { return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new r(t, e, n) }, r.fromTo = function (t, e, n, i) { return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, new r(t, e, i) }, r.staggerTo = r.allTo = function (o, c, u, h, d, f, p) { var m, g, v, y, _ = [], x = n(u.stagger || h), b = u.cycle, w = (u.startAt || l).cycle; for (a(o) || ("string" == typeof o && (o = i.l.selector(o) || o), s(o) && (o = t(o))), m = (o = o || []).length - 1, v = 0; v <= m; v++) { for (y in g = {}, u) g[y] = u[y]; if (b && (e(g, o, v), null != g.duration && (c = g.duration, delete g.duration)), w) { for (y in w = g.startAt = {}, u.startAt) w[y] = u.startAt[y]; e(g.startAt, o, v) } g.delay = x(v, o[v], o) + (g.delay || 0), v === m && d && (g.onComplete = function () { u.onComplete && u.onComplete.apply(u.onCompleteScope || this, arguments), d.apply(p || u.callbackScope || this, f || l) }), _[v] = new r(o[v], c, g) } return _ }, r.staggerFrom = r.allFrom = function (t, e, n, i, o, s, a) { return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, r.staggerTo(t, e, n, i, o, s, a) }, r.staggerFromTo = r.allFromTo = function (t, e, n, i, o, s, a, c) { return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, r.staggerTo(t, e, i, o, s, a, c) }, r.delayedCall = function (t, e, n, i, o) { return new r(e, 0, { delay: t, onComplete: e, onCompleteParams: n, callbackScope: i, onReverseComplete: e, onReverseCompleteParams: n, immediateRender: !1, useFrames: o, overwrite: 0 }) }, r.set = function (t, e) { return new r(t, 0, e) }, r.isTweening = function (t) { return i.l.getTweensOf(t, !0).length > 0 }; var u = function (t, e) { for (var n = [], r = 0, o = t._first; o;)o instanceof i.l ? n[r++] = o : (e && (n[r++] = o), r = (n = n.concat(u(o, e))).length), o = o._next; return n }, h = r.getAllTweens = function (t) { return u(i.a._rootTimeline, t).concat(u(i.a._rootFramesTimeline, t)) }; r.killAll = function (t, e, n, r) { null == e && (e = !0), null == n && (n = !0); var o, s, a, c = h(0 != r), l = c.length, u = e && n && r; for (a = 0; a < l; a++)s = c[a], (u || s instanceof i.i || (o = s.target === s.vars.onComplete) && n || e && !o) && (t ? s.totalTime(s._reversed ? 0 : s.totalDuration()) : s._enabled(!1, !1)) }, r.killChildTweensOf = function (e, n) { if (null != e) { var c, l, u, h, d, f = o.tweenLookup; if ("string" == typeof e && (e = i.l.selector(e) || e), s(e) && (e = t(e)), a(e)) for (h = e.length; --h > -1;)r.killChildTweensOf(e[h], n); else { for (u in c = [], f) for (l = f[u].target.parentNode; l;)l === e && (c = c.concat(f[u].tweens)), l = l.parentNode; for (d = c.length, h = 0; h < d; h++)n && c[h].totalTime(c[h].totalDuration()), c[h]._enabled(!1, !1) } } }; var d = function (t, e, n, r) { e = !1 !== e, n = !1 !== n; for (var o, s, a = h(r = !1 !== r), c = e && n && r, l = a.length; --l > -1;)s = a[l], (c || s instanceof i.i || (o = s.target === s.vars.onComplete) && n || e && !o) && s.paused(t) }; return r.pauseAll = function (t, e, n) { d(!0, t, e, n) }, r.resumeAll = function (t, e, n) { d(!1, t, e, n) }, r.globalTimeScale = function (t) { var e = i.a._rootTimeline, n = i.l.ticker.time; return arguments.length ? (t = t || 1e-8, e._startTime = n - (n - e._startTime) * e._timeScale / t, e = i.a._rootFramesTimeline, n = i.l.ticker.frame, e._startTime = n - (n - e._startTime) * e._timeScale / t, e._timeScale = i.a._rootTimeline._timeScale = t, t) : e._timeScale }, c.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this.duration() ? this._time / this._duration : this.ratio }, c.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() }, c.time = function (t, e) { if (!arguments.length) return this._time; this._dirty && this.totalDuration(); var n = this._duration, i = this._cycle, r = i * (n + this._repeatDelay); return t > n && (t = n), this.totalTime(this._yoyo && 1 & i ? n - t + r : this._repeat ? t + r : t, e) }, c.duration = function (t) { return arguments.length ? i.a.prototype.duration.call(this, t) : this._duration }, c.totalDuration = function (t) { return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration) }, c.repeat = function (t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, c.repeatDelay = function (t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, c.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, r }), !0); var s = i.m.TweenMax;
    /*!
     * VERSION: 2.1.3
     * DATE: 2019-05-17
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    i.k._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], (function () { var t, e, n, r, o = function () { i.j.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio }, s = i.k._gsDefine.globals, a = {}, c = o.prototype = new i.j("css"); c.constructor = o, o.version = "2.1.3", o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = "compensated", o.defaultSmoothOrigin = !0, c = "px", o.suffixMap = { top: c, right: c, bottom: c, left: c, width: c, height: c, fontSize: c, padding: c, margin: c, perspective: c, lineHeight: "" }; var l, u, h, d, f, p, m, g, v = /(?:\-|\.|\b)(\d|\.|e\-)+/g, y = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, _ = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b),?/gi, b = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, w = /(?:\d|\-|\+|=|#|\.)*/g, M = /opacity *= *([^)]*)/i, T = /opacity:([^;]*)/i, S = /alpha\(opacity *=.+?\)/i, E = /^(rgb|hsl)/, A = /([A-Z])/g, P = /-([a-z])/gi, L = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, R = function (t, e) { return e.toUpperCase() }, O = /(?:Left|Right|Width)/i, C = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, I = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, D = /,(?=[^\)]*(?:\(|$))/gi, N = /[\s,\(]/i, k = Math.PI / 180, B = 180 / Math.PI, z = {}, F = { style: {} }, U = i.k.document || { createElement: function () { return F } }, H = function (t, e) { var n = U.createElementNS ? U.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : U.createElement(t); return n.style ? n : U.createElement(t) }, G = H("div"), j = H("img"), V = o._internals = { _specialProps: a }, W = (i.k.navigator || {}).userAgent || "", q = function () { var t = W.indexOf("Android"), e = H("a"); return h = -1 !== W.indexOf("Safari") && -1 === W.indexOf("Chrome") && (-1 === t || parseFloat(W.substr(t + 8, 2)) > 3), f = h && parseFloat(W.substr(W.indexOf("Version/") + 8, 2)) < 6, d = -1 !== W.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(W) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(W)) && (p = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity)) }(), X = function (t) { return M.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1 }, Y = function (t) { i.k.console && console.log(t) }, Z = "", J = "", Q = function (t, e) { var n, i, r = (e = e || G).style; if (void 0 !== r[t]) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1), n = ["O", "Moz", "ms", "Ms", "Webkit"], i = 5; --i > -1 && void 0 === r[n[i] + t];); return i >= 0 ? (Z = "-" + (J = 3 === i ? "ms" : n[i]).toLowerCase() + "-", J + t) : null }, $ = "undefined" != typeof window ? window : U.defaultView || { getComputedStyle: function () { } }, K = function (t) { return $.getComputedStyle(t) }, tt = o.getStyle = function (t, e, n, i, r) { var o; return q || "opacity" !== e ? (!i && t.style[e] ? o = t.style[e] : (n = n || K(t)) ? o = n[e] || n.getPropertyValue(e) || n.getPropertyValue(e.replace(A, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : X(t) }, et = V.convertToPixels = function (t, e, n, r, s) { if ("px" === r || !r && "lineHeight" !== e) return n; if ("auto" === r || !n) return 0; var a, c, l, u = O.test(e), h = t, d = G.style, f = n < 0, p = 1 === n; if (f && (n = -n), p && (n *= 100), "lineHeight" !== e || r) if ("%" === r && -1 !== e.indexOf("border")) a = n / 100 * (u ? t.clientWidth : t.clientHeight); else { if (d.cssText = "border:0 solid red;position:" + tt(t, "position") + ";line-height:0;", "%" !== r && h.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[u ? "borderLeftWidth" : "borderTopWidth"] = n + r; else { if (h = t.parentNode || U.body, -1 !== tt(h, "display").indexOf("flex") && (d.position = "absolute"), c = h._gsCache, l = i.l.ticker.frame, c && u && c.time === l) return c.width * n / 100; d[u ? "width" : "height"] = n + r } h.appendChild(G), a = parseFloat(G[u ? "offsetWidth" : "offsetHeight"]), h.removeChild(G), u && "%" === r && !1 !== o.cacheWidths && ((c = h._gsCache = h._gsCache || {}).time = l, c.width = a / n * 100), 0 !== a || s || (a = et(t, e, n, r, !0)) } else c = K(t).lineHeight, t.style.lineHeight = n, a = parseFloat(K(t).lineHeight), t.style.lineHeight = c; return p && (a /= 100), f ? -a : a }, nt = V.calculateOffset = function (t, e, n) { if ("absolute" !== tt(t, "position", n)) return 0; var i = "left" === e ? "Left" : "Top", r = tt(t, "margin" + i, n); return t["offset" + i] - (et(t, e, parseFloat(r), r.replace(w, "")) || 0) }, it = function (t, e) { var n, i, r, o = {}; if (e = e || K(t)) if (n = e.length) for (; --n > -1;)-1 !== (r = e[n]).indexOf("-transform") && Dt !== r || (o[r.replace(P, R)] = e.getPropertyValue(r)); else for (n in e) -1 !== n.indexOf("Transform") && It !== n || (o[n] = e[n]); else if (e = t.currentStyle || t.style) for (n in e) "string" == typeof n && void 0 === o[n] && (o[n.replace(P, R)] = e[n]); return q || (o.opacity = X(t)), i = Xt(t, e, !1), o.rotation = i.rotation, o.skewX = i.skewX, o.scaleX = i.scaleX, o.scaleY = i.scaleY, o.x = i.x, o.y = i.y, kt && (o.z = i.z, o.rotationX = i.rotationX, o.rotationY = i.rotationY, o.scaleZ = i.scaleZ), o.filters && delete o.filters, o }, rt = function (t, e, n, i, r) { var o, s, a, c = {}, l = t.style; for (s in n) "cssText" !== s && "length" !== s && isNaN(s) && (e[s] !== (o = n[s]) || r && r[s]) && -1 === s.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (c[s] = "auto" !== o || "left" !== s && "top" !== s ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[s] || "" === e[s].replace(b, "") ? o : 0 : nt(t, s), void 0 !== l[s] && (a = new _t(l, s, l[s], a)))); if (i) for (s in i) "className" !== s && (c[s] = i[s]); return { difs: c, firstMPT: a } }, ot = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, st = ["marginLeft", "marginRight", "marginTop", "marginBottom"], at = function (t, e, n) { if ("svg" === (t.nodeName + "").toLowerCase()) return (n || K(t))[e] || 0; if (t.getCTM && Vt(t)) return t.getBBox()[e] || 0; var i = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight), r = ot[e], o = r.length; for (n = n || K(t); --o > -1;)i -= parseFloat(tt(t, "padding" + r[o], n, !0)) || 0, i -= parseFloat(tt(t, "border" + r[o] + "Width", n, !0)) || 0; return i }, ct = function (t, e) { if ("contain" === t || "auto" === t || "auto auto" === t) return t + " "; null != t && "" !== t || (t = "0 0"); var n, i = t.split(" "), r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0], o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1]; if (i.length > 3 && !e) { for (i = t.split(", ").join(",").split(","), t = [], n = 0; n < i.length; n++)t.push(ct(i[n])); return t.join(",") } return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + o + (i.length > 2 ? " " + i[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== o.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(r.replace(b, "")), e.oy = parseFloat(o.replace(b, "")), e.v = t), e || t }, lt = function (t, e) { return "function" == typeof t && (t = t(g, m)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0 }, ut = function (t, e) { "function" == typeof t && (t = t(g, m)); var n = "string" == typeof t && "=" === t.charAt(1); return "string" == typeof t && "v" === t.charAt(t.length - 2) && (t = (n ? t.substr(0, 2) : 0) + window["inner" + ("vh" === t.substr(-2) ? "Height" : "Width")] * (parseFloat(n ? t.substr(2) : t) / 100)), null == t ? e : n ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0 }, ht = function (t, e, n, i) { var r, o, s, a; return "function" == typeof t && (t = t(g, m)), null == t ? s = e : "number" == typeof t ? s = t : (360, r = t.split("_"), o = ((a = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(r[0].substr(2)) : parseFloat(r[0])) * (-1 === t.indexOf("rad") ? 1 : B) - (a ? 0 : e), r.length && (i && (i[n] = e + o), -1 !== t.indexOf("short") && (o %= 360) !== o % 180 && (o = o < 0 ? o + 360 : o - 360), -1 !== t.indexOf("_cw") && o < 0 ? o = (o + 3599999999640) % 360 - 360 * (o / 360 | 0) : -1 !== t.indexOf("ccw") && o > 0 && (o = (o - 3599999999640) % 360 - 360 * (o / 360 | 0))), s = e + o), s < 1e-6 && s > -1e-6 && (s = 0), s }, dt = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, ft = function (t, e, n) { return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0 }, pt = o.parseColor = function (t, e) { var n, i, r, o, s, a, c, l, u, h, d; if (t) if ("number" == typeof t) n = [t >> 16, t >> 8 & 255, 255 & t]; else { if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), dt[t]) n = dt[t]; else if ("#" === t.charAt(0)) 4 === t.length && (i = t.charAt(1), r = t.charAt(2), o = t.charAt(3), t = "#" + i + i + r + r + o + o), n = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t]; else if ("hsl" === t.substr(0, 3)) if (n = d = t.match(v), e) { if (-1 !== t.indexOf("=")) return t.match(y) } else s = Number(n[0]) % 360 / 360, a = Number(n[1]) / 100, i = 2 * (c = Number(n[2]) / 100) - (r = c <= .5 ? c * (a + 1) : c + a - c * a), n.length > 3 && (n[3] = Number(n[3])), n[0] = ft(s + 1 / 3, i, r), n[1] = ft(s, i, r), n[2] = ft(s - 1 / 3, i, r); else n = t.match(v) || dt.transparent; n[0] = Number(n[0]), n[1] = Number(n[1]), n[2] = Number(n[2]), n.length > 3 && (n[3] = Number(n[3])) } else n = dt.black; return e && !d && (i = n[0] / 255, r = n[1] / 255, o = n[2] / 255, c = ((l = Math.max(i, r, o)) + (u = Math.min(i, r, o))) / 2, l === u ? s = a = 0 : (h = l - u, a = c > .5 ? h / (2 - l - u) : h / (l + u), s = l === i ? (r - o) / h + (r < o ? 6 : 0) : l === r ? (o - i) / h + 2 : (i - r) / h + 4, s *= 60), n[0] = s + .5 | 0, n[1] = 100 * a + .5 | 0, n[2] = 100 * c + .5 | 0), n }, mt = function (t, e) { var n, i, r, o = t.match(gt) || [], s = 0, a = ""; if (!o.length) return t; for (n = 0; n < o.length; n++)i = o[n], s += (r = t.substr(s, t.indexOf(i, s) - s)).length + i.length, 3 === (i = pt(i, e)).length && i.push(1), a += r + (e ? "hsla(" + i[0] + "," + i[1] + "%," + i[2] + "%," + i[3] : "rgba(" + i.join(",")) + ")"; return a + t.substr(s) }, gt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; for (c in dt) gt += "|" + c + "\\b"; gt = new RegExp(gt + ")", "gi"), o.colorStringFilter = function (t) { var e, n = t[0] + " " + t[1]; gt.test(n) && (e = -1 !== n.indexOf("hsl(") || -1 !== n.indexOf("hsla("), t[0] = mt(t[0], e), t[1] = mt(t[1], e)), gt.lastIndex = 0 }, i.l.defaultStringFilter || (i.l.defaultStringFilter = o.colorStringFilter); var vt = function (t, e, n, i) { if (null == t) return function (t) { return t }; var r, o = e ? (t.match(gt) || [""])[0] : "", s = t.split(o).join("").match(_) || [], a = t.substr(0, t.indexOf(s[0])), c = ")" === t.charAt(t.length - 1) ? ")" : "", l = -1 !== t.indexOf(" ") ? " " : ",", u = s.length, h = u > 0 ? s[0].replace(v, "") : ""; return u ? r = e ? function (t) { var e, d, f, p; if ("number" == typeof t) t += h; else if (i && D.test(t)) { for (p = t.replace(D, "|").split("|"), f = 0; f < p.length; f++)p[f] = r(p[f]); return p.join(",") } if (e = (t.match(gt) || [o])[0], f = (d = t.split(e).join("").match(_) || []).length, u > f--) for (; ++f < u;)d[f] = n ? d[(f - 1) / 2 | 0] : s[f]; return a + d.join(l) + l + e + c + (-1 !== t.indexOf("inset") ? " inset" : "") } : function (t) { var e, o, d; if ("number" == typeof t) t += h; else if (i && D.test(t)) { for (o = t.replace(D, "|").split("|"), d = 0; d < o.length; d++)o[d] = r(o[d]); return o.join(",") } if (d = (e = t.match("," === l ? _ : x) || []).length, u > d--) for (; ++d < u;)e[d] = n ? e[(d - 1) / 2 | 0] : s[d]; return (a && "none" !== t && t.substr(0, t.indexOf(e[0])) || a) + e.join(l) + c } : function (t) { return t } }, yt = function (t) { return t = t.split(","), function (e, n, i, r, o, s, a) { var c, l = (n + "").split(" "); for (a = {}, c = 0; c < 4; c++)a[t[c]] = l[c] = l[c] || l[(c - 1) / 2 >> 0]; return r.parse(e, a, o, s) } }, _t = (V._setPluginRatio = function (t) { this.plugin.setRatio(t); for (var e, n, i, r, o, s = this.data, a = s.proxy, c = s.firstMPT; c;)e = a[c.v], c.r ? e = c.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), c.t[c.p] = e, c = c._next; if (s.autoRotate && (s.autoRotate.rotation = s.mod ? s.mod.call(this._tween, a.rotation, this.t, this._tween) : a.rotation), 1 === t || 0 === t) for (c = s.firstMPT, o = 1 === t ? "e" : "b"; c;) { if ((n = c.t).type) { if (1 === n.type) { for (r = n.xs0 + n.s + n.xs1, i = 1; i < n.l; i++)r += n["xn" + i] + n["xs" + (i + 1)]; n[o] = r } } else n[o] = n.s + n.xs0; c = c._next } }, function (t, e, n, i, r) { this.t = t, this.p = e, this.v = n, this.r = r, i && (i._prev = this, this._next = i) }), xt = (V._parseToProxy = function (t, e, n, i, r, o) { var s, a, c, l, u, h = i, d = {}, f = {}, p = n._transform, m = z; for (n._transform = null, z = e, i = u = n.parse(t, e, i, r), z = m, o && (n._transform = p, h && (h._prev = null, h._prev && (h._prev._next = null))); i && i !== h;) { if (i.type <= 1 && (f[a = i.p] = i.s + i.c, d[a] = i.s, o || (l = new _t(i, "s", a, l, i.r), i.c = 0), 1 === i.type)) for (s = i.l; --s > 0;)c = "xn" + s, f[a = i.p + "_" + c] = i.data[c], d[a] = i[c], o || (l = new _t(i, c, a, l, i.rxp[c])); i = i._next } return { proxy: d, end: f, firstMPT: l, pt: u } }, V.CSSPropTween = function (e, n, i, o, s, a, c, l, u, h, d) { this.t = e, this.p = n, this.s = i, this.c = o, this.n = c || n, e instanceof xt || r.push(this.n), this.r = l ? "function" == typeof l ? l : Math.round : l, this.type = a || 0, u && (this.pr = u, t = !0), this.b = void 0 === h ? i : h, this.e = void 0 === d ? i + o : d, s && (this._next = s, s._prev = this) }), bt = function (t, e, n, i, r, o) { var s = new xt(t, e, n, i - n, r, -1, o); return s.b = n, s.e = s.xs0 = i, s }, wt = o.parseComplex = function (t, e, n, i, r, s, a, c, u, h) { n = n || s || "", "function" == typeof i && (i = i(g, m)), a = new xt(t, e, 0, 0, a, h ? 2 : 1, null, !1, c, n, i), i += "", r && gt.test(i + n) && (i = [n, i], o.colorStringFilter(i), n = i[0], i = i[1]); var d, f, p, _, x, b, w, M, T, S, E, A, P, L = n.split(", ").join(",").split(" "), R = i.split(", ").join(",").split(" "), O = L.length, C = !1 !== l; for (-1 === i.indexOf(",") && -1 === n.indexOf(",") || (-1 !== (i + n).indexOf("rgb") || -1 !== (i + n).indexOf("hsl") ? (L = L.join(" ").replace(D, ", ").split(" "), R = R.join(" ").replace(D, ", ").split(" ")) : (L = L.join(" ").split(",").join(", ").split(" "), R = R.join(" ").split(",").join(", ").split(" ")), O = L.length), O !== R.length && (O = (L = (s || "").split(" ")).length), a.plugin = u, a.setRatio = h, gt.lastIndex = 0, d = 0; d < O; d++)if (_ = L[d], x = R[d] + "", (M = parseFloat(_)) || 0 === M) a.appendXtra("", M, lt(x, M), x.replace(y, ""), !(!C || -1 === x.indexOf("px")) && Math.round, !0); else if (r && gt.test(_)) A = ")" + ((A = x.indexOf(")") + 1) ? x.substr(A) : ""), P = -1 !== x.indexOf("hsl") && q, S = x, _ = pt(_, P), x = pt(x, P), (T = _.length + x.length > 6) && !q && 0 === x[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[d]).join("transparent")) : (q || (T = !1), P ? a.appendXtra(S.substr(0, S.indexOf("hsl")) + (T ? "hsla(" : "hsl("), _[0], lt(x[0], _[0]), ",", !1, !0).appendXtra("", _[1], lt(x[1], _[1]), "%,", !1).appendXtra("", _[2], lt(x[2], _[2]), T ? "%," : "%" + A, !1) : a.appendXtra(S.substr(0, S.indexOf("rgb")) + (T ? "rgba(" : "rgb("), _[0], x[0] - _[0], ",", Math.round, !0).appendXtra("", _[1], x[1] - _[1], ",", Math.round).appendXtra("", _[2], x[2] - _[2], T ? "," : A, Math.round), T && (_ = _.length < 4 ? 1 : _[3], a.appendXtra("", _, (x.length < 4 ? 1 : x[3]) - _, A, !1))), gt.lastIndex = 0; else if (b = _.match(v)) { if (!(w = x.match(y)) || w.length !== b.length) return a; for (p = 0, f = 0; f < b.length; f++)E = b[f], S = _.indexOf(E, p), a.appendXtra(_.substr(p, S - p), Number(E), lt(w[f], E), "", !(!C || "px" !== _.substr(S + E.length, 2)) && Math.round, 0 === f), p = S + E.length; a["xs" + a.l] += _.substr(p) } else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + x : x; if (-1 !== i.indexOf("=") && a.data) { for (A = a.xs0 + a.data.s, d = 1; d < a.l; d++)A += a["xs" + d] + a.data["xn" + d]; a.e = A + a["xs" + d] } return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a }, Mt = 9; for ((c = xt.prototype).l = c.pr = 0; --Mt > 0;)c["xn" + Mt] = 0, c["xs" + Mt] = ""; c.xs0 = "", c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null, c.appendXtra = function (t, e, n, i, r, o) { var s = this, a = s.l; return s["xs" + a] += o && (a || s["xs" + a]) ? " " + t : t || "", n || 0 === a || s.plugin ? (s.l++, s.type = s.setRatio ? 2 : 1, s["xs" + s.l] = i || "", a > 0 ? (s.data["xn" + a] = e + n, s.rxp["xn" + a] = r, s["xn" + a] = e, s.plugin || (s.xfirst = new xt(s, "xn" + a, e, n, s.xfirst || s, 0, s.n, r, s.pr), s.xfirst.xs0 = 0), s) : (s.data = { s: e + n }, s.rxp = {}, s.s = e, s.c = n, s.r = r, s)) : (s["xs" + a] += e + (i || ""), s) }; var Tt = function (t, e) { e = e || {}, this.p = e.prefix && Q(t) || t, a[t] = a[this.p] = this, this.format = e.formatter || vt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.allowFunc = e.allowFunc, this.pr = e.priority || 0 }, St = V._registerComplexSpecialProp = function (t, e, n) { "object" != typeof e && (e = { parser: n }); var i, r = t.split(","), o = e.defaultValue; for (n = n || [o], i = 0; i < r.length; i++)e.prefix = 0 === i && e.prefix, e.defaultValue = n[i] || o, new Tt(r[i], e) }, Et = V._registerPluginProp = function (t) { if (!a[t]) { var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin"; St(t, { parser: function (t, n, i, r, o, c, l) { var u = s.com.greensock.plugins[e]; return u ? (u._cssRegister(), a[i].parse(t, n, i, r, o, c, l)) : (Y("Error: " + e + " js file not loaded."), o) } }) } }; (c = Tt.prototype).parseComplex = function (t, e, n, i, r, o) { var s, a, c, l, u, h, d = this.keyword; if (this.multi && (D.test(n) || D.test(e) ? (a = e.replace(D, "|").split("|"), c = n.replace(D, "|").split("|")) : d && (a = [e], c = [n])), c) { for (l = c.length > a.length ? c.length : a.length, s = 0; s < l; s++)e = a[s] = a[s] || this.dflt, n = c[s] = c[s] || this.dflt, d && (u = e.indexOf(d)) !== (h = n.indexOf(d)) && (-1 === h ? a[s] = a[s].split(d).join("") : -1 === u && (a[s] += " " + d)); e = a.join(", "), n = c.join(", ") } return wt(t, this.p, e, n, this.clrs, this.dflt, i, this.pr, r, o) }, c.parse = function (t, e, i, r, o, s, a) { return this.parseComplex(t.style, this.format(tt(t, this.p, n, !1, this.dflt)), this.format(e), o, s) }, o.registerSpecialProp = function (t, e, n) { St(t, { parser: function (t, i, r, o, s, a, c) { var l = new xt(t, r, 0, 0, s, 2, r, !1, n); return l.plugin = a, l.setRatio = e(t, i, o._tween, r), l }, priority: n }) }, o.useSVGTransformAttr = !0; var At, Pt, Lt, Rt, Ot, Ct = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","), It = Q("transform"), Dt = Z + "transform", Nt = Q("transformOrigin"), kt = null !== Q("perspective"), Bt = V.Transform = function () { this.perspective = parseFloat(o.defaultTransformPerspective) || 0, this.force3D = !(!1 === o.defaultForce3D || !kt) && (o.defaultForce3D || "auto") }, zt = i.k.SVGElement, Ft = function (t, e, n) { var i, r = U.createElementNS("http://www.w3.org/2000/svg", t), o = /([a-z])([A-Z])/g; for (i in n) r.setAttributeNS(null, i.replace(o, "$1-$2").toLowerCase(), n[i]); return e.appendChild(r), r }, Ut = U.documentElement || {}, Ht = (Ot = p || /Android/i.test(W) && !i.k.chrome, U.createElementNS && Ut.appendChild && !Ot && (Pt = Ft("svg", Ut), Rt = (Lt = Ft("rect", Pt, { width: 100, height: 50, x: 100 })).getBoundingClientRect().width, Lt.style[Nt] = "50% 50%", Lt.style[It] = "scaleX(0.5)", Ot = Rt === Lt.getBoundingClientRect().width && !(d && kt), Ut.removeChild(Pt)), Ot), Gt = function (t, e, n, i, r, s) { var a, c, l, u, h, d, f, p, m, g, v, y, _, x, b = t._gsTransform, w = qt(t, !0); b && (_ = b.xOrigin, x = b.yOrigin), (!i || (a = i.split(" ")).length < 2) && (0 === (f = t.getBBox()).x && 0 === f.y && f.width + f.height === 0 && (f = { x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0, y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0, width: 0, height: 0 }), a = [(-1 !== (e = ct(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * f.width : parseFloat(e[0])) + f.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * f.height : parseFloat(e[1])) + f.y]), n.xOrigin = u = parseFloat(a[0]), n.yOrigin = h = parseFloat(a[1]), i && w !== Wt && (d = w[0], f = w[1], p = w[2], m = w[3], g = w[4], v = w[5], (y = d * m - f * p) && (c = u * (m / y) + h * (-p / y) + (p * v - m * g) / y, l = u * (-f / y) + h * (d / y) - (d * v - f * g) / y, u = n.xOrigin = a[0] = c, h = n.yOrigin = a[1] = l)), b && (s && (n.xOffset = b.xOffset, n.yOffset = b.yOffset, b = n), r || !1 !== r && !1 !== o.defaultSmoothOrigin ? (c = u - _, l = h - x, b.xOffset += c * w[0] + l * w[2] - c, b.yOffset += c * w[1] + l * w[3] - l) : b.xOffset = b.yOffset = 0), s || t.setAttribute("data-svg-origin", a.join(" ")) }, jt = function (t) { var e, n = H("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, r = this.nextSibling, o = this.style.cssText; if (Ut.appendChild(n), n.appendChild(this), this.style.display = "block", t) try { e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = jt } catch (t) { } else this._originalGetBBox && (e = this._originalGetBBox()); return r ? i.insertBefore(this, r) : i.appendChild(this), Ut.removeChild(n), this.style.cssText = o, e }, Vt = function (t) { return !(!zt || !t.getCTM || t.parentNode && !t.ownerSVGElement || !function (t) { try { return t.getBBox() } catch (e) { return jt.call(t, !0) } }(t)) }, Wt = [1, 0, 0, 1, 0, 0], qt = function (t, e) { var n, i, r, o, s, a, c, l = t._gsTransform || new Bt, u = t.style; if (It ? i = tt(t, Dt, null, !0) : t.currentStyle && (i = (i = t.currentStyle.filter.match(C)) && 4 === i.length ? [i[0].substr(4), Number(i[2].substr(4)), Number(i[1].substr(4)), i[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), n = !i || "none" === i || "matrix(1, 0, 0, 1, 0, 0)" === i, It && n && !t.offsetParent && t !== Ut && (o = u.display, u.display = "block", (c = t.parentNode) && t.offsetParent || (s = 1, a = t.nextSibling, Ut.appendChild(t)), n = !(i = tt(t, Dt, null, !0)) || "none" === i || "matrix(1, 0, 0, 1, 0, 0)" === i, o ? u.display = o : Qt(u, "display"), s && (a ? c.insertBefore(t, a) : c ? c.appendChild(t) : Ut.removeChild(t))), (l.svg || t.getCTM && Vt(t)) && (n && -1 !== (u[It] + "").indexOf("matrix") && (i = u[It], n = 0), r = t.getAttribute("transform"), n && r && (i = "matrix(" + (r = t.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", n = 0)), n) return Wt; for (r = (i || "").match(v) || [], Mt = r.length; --Mt > -1;)o = Number(r[Mt]), r[Mt] = (s = o - (o |= 0)) ? (1e5 * s + (s < 0 ? -.5 : .5) | 0) / 1e5 + o : o; return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r }, Xt = V.getTransform = function (t, e, n, r) { if (t._gsTransform && n && !r) return t._gsTransform; var s, a, c, l, u, h, d = n && t._gsTransform || new Bt, f = d.scaleX < 0, p = kt && (parseFloat(tt(t, Nt, e, !1, "0 0 0").split(" ")[2]) || d.zOrigin) || 0, m = parseFloat(o.defaultTransformPerspective) || 0; if (d.svg = !(!t.getCTM || !Vt(t)), d.svg && (Gt(t, tt(t, Nt, e, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")), At = o.useSVGTransformAttr || Ht), (s = qt(t)) !== Wt) { if (16 === s.length) { var g, v, y, _, x, b = s[0], w = s[1], M = s[2], T = s[3], S = s[4], E = s[5], A = s[6], P = s[7], L = s[8], R = s[9], O = s[10], C = s[12], I = s[13], D = s[14], N = s[11], k = Math.atan2(A, O); d.zOrigin && (C = L * (D = -d.zOrigin) - s[12], I = R * D - s[13], D = O * D + d.zOrigin - s[14]), d.rotationX = k * B, k && (g = S * (_ = Math.cos(-k)) + L * (x = Math.sin(-k)), v = E * _ + R * x, y = A * _ + O * x, L = S * -x + L * _, R = E * -x + R * _, O = A * -x + O * _, N = P * -x + N * _, S = g, E = v, A = y), k = Math.atan2(-M, O), d.rotationY = k * B, k && (v = w * (_ = Math.cos(-k)) - R * (x = Math.sin(-k)), y = M * _ - O * x, R = w * x + R * _, O = M * x + O * _, N = T * x + N * _, b = g = b * _ - L * x, w = v, M = y), k = Math.atan2(w, b), d.rotation = k * B, k && (g = b * (_ = Math.cos(k)) + w * (x = Math.sin(k)), v = S * _ + E * x, y = L * _ + R * x, w = w * _ - b * x, E = E * _ - S * x, R = R * _ - L * x, b = g, S = v, L = y), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), k = Math.atan2(S, E), d.scaleX = (1e5 * Math.sqrt(b * b + w * w + M * M) + .5 | 0) / 1e5, d.scaleY = (1e5 * Math.sqrt(E * E + A * A) + .5 | 0) / 1e5, d.scaleZ = (1e5 * Math.sqrt(L * L + R * R + O * O) + .5 | 0) / 1e5, b /= d.scaleX, S /= d.scaleY, w /= d.scaleX, E /= d.scaleY, Math.abs(k) > 2e-5 ? (d.skewX = k * B, S = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(k))) : d.skewX = 0, d.perspective = N ? 1 / (N < 0 ? -N : N) : 0, d.x = C, d.y = I, d.z = D, d.svg && (d.x -= d.xOrigin - (d.xOrigin * b - d.yOrigin * S), d.y -= d.yOrigin - (d.yOrigin * w - d.xOrigin * E)) } else if (!kt || r || !s.length || d.x !== s[4] || d.y !== s[5] || !d.rotationX && !d.rotationY) { var z = s.length >= 6, F = z ? s[0] : 1, U = s[1] || 0, H = s[2] || 0, G = z ? s[3] : 1; d.x = s[4] || 0, d.y = s[5] || 0, c = Math.sqrt(F * F + U * U), l = Math.sqrt(G * G + H * H), u = F || U ? Math.atan2(U, F) * B : d.rotation || 0, h = H || G ? Math.atan2(H, G) * B + u : d.skewX || 0, d.scaleX = c, d.scaleY = l, d.rotation = u, d.skewX = h, kt && (d.rotationX = d.rotationY = d.z = 0, d.perspective = m, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * F + d.yOrigin * H), d.y -= d.yOrigin - (d.xOrigin * U + d.yOrigin * G)) } for (a in Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (f ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = p, d) d[a] < 2e-5 && d[a] > -2e-5 && (d[a] = 0) } return n && (t._gsTransform = d, d.svg && (At && t.style[It] ? i.l.delayedCall(.001, (function () { Qt(t.style, It) })) : !At && t.getAttribute("transform") && i.l.delayedCall(.001, (function () { t.removeAttribute("transform") })))), d }, Yt = function (t) { var e, n, i = this.data, r = -i.rotation * k, o = r + i.skewX * k, s = (Math.cos(r) * i.scaleX * 1e5 | 0) / 1e5, a = (Math.sin(r) * i.scaleX * 1e5 | 0) / 1e5, c = (Math.sin(o) * -i.scaleY * 1e5 | 0) / 1e5, l = (Math.cos(o) * i.scaleY * 1e5 | 0) / 1e5, u = this.t.style, h = this.t.currentStyle; if (h) { n = a, a = -c, c = -n, e = h.filter, u.filter = ""; var d, f, m = this.t.offsetWidth, g = this.t.offsetHeight, v = "absolute" !== h.position, y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + a + ", M21=" + c + ", M22=" + l, _ = i.x + m * i.xPercent / 100, x = i.y + g * i.yPercent / 100; if (null != i.ox && (_ += (d = (i.oxp ? m * i.ox * .01 : i.ox) - m / 2) - (d * s + (f = (i.oyp ? g * i.oy * .01 : i.oy) - g / 2) * a), x += f - (d * c + f * l)), y += v ? ", Dx=" + ((d = m / 2) - (d * s + (f = g / 2) * a) + _) + ", Dy=" + (f - (d * c + f * l) + x) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? u.filter = e.replace(I, y) : u.filter = y + " " + e, 0 !== t && 1 !== t || 1 === s && 0 === a && 0 === c && 1 === l && (v && -1 === y.indexOf("Dx=0, Dy=0") || M.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && u.removeAttribute("filter")), !v) { var b, T, S, E = p < 8 ? 1 : -1; for (d = i.ieOffsetX || 0, f = i.ieOffsetY || 0, i.ieOffsetX = Math.round((m - ((s < 0 ? -s : s) * m + (a < 0 ? -a : a) * g)) / 2 + _), i.ieOffsetY = Math.round((g - ((l < 0 ? -l : l) * g + (c < 0 ? -c : c) * m)) / 2 + x), Mt = 0; Mt < 4; Mt++)S = (n = -1 !== (b = h[T = st[Mt]]).indexOf("px") ? parseFloat(b) : et(this.t, T, parseFloat(b), b.replace(w, "")) || 0) !== i[T] ? Mt < 2 ? -i.ieOffsetX : -i.ieOffsetY : Mt < 2 ? d - i.ieOffsetX : f - i.ieOffsetY, u[T] = (i[T] = Math.round(n - S * (0 === Mt || 2 === Mt ? 1 : E))) + "px" } } }, Zt = V.set3DTransformRatio = V.setTransformRatio = function (t) { var e, n, i, r, o, s, a, c, l, u, h, f, p, m, g, v, y, _, x, b, w = this.data, M = this.t.style, T = w.rotation, S = w.rotationX, E = w.rotationY, A = w.scaleX, P = w.scaleY, L = w.scaleZ, R = w.x, O = w.y, C = w.z, I = w.svg, D = w.perspective, N = w.force3D, B = w.skewY, z = w.skewX; if (B && (z += B, T += B), !((1 !== t && 0 !== t || "auto" !== N || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && N || C || D || E || S || 1 !== L) || At && I || !kt) T || z || I ? (T *= k, b = z * k, 1e5, n = Math.cos(T) * A, o = Math.sin(T) * A, i = Math.sin(T - b) * -P, s = Math.cos(T - b) * P, b && "simple" === w.skewType && (e = Math.tan(b - B * k), i *= e = Math.sqrt(1 + e * e), s *= e, B && (e = Math.tan(B * k), n *= e = Math.sqrt(1 + e * e), o *= e)), I && (R += w.xOrigin - (w.xOrigin * n + w.yOrigin * i) + w.xOffset, O += w.yOrigin - (w.xOrigin * o + w.yOrigin * s) + w.yOffset, At && (w.xPercent || w.yPercent) && (g = this.t.getBBox(), R += .01 * w.xPercent * g.width, O += .01 * w.yPercent * g.height), R < (g = 1e-6) && R > -g && (R = 0), O < g && O > -g && (O = 0)), x = (1e5 * n | 0) / 1e5 + "," + (1e5 * o | 0) / 1e5 + "," + (1e5 * i | 0) / 1e5 + "," + (1e5 * s | 0) / 1e5 + "," + R + "," + O + ")", I && At ? this.t.setAttribute("transform", "matrix(" + x) : M[It] = (w.xPercent || w.yPercent ? "translate(" + w.xPercent + "%," + w.yPercent + "%) matrix(" : "matrix(") + x) : M[It] = (w.xPercent || w.yPercent ? "translate(" + w.xPercent + "%," + w.yPercent + "%) matrix(" : "matrix(") + A + ",0,0," + P + "," + R + "," + O + ")"; else { if (d && (A < (g = 1e-4) && A > -g && (A = L = 2e-5), P < g && P > -g && (P = L = 2e-5), !D || w.z || w.rotationX || w.rotationY || (D = 0)), T || z) T *= k, v = n = Math.cos(T), y = o = Math.sin(T), z && (T -= z * k, v = Math.cos(T), y = Math.sin(T), "simple" === w.skewType && (e = Math.tan((z - B) * k), v *= e = Math.sqrt(1 + e * e), y *= e, w.skewY && (e = Math.tan(B * k), n *= e = Math.sqrt(1 + e * e), o *= e))), i = -y, s = v; else { if (!(E || S || 1 !== L || D || I)) return void (M[It] = (w.xPercent || w.yPercent ? "translate(" + w.xPercent + "%," + w.yPercent + "%) translate3d(" : "translate3d(") + R + "px," + O + "px," + C + "px)" + (1 !== A || 1 !== P ? " scale(" + A + "," + P + ")" : "")); n = s = 1, i = o = 0 } u = 1, r = a = c = l = h = f = 0, p = D ? -1 / D : 0, m = w.zOrigin, g = 1e-6, ",", "0", (T = E * k) && (v = Math.cos(T), c = -(y = Math.sin(T)), h = p * -y, r = n * y, a = o * y, u = v, p *= v, n *= v, o *= v), (T = S * k) && (e = i * (v = Math.cos(T)) + r * (y = Math.sin(T)), _ = s * v + a * y, l = u * y, f = p * y, r = i * -y + r * v, a = s * -y + a * v, u *= v, p *= v, i = e, s = _), 1 !== L && (r *= L, a *= L, u *= L, p *= L), 1 !== P && (i *= P, s *= P, l *= P, f *= P), 1 !== A && (n *= A, o *= A, c *= A, h *= A), (m || I) && (m && (R += r * -m, O += a * -m, C += u * -m + m), I && (R += w.xOrigin - (w.xOrigin * n + w.yOrigin * i) + w.xOffset, O += w.yOrigin - (w.xOrigin * o + w.yOrigin * s) + w.yOffset), R < g && R > -g && (R = "0"), O < g && O > -g && (O = "0"), C < g && C > -g && (C = 0)), x = w.xPercent || w.yPercent ? "translate(" + w.xPercent + "%," + w.yPercent + "%) matrix3d(" : "matrix3d(", x += (n < g && n > -g ? "0" : n) + "," + (o < g && o > -g ? "0" : o) + "," + (c < g && c > -g ? "0" : c), x += "," + (h < g && h > -g ? "0" : h) + "," + (i < g && i > -g ? "0" : i) + "," + (s < g && s > -g ? "0" : s), S || E || 1 !== L ? (x += "," + (l < g && l > -g ? "0" : l) + "," + (f < g && f > -g ? "0" : f) + "," + (r < g && r > -g ? "0" : r), x += "," + (a < g && a > -g ? "0" : a) + "," + (u < g && u > -g ? "0" : u) + "," + (p < g && p > -g ? "0" : p) + ",") : x += ",0,0,0,0,1,0,", x += R + "," + O + "," + C + "," + (D ? 1 + -C / D : 1) + ")", M[It] = x } }; (c = Bt.prototype).x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0, c.scaleX = c.scaleY = c.scaleZ = 1, St("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function (t, e, i, r, s, a, c) { if (r._lastParsedTransform === c) return s; r._lastParsedTransform = c; var l = c.scale && "function" == typeof c.scale ? c.scale : 0; l && (c.scale = l(g, t)); var u, h, d, f, p, v, y, _, x, b = t._gsTransform, w = t.style, M = Ct.length, T = c, S = {}, E = Xt(t, n, !0, T.parseTransform), A = T.transform && ("function" == typeof T.transform ? T.transform(g, m) : T.transform); if (E.skewType = T.skewType || E.skewType || o.defaultSkewType, r._transform = E, "rotationZ" in T && (T.rotation = T.rotationZ), A && "string" == typeof A && It) (h = G.style)[It] = A, h.display = "block", h.position = "absolute", -1 !== A.indexOf("%") && (h.width = tt(t, "width"), h.height = tt(t, "height")), U.body.appendChild(G), u = Xt(G, null, !1), "simple" === E.skewType && (u.scaleY *= Math.cos(u.skewX * k)), E.svg && (v = E.xOrigin, y = E.yOrigin, u.x -= E.xOffset, u.y -= E.yOffset, (T.transformOrigin || T.svgOrigin) && (A = {}, Gt(t, ct(T.transformOrigin), A, T.svgOrigin, T.smoothOrigin, !0), v = A.xOrigin, y = A.yOrigin, u.x -= A.xOffset - E.xOffset, u.y -= A.yOffset - E.yOffset), (v || y) && (_ = qt(G, !0), u.x -= v - (v * _[0] + y * _[2]), u.y -= y - (v * _[1] + y * _[3]))), U.body.removeChild(G), u.perspective || (u.perspective = E.perspective), null != T.xPercent && (u.xPercent = ut(T.xPercent, E.xPercent)), null != T.yPercent && (u.yPercent = ut(T.yPercent, E.yPercent)); else if ("object" == typeof T) { if (u = { scaleX: ut(null != T.scaleX ? T.scaleX : T.scale, E.scaleX), scaleY: ut(null != T.scaleY ? T.scaleY : T.scale, E.scaleY), scaleZ: ut(T.scaleZ, E.scaleZ), x: ut(T.x, E.x), y: ut(T.y, E.y), z: ut(T.z, E.z), xPercent: ut(T.xPercent, E.xPercent), yPercent: ut(T.yPercent, E.yPercent), perspective: ut(T.transformPerspective, E.perspective) }, null != (p = T.directionalRotation)) if ("object" == typeof p) for (h in p) T[h] = p[h]; else T.rotation = p; "string" == typeof T.x && -1 !== T.x.indexOf("%") && (u.x = 0, u.xPercent = ut(T.x, E.xPercent)), "string" == typeof T.y && -1 !== T.y.indexOf("%") && (u.y = 0, u.yPercent = ut(T.y, E.yPercent)), u.rotation = ht("rotation" in T ? T.rotation : "shortRotation" in T ? T.shortRotation + "_short" : E.rotation, E.rotation, "rotation", S), kt && (u.rotationX = ht("rotationX" in T ? T.rotationX : "shortRotationX" in T ? T.shortRotationX + "_short" : E.rotationX || 0, E.rotationX, "rotationX", S), u.rotationY = ht("rotationY" in T ? T.rotationY : "shortRotationY" in T ? T.shortRotationY + "_short" : E.rotationY || 0, E.rotationY, "rotationY", S)), u.skewX = ht(T.skewX, E.skewX), u.skewY = ht(T.skewY, E.skewY) } for (kt && null != T.force3D && (E.force3D = T.force3D, f = !0), (d = E.force3D || E.z || E.rotationX || E.rotationY || u.z || u.rotationX || u.rotationY || u.perspective) || null == T.scale || (u.scaleZ = 1); --M > -1;)((A = u[x = Ct[M]] - E[x]) > 1e-6 || A < -1e-6 || null != T[x] || null != z[x]) && (f = !0, s = new xt(E, x, E[x], A, s), x in S && (s.e = S[x]), s.xs0 = 0, s.plugin = a, r._overwriteProps.push(s.n)); return A = "function" == typeof T.transformOrigin ? T.transformOrigin(g, m) : T.transformOrigin, E.svg && (A || T.svgOrigin) && (v = E.xOffset, y = E.yOffset, Gt(t, ct(A), u, T.svgOrigin, T.smoothOrigin), s = bt(E, "xOrigin", (b ? E : u).xOrigin, u.xOrigin, s, "transformOrigin"), s = bt(E, "yOrigin", (b ? E : u).yOrigin, u.yOrigin, s, "transformOrigin"), v === E.xOffset && y === E.yOffset || (s = bt(E, "xOffset", b ? v : E.xOffset, E.xOffset, s, "transformOrigin"), s = bt(E, "yOffset", b ? y : E.yOffset, E.yOffset, s, "transformOrigin")), A = "0px 0px"), (A || kt && d && E.zOrigin) && (It ? (f = !0, x = Nt, A || (A = (A = (tt(t, x, n, !1, "50% 50%") + "").split(" "))[0] + " " + A[1] + " " + E.zOrigin + "px"), A += "", (s = new xt(w, x, 0, 0, s, -1, "transformOrigin")).b = w[x], s.plugin = a, kt ? (h = E.zOrigin, A = A.split(" "), E.zOrigin = (A.length > 2 ? parseFloat(A[2]) : h) || 0, s.xs0 = s.e = A[0] + " " + (A[1] || "50%") + " 0px", (s = new xt(E, "zOrigin", 0, 0, s, -1, s.n)).b = h, s.xs0 = s.e = E.zOrigin) : s.xs0 = s.e = A) : ct(A + "", E)), f && (r._transformType = E.svg && At || !d && 3 !== this._transformType ? 2 : 3), l && (c.scale = l), s }, allowFunc: !0, prefix: !0 }), St("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }), St("clipPath", { defaultValue: "inset(0%)", prefix: !0, multi: !0, formatter: vt("inset(0% 0% 0% 0%)", !1, !0) }), St("borderRadius", { defaultValue: "0px", parser: function (t, i, r, o, s, a) { i = this.format(i); var c, l, u, h, d, f, p, m, g, v, y, _, x, b, w, M, T = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], S = t.style; for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), c = i.split(" "), l = 0; l < T.length; l++)this.p.indexOf("border") && (T[l] = Q(T[l])), -1 !== (d = h = tt(t, T[l], n, !1, "0px")).indexOf(" ") && (h = d.split(" "), d = h[0], h = h[1]), f = u = c[l], p = parseFloat(d), _ = d.substr((p + "").length), (x = "=" === f.charAt(1)) ? (m = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), m *= parseFloat(f), y = f.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(f), y = f.substr((m + "").length)), "" === y && (y = e[r] || _), y !== _ && (b = et(t, "borderLeft", p, _), w = et(t, "borderTop", p, _), "%" === y ? (d = b / g * 100 + "%", h = w / v * 100 + "%") : "em" === y ? (d = b / (M = et(t, "borderLeft", 1, "em")) + "em", h = w / M + "em") : (d = b + "px", h = w + "px"), x && (f = parseFloat(d) + m + y, u = parseFloat(h) + m + y)), s = wt(S, T[l], d + " " + h, f + " " + u, !1, "0px", s); return s }, prefix: !0, formatter: vt("0px 0px 0px 0px", !1, !0) }), St("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function (t, e, i, r, o, s) { return wt(t.style, i, this.format(tt(t, i, n, !1, "0px 0px")), this.format(e), !1, "0px", o) }, prefix: !0, formatter: vt("0px 0px", !1, !0) }), St("backgroundPosition", { defaultValue: "0 0", parser: function (t, e, i, r, o, s) { var a, c, l, u, h, d, f = "background-position", m = n || K(t), g = this.format((m ? p ? m.getPropertyValue(f + "-x") + " " + m.getPropertyValue(f + "-y") : m.getPropertyValue(f) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), v = this.format(e); if (-1 !== g.indexOf("%") != (-1 !== v.indexOf("%")) && v.split(",").length < 2 && (d = tt(t, "backgroundImage").replace(L, "")) && "none" !== d) { for (a = g.split(" "), c = v.split(" "), j.setAttribute("src", d), l = 2; --l > -1;)(u = -1 !== (g = a[l]).indexOf("%")) !== (-1 !== c[l].indexOf("%")) && (h = 0 === l ? t.offsetWidth - j.width : t.offsetHeight - j.height, a[l] = u ? parseFloat(g) / 100 * h + "px" : parseFloat(g) / h * 100 + "%"); g = a.join(" ") } return this.parseComplex(t.style, g, v, o, s) }, formatter: ct }), St("backgroundSize", { defaultValue: "0 0", formatter: function (t) { return "co" === (t += "").substr(0, 2) ? t : ct(-1 === t.indexOf(" ") ? t + " " + t : t) } }), St("perspective", { defaultValue: "0px", prefix: !0 }), St("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), St("transformStyle", { prefix: !0 }), St("backfaceVisibility", { prefix: !0 }), St("userSelect", { prefix: !0 }), St("margin", { parser: yt("marginTop,marginRight,marginBottom,marginLeft") }), St("padding", { parser: yt("paddingTop,paddingRight,paddingBottom,paddingLeft") }), St("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (t, e, i, r, o, s) { var a, c, l; return p < 9 ? (c = t.currentStyle, l = p < 8 ? " " : ",", a = "rect(" + c.clipTop + l + c.clipRight + l + c.clipBottom + l + c.clipLeft + ")", e = this.format(e).split(",").join(l)) : (a = this.format(tt(t, this.p, n, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, a, e, o, s) } }), St("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }), St("autoRound,strictUnits", { parser: function (t, e, n, i, r) { return r } }), St("border", { defaultValue: "0px solid #000", parser: function (t, e, i, r, o, s) { var a = tt(t, "borderTopWidth", n, !1, "0px"), c = this.format(e).split(" "), l = c[0].replace(w, ""); return "px" !== l && (a = parseFloat(a) / et(t, "borderTopWidth", 1, l) + l), this.parseComplex(t.style, this.format(a + " " + tt(t, "borderTopStyle", n, !1, "solid") + " " + tt(t, "borderTopColor", n, !1, "#000")), c.join(" "), o, s) }, color: !0, formatter: function (t) { var e = t.split(" "); return e[0] + " " + (e[1] || "solid") + " " + (t.match(gt) || ["#000"])[0] } }), St("borderWidth", { parser: yt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }), St("float,cssFloat,styleFloat", { parser: function (t, e, n, i, r, o) { var s = t.style, a = "cssFloat" in s ? "cssFloat" : "styleFloat"; return new xt(s, a, 0, 0, r, -1, n, !1, 0, s[a], e) } }); var Jt = function (t) { var e, n = this.t, i = n.filter || tt(this.data, "filter") || "", r = this.s + this.c * t | 0; 100 === r && (-1 === i.indexOf("atrix(") && -1 === i.indexOf("radient(") && -1 === i.indexOf("oader(") ? (n.removeAttribute("filter"), e = !tt(this.data, "filter")) : (n.filter = i.replace(S, ""), e = !0)), e || (this.xn1 && (n.filter = i = i || "alpha(opacity=" + r + ")"), -1 === i.indexOf("pacity") ? 0 === r && this.xn1 || (n.filter = i + " alpha(opacity=" + r + ")") : n.filter = i.replace(M, "opacity=" + r)) }; St("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (t, e, i, r, o, s) { var a = parseFloat(tt(t, "opacity", n, !1, "1")), c = t.style, l = "autoAlpha" === i; return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + a), l && 1 === a && "hidden" === tt(t, "visibility", n) && 0 !== e && (a = 0), q ? o = new xt(c, "opacity", a, e - a, o) : ((o = new xt(c, "opacity", 100 * a, 100 * (e - a), o)).xn1 = l ? 1 : 0, c.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = t, o.plugin = s, o.setRatio = Jt), l && ((o = new xt(c, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== a ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", r._overwriteProps.push(o.n), r._overwriteProps.push(i)), o } }); var Qt = function (t, e) { e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(A, "-$1").toLowerCase())) : t.removeAttribute(e)) }, $t = function (t) { if (this.t._gsClassPT = this, 1 === t || 0 === t) { this.t.setAttribute("class", 0 === t ? this.b : this.e); for (var e = this.data, n = this.t.style; e;)e.v ? n[e.p] = e.v : Qt(n, e.p), e = e._next; 1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e) }; St("className", { parser: function (e, i, r, o, s, a, c) { var l, u, h, d, f, p = e.getAttribute("class") || "", m = e.style.cssText; if ((s = o._classNamePT = new xt(e, r, 0, 0, s, 2)).setRatio = $t, s.pr = -11, t = !0, s.b = p, u = it(e, n), h = e._gsClassPT) { for (d = {}, f = h.data; f;)d[f.p] = 1, f = f._next; h.setRatio(1) } return e._gsClassPT = s, s.e = "=" !== i.charAt(1) ? i : p.replace(new RegExp("(?:\\s|^)" + i.substr(2) + "(?![\\w-])"), "") + ("+" === i.charAt(0) ? " " + i.substr(2) : ""), e.setAttribute("class", s.e), l = rt(e, u, it(e), c, d), e.setAttribute("class", p), s.data = l.firstMPT, e.style.cssText !== m && (e.style.cssText = m), s = s.xfirst = o.parse(e, l.difs, s, a) } }); var Kt = function (t) { if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) { var e, n, i, r, o, s = this.t.style, c = a.transform.parse; if ("all" === this.e) s.cssText = "", r = !0; else for (i = (e = this.e.split(" ").join("").split(",")).length; --i > -1;)n = e[i], a[n] && (a[n].parse === c ? r = !0 : n = "transformOrigin" === n ? Nt : a[n].p), Qt(s, n); r && (Qt(s, It), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform)) } }; for (St("clearProps", { parser: function (e, n, i, r, o) { return (o = new xt(e, i, 0, 0, o, 2)).setRatio = Kt, o.e = n, o.pr = -10, o.data = r._tween, t = !0, o } }), c = "bezier,throwProps,physicsProps,physics2D".split(","), Mt = c.length; Mt--;)Et(c[Mt]); (c = o.prototype)._firstPT = c._lastParsedTransform = c._transform = null, c._onInitTween = function (i, s, c, d) { if (!i.nodeType) return !1; this._target = m = i, this._tween = c, this._vars = s, g = d, l = s.autoRound, t = !1, e = s.suffixMap || o.suffixMap, n = K(i), r = this._overwriteProps; var p, v, y, _, x, b, w, M, S, E = i.style; if (u && "" === E.zIndex && ("auto" !== (p = tt(i, "zIndex", n)) && "" !== p || this._addLazySet(E, "zIndex", 0)), "string" == typeof s && (_ = E.cssText, p = it(i, n), E.cssText = _ + ";" + s, p = rt(i, p, it(i)).difs, !q && T.test(s) && (p.opacity = parseFloat(RegExp.$1)), s = p, E.cssText = _), s.className ? this._firstPT = v = a.className.parse(i, s.className, "className", this, null, null, s) : this._firstPT = v = this.parse(i, s, null), this._transformType) { for (S = 3 === this._transformType, It ? h && (u = !0, "" === E.zIndex && ("auto" !== (w = tt(i, "zIndex", n)) && "" !== w || this._addLazySet(E, "zIndex", 0)), f && this._addLazySet(E, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (S ? "visible" : "hidden"))) : E.zoom = 1, y = v; y && y._next;)y = y._next; M = new xt(i, "transform", 0, 0, null, 2), this._linkCSSP(M, null, y), M.setRatio = It ? Zt : Yt, M.data = this._transform || Xt(i, n, !0), M.tween = c, M.pr = -1, r.pop() } if (t) { for (; v;) { for (b = v._next, y = _; y && y.pr > v.pr;)y = y._next; (v._prev = y ? y._prev : x) ? v._prev._next = v : _ = v, (v._next = y) ? y._prev = v : x = v, v = b } this._firstPT = _ } return !0 }, c.parse = function (t, i, r, o) { var s, c, u, h, d, f, p, v, y, _, x = t.style; for (s in i) { if (f = i[s], c = a[s], "function" != typeof f || c && c.allowFunc || (f = f(g, m)), c) r = c.parse(t, f, s, this, r, o, i); else { if ("--" === s.substr(0, 2)) { this._tween._propLookup[s] = this._addTween.call(this._tween, t.style, "setProperty", K(t).getPropertyValue(s) + "", f + "", s, !1, s); continue } d = tt(t, s, n) + "", y = "string" == typeof f, "color" === s || "fill" === s || "stroke" === s || -1 !== s.indexOf("Color") || y && E.test(f) ? (y || (f = ((f = pt(f)).length > 3 ? "rgba(" : "rgb(") + f.join(",") + ")"), r = wt(x, s, d, f, !0, "transparent", r, 0, o)) : y && N.test(f) ? r = wt(x, s, d, f, !0, null, r, 0, o) : (p = (u = parseFloat(d)) || 0 === u ? d.substr((u + "").length) : "", "" !== d && "auto" !== d || ("width" === s || "height" === s ? (u = at(t, s, n), p = "px") : "left" === s || "top" === s ? (u = nt(t, s, n), p = "px") : (u = "opacity" !== s ? 0 : 1, p = "")), (_ = y && "=" === f.charAt(1)) ? (h = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), h *= parseFloat(f), v = f.replace(w, "")) : (h = parseFloat(f), v = y ? f.replace(w, "") : ""), "" === v && (v = s in e ? e[s] : p), f = h || 0 === h ? (_ ? h + u : h) + v : i[s], p !== v && ("" === v && "lineHeight" !== s || (h || 0 === h) && u && (u = et(t, s, u, p), "%" === v ? (u /= et(t, s, 100, "%") / 100, !0 !== i.strictUnits && (d = u + "%")) : "em" === v || "rem" === v || "vw" === v || "vh" === v ? u /= et(t, s, 1, v) : "px" !== v && (h = et(t, s, h, v), v = "px"), _ && (h || 0 === h) && (f = h + u + v))), _ && (h += u), !u && 0 !== u || !h && 0 !== h ? void 0 !== x[s] && (f || f + "" != "NaN" && null != f) ? (r = new xt(x, s, h || u || 0, 0, r, -1, s, !1, 0, d, f)).xs0 = "none" !== f || "display" !== s && -1 === s.indexOf("Style") ? f : d : Y("invalid " + s + " tween value: " + i[s]) : (r = new xt(x, s, u, h - u, r, 0, s, !1 !== l && ("px" === v || "zIndex" === s), 0, d, f)).xs0 = v) } o && r && !r.plugin && (r.plugin = o) } return r }, c.setRatio = function (t) { var e, n, i, r = this._firstPT; if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime) for (; r;) { if (e = r.c * t + r.s, r.r ? e = r.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), r.type) if (1 === r.type) if (2 === (i = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2; else if (3 === i) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3; else if (4 === i) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4; else if (5 === i) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5; else { for (n = r.xs0 + e + r.xs1, i = 1; i < r.l; i++)n += r["xn" + i] + r["xs" + (i + 1)]; r.t[r.p] = n } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t); else r.t[r.p] = e + r.xs0; r = r._next } else for (; r;)2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next; else for (; r;) { if (2 !== r.type) if (r.r && -1 !== r.type) if (e = r.r(r.s + r.c), r.type) { if (1 === r.type) { for (i = r.l, n = r.xs0 + e + r.xs1, i = 1; i < r.l; i++)n += r["xn" + i] + r["xs" + (i + 1)]; r.t[r.p] = n } } else r.t[r.p] = e + r.xs0; else r.t[r.p] = r.e; else r.setRatio(t); r = r._next } }, c._enableTransforms = function (t) { this._transform = this._transform || Xt(this._target, n, !0), this._transformType = this._transform.svg && At || !t && 3 !== this._transformType ? 2 : 3 }; var te = function (t) { this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0) }; c._addLazySet = function (t, e, n) { var i = this._firstPT = new xt(t, e, 0, 0, this._firstPT, 2); i.e = n, i.setRatio = te, i.data = this }, c._linkCSSP = function (t, e, n, i) { return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, i = !0), n ? n._next = t : i || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = n), t }, c._mod = function (t) { for (var e = this._firstPT; e;)"function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next }, c._kill = function (t) { var e, n, r, o = t; if (t.autoAlpha || t.alpha) { for (n in o = {}, t) o[n] = t[n]; o.opacity = 1, o.autoAlpha && (o.visibility = 1) } for (t.className && (e = this._classNamePT) && ((r = e.xfirst) && r._prev ? this._linkCSSP(r._prev, e._next, r._prev._prev) : r === this._firstPT && (this._firstPT = e._next), e._next && this._linkCSSP(e._next, e._next._next, r._prev), this._classNamePT = null), e = this._firstPT; e;)e.plugin && e.plugin !== n && e.plugin._kill && (e.plugin._kill(t), n = e.plugin), e = e._next; return i.j.prototype._kill.call(this, o) }; var ee = function (t, e, n) { var i, r, o, s; if (t.slice) for (r = t.length; --r > -1;)ee(t[r], e, n); else for (r = (i = t.childNodes).length; --r > -1;)s = (o = i[r]).type, o.style && (e.push(it(o)), n && n.push(o)), 1 !== s && 9 !== s && 11 !== s || !o.childNodes.length || ee(o, e, n) }; return o.cascadeTo = function (t, e, n) { var r, o, s, a, c = i.l.to(t, e, n), l = [c], u = [], h = [], d = [], f = i.l._internals.reservedProps; for (t = c._targets || c.target, ee(t, u, d), c.render(e, !0, !0), ee(t, h), c.render(0, !0, !0), c._enabled(!0), r = d.length; --r > -1;)if ((o = rt(d[r], u[r], h[r])).firstMPT) { for (s in o = o.difs, n) f[s] && (o[s] = n[s]); for (s in a = {}, o) a[s] = u[r][s]; l.push(i.l.fromTo(d[r], e, a, o)) } return l }, i.j.activate([o]), o }), !0); var a = i.m.CSSPlugin, c = i.k._gsDefine.plugin({ propName: "attr", API: 2, version: "0.6.1", init: function (t, e, n, i) { var r, o; if ("function" != typeof t.setAttribute) return !1; for (r in e) "function" == typeof (o = e[r]) && (o = o(i, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r), this._overwriteProps.push(r); return !0 } }), l = i.k._gsDefine.plugin({ propName: "roundProps", version: "1.7.0", priority: -1, API: 2, init: function (t, e, n) { return this._tween = n, !0 } }), u = function (t) { var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1; return function (n) { return (Math.round(n / t) * t * e | 0) / e } }, h = function (t, e) { for (; t;)t.f || t.blob || (t.m = e || Math.round), t = t._next }, d = l.prototype;
/*!
 * VERSION: 0.6.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */d._onInitAllProps = function () { var t, e, n, i, r = this._tween, o = r.vars.roundProps, s = {}, a = r._propLookup.roundProps; if ("object" != typeof o || o.push) for ("string" == typeof o && (o = o.split(",")), n = o.length; --n > -1;)s[o[n]] = Math.round; else for (i in o) s[i] = u(o[i]); for (i in s) for (t = r._firstPT; t;)e = t._next, t.pg ? t.t._mod(s) : t.n === i && (2 === t.f && t.t ? h(t.t._firstPT, s[i]) : (this._add(t.t, i, t.s, t.c, s[i]), e && (e._prev = t._prev), t._prev ? t._prev._next = e : r._firstPT === t && (r._firstPT = e), t._next = t._prev = null, r._propLookup[i] = a)), t = e; return !1 }, d._add = function (t, e, n, i, r) { this._addTween(t, e, n, n + i, e, r || Math.round), this._overwriteProps.push(e) };
    /*!
     * VERSION: 0.3.1
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     **/
    var f = i.k._gsDefine.plugin({ propName: "directionalRotation", version: "0.3.1", API: 2, init: function (t, e, n, i) { "object" != typeof e && (e = { rotation: e }), this.finals = {}; var r, o, s, a, c, l, u = !0 === e.useRadians ? 2 * Math.PI : 360; for (r in e) "useRadians" !== r && ("function" == typeof (a = e[r]) && (a = a(i, t)), o = (l = (a + "").split("_"))[0], s = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), c = (a = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? s + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - s, l.length && (-1 !== (o = l.join("_")).indexOf("short") && (c %= u) !== c % (u / 2) && (c = c < 0 ? c + u : c - u), -1 !== o.indexOf("_cw") && c < 0 ? c = (c + 9999999999 * u) % u - (c / u | 0) * u : -1 !== o.indexOf("ccw") && c > 0 && (c = (c - 9999999999 * u) % u - (c / u | 0) * u)), (c > 1e-6 || c < -1e-6) && (this._addTween(t, r, s, s + c, r), this._overwriteProps.push(r))); return !0 }, set: function (t) { var e; if (1 !== t) this._super.setRatio.call(this, t); else for (e = this._firstPT; e;)e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next } }); f._autoCSS = !0;
    /*!
     * VERSION: 1.3.9
     * DATE: 2019-05-17
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     **/
    var p = 180 / Math.PI, m = [], g = [], v = [], y = {}, _ = i.k._gsDefine.globals, x = function (t, e, n, i) { n === i && (n = i - (i - e) / 1e6), t === e && (e = t + (n - t) / 1e6), this.a = t, this.b = e, this.c = n, this.d = i, this.da = i - t, this.ca = n - t, this.ba = e - t }, b = function (t, e, n, i) { var r = { a: t }, o = {}, s = {}, a = { c: i }, c = (t + e) / 2, l = (e + n) / 2, u = (n + i) / 2, h = (c + l) / 2, d = (l + u) / 2, f = (d - h) / 8; return r.b = c + (t - c) / 4, o.b = h + f, r.c = o.a = (r.b + o.b) / 2, o.c = s.a = (h + d) / 2, s.b = d - f, a.b = u + (i - u) / 4, s.c = a.a = (s.b + a.b) / 2, [r, o, s, a] }, w = function (t, e, n, i, r) { var o, s, a, c, l, u, h, d, f, p, y, _, x, w = t.length - 1, M = 0, T = t[0].a; for (o = 0; o < w; o++)s = (l = t[M]).a, a = l.d, c = t[M + 1].d, r ? (y = m[o], x = ((_ = g[o]) + y) * e * .25 / (i ? .5 : v[o] || .5), d = a - ((u = a - (a - s) * (i ? .5 * e : 0 !== y ? x / y : 0)) + (((h = a + (c - a) * (i ? .5 * e : 0 !== _ ? x / _ : 0)) - u) * (3 * y / (y + _) + .5) / 4 || 0))) : d = a - ((u = a - (a - s) * e * .5) + (h = a + (c - a) * e * .5)) / 2, u += d, h += d, l.c = f = u, l.b = 0 !== o ? T : T = l.a + .6 * (l.c - l.a), l.da = a - s, l.ca = f - s, l.ba = T - s, n ? (p = b(s, T, f, a), t.splice(M, 1, p[0], p[1], p[2], p[3]), M += 4) : M++, T = h; (l = t[M]).b = T, l.c = T + .4 * (l.d - T), l.da = l.d - l.a, l.ca = l.c - l.a, l.ba = T - l.a, n && (p = b(l.a, T, l.c, l.d), t.splice(M, 1, p[0], p[1], p[2], p[3])) }, M = function (t, e, n, i) { var r, o, s, a, c, l, u = []; if (i) for (o = (t = [i].concat(t)).length; --o > -1;)"string" == typeof (l = t[o][e]) && "=" === l.charAt(1) && (t[o][e] = i[e] + Number(l.charAt(0) + l.substr(2))); if ((r = t.length - 2) < 0) return u[0] = new x(t[0][e], 0, 0, t[0][e]), u; for (o = 0; o < r; o++)s = t[o][e], a = t[o + 1][e], u[o] = new x(s, 0, 0, a), n && (c = t[o + 2][e], m[o] = (m[o] || 0) + (a - s) * (a - s), g[o] = (g[o] || 0) + (c - a) * (c - a)); return u[o] = new x(t[o][e], 0, 0, t[o + 1][e]), u }, T = function (t, e, n, i, r, o) { var s, a, c, l, u, h, d, f, p = {}, _ = [], x = o || t[0]; for (a in r = "string" == typeof r ? "," + r + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == e && (e = 1), t[0]) _.push(a); if (t.length > 1) { for (f = t[t.length - 1], d = !0, s = _.length; --s > -1;)if (a = _[s], Math.abs(x[a] - f[a]) > .05) { d = !1; break } d && (t = t.concat(), o && t.unshift(o), t.push(t[1]), o = t[t.length - 3]) } for (m.length = g.length = v.length = 0, s = _.length; --s > -1;)a = _[s], y[a] = -1 !== r.indexOf("," + a + ","), p[a] = M(t, a, y[a], o); for (s = m.length; --s > -1;)m[s] = Math.sqrt(m[s]), g[s] = Math.sqrt(g[s]); if (!i) { for (s = _.length; --s > -1;)if (y[a]) for (h = (c = p[_[s]]).length - 1, l = 0; l < h; l++)u = c[l + 1].da / g[l] + c[l].da / m[l] || 0, v[l] = (v[l] || 0) + u * u; for (s = v.length; --s > -1;)v[s] = Math.sqrt(v[s]) } for (s = _.length, l = n ? 4 : 1; --s > -1;)c = p[a = _[s]], w(c, e, n, i, y[a]), d && (c.splice(0, l), c.splice(c.length - l, l)); return p }, S = function (t, e, n) { for (var i, r, o, s, a, c, l, u, h, d, f, p = 1 / n, m = t.length; --m > -1;)for (o = (d = t[m]).a, s = d.d - o, a = d.c - o, c = d.b - o, i = r = 0, u = 1; u <= n; u++)i = r - (r = ((l = p * u) * l * s + 3 * (h = 1 - l) * (l * a + h * c)) * l), e[f = m * n + u - 1] = (e[f] || 0) + i * i }, E = i.k._gsDefine.plugin({ propName: "bezier", priority: -1, version: "1.3.9", API: 2, global: !0, init: function (t, e, n) { this._target = t, e instanceof Array && (e = { values: e }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10); var i, r, o, s, a, c = e.values || [], l = {}, u = c[0], h = e.autoRotate || n.vars.orientToBezier; for (i in this._autoRotate = h ? h instanceof Array ? h : [["x", "y", "rotation", !0 === h ? 0 : Number(h) || 0]] : null, u) this._props.push(i); for (o = this._props.length; --o > -1;)i = this._props[o], this._overwriteProps.push(i), r = this._func[i] = "function" == typeof t[i], l[i] = r ? t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]() : parseFloat(t[i]), a || l[i] !== c[0][i] && (a = l); if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? T(c, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, a) : function (t, e, n) { var i, r, o, s, a, c, l, u, h, d, f, p = {}, m = "cubic" === (e = e || "soft") ? 3 : 2, g = "soft" === e, v = []; if (g && n && (t = [n].concat(t)), null == t || t.length < m + 1) throw "invalid Bezier data"; for (h in t[0]) v.push(h); for (c = v.length; --c > -1;) { for (p[h = v[c]] = a = [], d = 0, u = t.length, l = 0; l < u; l++)i = null == n ? t[l][h] : "string" == typeof (f = t[l][h]) && "=" === f.charAt(1) ? n[h] + Number(f.charAt(0) + f.substr(2)) : Number(f), g && l > 1 && l < u - 1 && (a[d++] = (i + a[d - 2]) / 2), a[d++] = i; for (u = d - m + 1, d = 0, l = 0; l < u; l += m)i = a[l], r = a[l + 1], o = a[l + 2], s = 2 === m ? 0 : a[l + 3], a[d++] = f = 3 === m ? new x(i, r, o, s) : new x(i, (2 * r + i) / 3, (2 * r + o) / 3, o); a.length = d } return p }(c, e.type, l), this._segCount = this._beziers[i].length, this._timeRes) { var d = function (t, e) { var n, i, r, o, s = [], a = [], c = 0, l = 0, u = (e = e >> 0 || 6) - 1, h = [], d = []; for (n in t) S(t[n], s, e); for (r = s.length, i = 0; i < r; i++)c += Math.sqrt(s[i]), d[o = i % e] = c, o === u && (l += c, h[o = i / e >> 0] = d, a[o] = l, c = 0, d = []); return { length: l, lengths: a, segments: h } }(this._beziers, this._timeRes); this._length = d.length, this._lengths = d.lengths, this._segments = d.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length } if (h = this._autoRotate) for (this._initialRotations = [], h[0] instanceof Array || (this._autoRotate = h = [h]), o = h.length; --o > -1;) { for (s = 0; s < 3; s++)i = h[o][s], this._func[i] = "function" == typeof t[i] && t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]; i = h[o][2], this._initialRotations[o] = (this._func[i] ? this._func[i].call(this._target) : this._target[i]) || 0, this._overwriteProps.push(i) } return this._startRatio = n.vars.runBackwards ? 1 : 0, !0 }, set: function (t) { var e, n, i, r, o, s, a, c, l, u, h, d = this._segCount, f = this._func, m = this._target, g = t !== this._startRatio; if (this._timeRes) { if (l = this._lengths, u = this._curSeg, h = t * this._length, i = this._li, h > this._l2 && i < d - 1) { for (c = d - 1; i < c && (this._l2 = l[++i]) <= h;); this._l1 = l[i - 1], this._li = i, this._curSeg = u = this._segments[i], this._s2 = u[this._s1 = this._si = 0] } else if (h < this._l1 && i > 0) { for (; i > 0 && (this._l1 = l[--i]) >= h;); 0 === i && h < this._l1 ? this._l1 = 0 : i++, this._l2 = l[i], this._li = i, this._curSeg = u = this._segments[i], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si] } if (e = i, h -= this._l1, i = this._si, h > this._s2 && i < u.length - 1) { for (c = u.length - 1; i < c && (this._s2 = u[++i]) <= h;); this._s1 = u[i - 1], this._si = i } else if (h < this._s1 && i > 0) { for (; i > 0 && (this._s1 = u[--i]) >= h;); 0 === i && h < this._s1 ? this._s1 = 0 : i++, this._s2 = u[i], this._si = i } s = 1 === t ? 1 : (i + (h - this._s1) / (this._s2 - this._s1)) * this._prec || 0 } else s = (t - (e = t < 0 ? 0 : t >= 1 ? d - 1 : d * t >> 0) * (1 / d)) * d; for (n = 1 - s, i = this._props.length; --i > -1;)r = this._props[i], a = (s * s * (o = this._beziers[r][e]).da + 3 * n * (s * o.ca + n * o.ba)) * s + o.a, this._mod[r] && (a = this._mod[r](a, m)), f[r] ? m[r](a) : m[r] = a; if (this._autoRotate) { var v, y, _, x, b, w, M, T = this._autoRotate; for (i = T.length; --i > -1;)r = T[i][2], w = T[i][3] || 0, M = !0 === T[i][4] ? 1 : p, o = this._beziers[T[i][0]], v = this._beziers[T[i][1]], o && v && (o = o[e], v = v[e], y = o.a + (o.b - o.a) * s, y += ((x = o.b + (o.c - o.b) * s) - y) * s, x += (o.c + (o.d - o.c) * s - x) * s, _ = v.a + (v.b - v.a) * s, _ += ((b = v.b + (v.c - v.b) * s) - _) * s, b += (v.c + (v.d - v.c) * s - b) * s, a = g ? Math.atan2(b - _, x - y) * M + w : this._initialRotations[i], this._mod[r] && (a = this._mod[r](a, m)), f[r] ? m[r](a) : m[r] = a) } } }), A = E.prototype; E.bezierThrough = T, E.cubicToQuadratic = b, E._autoCSS = !0, E.quadraticToCubic = function (t, e, n) { return new x(t, (2 * e + t) / 3, (2 * e + n) / 3, n) }, E._cssRegister = function () { var t = _.CSSPlugin; if (t) { var e = t._internals, n = e._parseToProxy, i = e._setPluginRatio, r = e.CSSPropTween; e._registerComplexSpecialProp("bezier", { parser: function (t, e, o, s, a, c) { e instanceof Array && (e = { values: e }), c = new E; var l, u, h, d = e.values, f = d.length - 1, p = [], m = {}; if (f < 0) return a; for (l = 0; l <= f; l++)h = n(t, d[l], s, a, c, f !== l), p[l] = h.end; for (u in e) m[u] = e[u]; return m.values = p, (a = new r(t, "bezier", 0, 0, h.pt, 2)).data = h, a.plugin = c, a.setRatio = i, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (l = !0 === m.autoRotate ? 0 : Number(m.autoRotate), m.autoRotate = null != h.end.left ? [["left", "top", "rotation", l, !1]] : null != h.end.x && [["x", "y", "rotation", l, !1]]), m.autoRotate && (s._transform || s._enableTransforms(!1), h.autoRotate = s._target._gsTransform, h.proxy.rotation = h.autoRotate.rotation || 0, s._overwriteProps.push("rotation")), c._onInitTween(h.proxy, m, s._tween), a } }) } }, A._mod = function (t) { for (var e, n = this._overwriteProps, i = n.length; --i > -1;)(e = t[n[i]]) && "function" == typeof e && (this._mod[n[i]] = e) }, A._kill = function (t) { var e, n, i = this._props; for (e in this._beziers) if (e in t) for (delete this._beziers[e], delete this._func[e], n = i.length; --n > -1;)i[n] === e && i.splice(n, 1); if (i = this._autoRotate) for (n = i.length; --n > -1;)t[i[n][2]] && i.splice(n, 1); return this._super._kill.call(this, t) },
        /*!
         * VERSION: 1.16.1
         * DATE: 2018-08-27
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         * 
         * @author: Jack Doyle, jack@greensock.com
         **/
        i.k._gsDefine("easing.Back", ["easing.Ease"], (function () { var t, e, n, r, o = i.k.GreenSockGlobals || i.k, s = o.com.greensock, a = 2 * Math.PI, c = Math.PI / 2, l = s._class, u = function (t, e) { var n = l("easing." + t, (function () { }), !0), r = n.prototype = new i.b; return r.constructor = n, r.getRatio = e, n }, h = i.b.register || function () { }, d = function (t, e, n, i, r) { var o = l("easing." + t, { easeOut: new e, easeIn: new n, easeInOut: new i }, !0); return h(o, t), o }, f = function (t, e, n) { this.t = t, this.v = e, n && (this.next = n, n.prev = this, this.c = n.v - e, this.gap = n.t - t) }, p = function (t, e) { var n = l("easing." + t, (function (t) { this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1 }), !0), r = n.prototype = new i.b; return r.constructor = n, r.getRatio = e, r.config = function (t) { return new n(t) }, n }, m = d("Back", p("BackOut", (function (t) { return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1 })), p("BackIn", (function (t) { return t * t * ((this._p1 + 1) * t - this._p1) })), p("BackInOut", (function (t) { return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2) }))), g = l("easing.SlowMo", (function (t, e, n) { e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === n }), !0), v = g.prototype = new i.b; return v.constructor = g, v.getRatio = function (t) { var e = t + (.5 - t) * this._p; return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e }, g.ease = new g(.7, .7), v.config = g.config = function (t, e, n) { return new g(t, e, n) }, (v = (t = l("easing.SteppedEase", (function (t, e) { t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0 }), !0)).prototype = new i.b).constructor = t, v.getRatio = function (t) { return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1 }, v.config = t.config = function (e, n) { return new t(e, n) }, (v = (e = l("easing.ExpoScaleEase", (function (t, e, n) { this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = n }), !0)).prototype = new i.b).constructor = e, v.getRatio = function (t) { return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2 }, v.config = e.config = function (t, n, i) { return new e(t, n, i) }, (v = (n = l("easing.RoughEase", (function (t) { for (var e, n, r, o, s, a, c = (t = t || {}).taper || "none", l = [], u = 0, h = 0 | (t.points || 20), d = h, p = !1 !== t.randomize, m = !0 === t.clamp, g = t.template instanceof i.b ? t.template : null, v = "number" == typeof t.strength ? .4 * t.strength : .4; --d > -1;)e = p ? Math.random() : 1 / h * d, n = g ? g.getRatio(e) : e, r = "none" === c ? v : "out" === c ? (o = 1 - e) * o * v : "in" === c ? e * e * v : e < .5 ? (o = 2 * e) * o * .5 * v : (o = 2 * (1 - e)) * o * .5 * v, p ? n += Math.random() * r - .5 * r : d % 2 ? n += .5 * r : n -= .5 * r, m && (n > 1 ? n = 1 : n < 0 && (n = 0)), l[u++] = { x: e, y: n }; for (l.sort((function (t, e) { return t.x - e.x })), a = new f(1, 1, null), d = h; --d > -1;)s = l[d], a = new f(s.x, s.y, a); this._prev = new f(0, 0, 0 !== a.t ? a : a.next) }), !0)).prototype = new i.b).constructor = n, v.getRatio = function (t) { var e = this._prev; if (t > e.t) { for (; e.next && t >= e.t;)e = e.next; e = e.prev } else for (; e.prev && t <= e.t;)e = e.prev; return this._prev = e, e.v + (t - e.t) / e.gap * e.c }, v.config = function (t) { return new n(t) }, n.ease = new n, d("Bounce", u("BounceOut", (function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 })), u("BounceIn", (function (t) { return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375) })), u("BounceInOut", (function (t) { var e = t < .5; return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5 }))), d("Circ", u("CircOut", (function (t) { return Math.sqrt(1 - (t -= 1) * t) })), u("CircIn", (function (t) { return -(Math.sqrt(1 - t * t) - 1) })), u("CircInOut", (function (t) { return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }))), d("Elastic", (r = function (t, e, n) { var r = l("easing." + t, (function (t, e) { this._p1 = t >= 1 ? t : 1, this._p2 = (e || n) / (t < 1 ? t : 1), this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0), this._p2 = a / this._p2 }), !0), o = r.prototype = new i.b; return o.constructor = r, o.getRatio = e, o.config = function (t, e) { return new r(t, e) }, r })("ElasticOut", (function (t) { return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1 }), .3), r("ElasticIn", (function (t) { return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) }), .3), r("ElasticInOut", (function (t) { return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1 }), .45)), d("Expo", u("ExpoOut", (function (t) { return 1 - Math.pow(2, -10 * t) })), u("ExpoIn", (function (t) { return Math.pow(2, 10 * (t - 1)) - .001 })), u("ExpoInOut", (function (t) { return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1))) }))), d("Sine", u("SineOut", (function (t) { return Math.sin(t * c) })), u("SineIn", (function (t) { return 1 - Math.cos(t * c) })), u("SineInOut", (function (t) { return -.5 * (Math.cos(Math.PI * t) - 1) }))), l("easing.EaseLookup", { find: function (t) { return i.b.map[t] } }, !0), h(o.SlowMo, "SlowMo", "ease,"), h(n, "RoughEase", "ease,"), h(t, "SteppedEase", "ease,"), m }), !0); var P = i.m.Back, L = i.m.Elastic, R = i.m.Bounce, O = i.m.RoughEase, C = i.m.SlowMo, I = i.m.SteppedEase, D = i.m.Circ, N = i.m.Expo, k = i.m.Sine, B = i.m.ExpoScaleEase, z = s; z._autoActivated = [r, o, a, c, E, l, f, P, L, R, O, C, I, D, N, k, B], n.d(e, "default", (function () { return z })), n.d(e, "TweenLite", (function () { return i.l })), n.d(e, "TweenMax", (function () { return z })), n.d(e, "TimelineLite", (function () { return r })), n.d(e, "TimelineMax", (function () { return o })), n.d(e, "CSSPlugin", (function () { return a })), n.d(e, "AttrPlugin", (function () { return c })), n.d(e, "BezierPlugin", (function () { return E })), n.d(e, "RoundPropsPlugin", (function () { return l })), n.d(e, "DirectionalRotationPlugin", (function () { return f })), n.d(e, "TweenPlugin", (function () { return i.j })), n.d(e, "Ease", (function () { return i.b })), n.d(e, "Power0", (function () { return i.d })), n.d(e, "Power1", (function () { return i.e })), n.d(e, "Power2", (function () { return i.f })), n.d(e, "Power3", (function () { return i.g })), n.d(e, "Power4", (function () { return i.h })), n.d(e, "Linear", (function () { return i.c })), n.d(e, "Back", (function () { return P })), n.d(e, "Elastic", (function () { return L })), n.d(e, "Bounce", (function () { return R })), n.d(e, "RoughEase", (function () { return O })), n.d(e, "SlowMo", (function () { return C })), n.d(e, "SteppedEase", (function () { return I })), n.d(e, "Circ", (function () { return D })), n.d(e, "Expo", (function () { return N })), n.d(e, "Sine", (function () { return k })), n.d(e, "ExpoScaleEase", (function () { return B })), n.d(e, "_gsScope", (function () { return i.k }))
}, function (t, e, n) { var i; window, i = function () { return function (t) { var e = {}; function n(i) { if (e[i]) return e[i].exports; var r = e[i] = { i: i, l: !1, exports: {} }; return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports } return n.m = t, n.c = e, n.d = function (t, e, i) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i }) }, n.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var i = Object.create(null); if (n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var r in t) n.d(i, r, function (e) { return t[e] }.bind(null, r)); return i }, n.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return n.d(e, "a", e), e }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, n.p = "", n(n.s = 123) }([function (t, e, n) { (function (e) { var n = "object", i = function (t) { return t && t.Math == Math && t }; t.exports = i(typeof globalThis == n && globalThis) || i(typeof window == n && window) || i(typeof self == n && self) || i(typeof e == n && e) || Function("return this")() }).call(this, n(81)) }, function (t, e, n) { var i = n(0), r = n(16), o = n(25), s = n(58), a = i.Symbol, c = r("wks"); t.exports = function (t) { return c[t] || (c[t] = s && a[t] || (s ? a : o)("Symbol." + t)) } }, function (t, e) { t.exports = function (t) { try { return !!t() } catch (t) { return !0 } } }, function (t, e, n) { var i = n(4); t.exports = function (t) { if (!i(t)) throw TypeError(String(t) + " is not an object"); return t } }, function (t, e) { t.exports = function (t) { return "object" == typeof t ? null !== t : "function" == typeof t } }, function (t, e) { var n = {}.hasOwnProperty; t.exports = function (t, e) { return n.call(t, e) } }, function (t, e, n) { var i = n(7), r = n(53), o = n(3), s = n(35), a = Object.defineProperty; e.f = i ? a : function (t, e, n) { if (o(t), e = s(e, !0), o(n), r) try { return a(t, e, n) } catch (t) { } if ("get" in n || "set" in n) throw TypeError("Accessors not supported"); return "value" in n && (t[e] = n.value), t } }, function (t, e, n) { var i = n(2); t.exports = !i((function () { return 7 != Object.defineProperty({}, "a", { get: function () { return 7 } }).a })) }, function (t, e, n) { var i = n(0), r = n(22).f, o = n(9), s = n(10), a = n(37), c = n(55), l = n(41); t.exports = function (t, e) { var n, u, h, d, f, p = t.target, m = t.global, g = t.stat; if (n = m ? i : g ? i[p] || a(p, {}) : (i[p] || {}).prototype) for (u in e) { if (d = e[u], h = t.noTargetGet ? (f = r(n, u)) && f.value : n[u], !l(m ? u : p + (g ? "." : "#") + u, t.forced) && void 0 !== h) { if (typeof d == typeof h) continue; c(d, h) } (t.sham || h && h.sham) && o(d, "sham", !0), s(n, u, d, t) } } }, function (t, e, n) { var i = n(7), r = n(6), o = n(23); t.exports = i ? function (t, e, n) { return r.f(t, e, o(1, n)) } : function (t, e, n) { return t[e] = n, t } }, function (t, e, n) { var i = n(0), r = n(16), o = n(9), s = n(5), a = n(37), c = n(54), l = n(14), u = l.get, h = l.enforce, d = String(c).split("toString"); r("inspectSource", (function (t) { return c.call(t) })), (t.exports = function (t, e, n, r) { var c = !!r && !!r.unsafe, l = !!r && !!r.enumerable, u = !!r && !!r.noTargetGet; "function" == typeof n && ("string" != typeof e || s(n, "name") || o(n, "name", e), h(n).source = d.join("string" == typeof e ? e : "")), t !== i ? (c ? !u && t[e] && (l = !0) : delete t[e], l ? t[e] = n : o(t, e, n)) : l ? t[e] = n : a(e, n) })(Function.prototype, "toString", (function () { return "function" == typeof this && u(this).source || c.call(this) })) }, function (t, e) { var n = {}.toString; t.exports = function (t) { return n.call(t).slice(8, -1) } }, function (t, e) { t.exports = function (t) { if (null == t) throw TypeError("Can't call method on " + t); return t } }, function (t, e, n) { var i = n(52), r = n(12); t.exports = function (t) { return i(r(t)) } }, function (t, e, n) { var i, r, o, s = n(82), a = n(0), c = n(4), l = n(9), u = n(5), h = n(24), d = n(18), f = a.WeakMap; if (s) { var p = new f, m = p.get, g = p.has, v = p.set; i = function (t, e) { return v.call(p, t, e), e }, r = function (t) { return m.call(p, t) || {} }, o = function (t) { return g.call(p, t) } } else { var y = h("state"); d[y] = !0, i = function (t, e) { return l(t, y, e), e }, r = function (t) { return u(t, y) ? t[y] : {} }, o = function (t) { return u(t, y) } } t.exports = { set: i, get: r, has: o, enforce: function (t) { return o(t) ? r(t) : i(t, {}) }, getterFor: function (t) { return function (e) { var n; if (!c(e) || (n = r(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required"); return n } } } }, function (t, e, n) { var i = n(27), r = Math.min; t.exports = function (t) { return t > 0 ? r(i(t), 9007199254740991) : 0 } }, function (t, e, n) { var i = n(0), r = n(37), o = n(17), s = i["__core-js_shared__"] || r("__core-js_shared__", {}); (t.exports = function (t, e) { return s[t] || (s[t] = void 0 !== e ? e : {}) })("versions", []).push({ version: "3.1.3", mode: o ? "pure" : "global", copyright: "© 2019 Denis Pushkarev (zloirock.ru)" }) }, function (t, e) { t.exports = !1 }, function (t, e) { t.exports = {} }, function (t, e, n) { var i = n(12); t.exports = function (t) { return Object(i(t)) } }, function (t, e, n) { var i = n(6).f, r = n(5), o = n(1)("toStringTag"); t.exports = function (t, e, n) { t && !r(t = n ? t : t.prototype, o) && i(t, o, { configurable: !0, value: e }) } }, function (t, e) { t.exports = {} }, function (t, e, n) { var i = n(7), r = n(51), o = n(23), s = n(13), a = n(35), c = n(5), l = n(53), u = Object.getOwnPropertyDescriptor; e.f = i ? u : function (t, e) { if (t = s(t), e = a(e, !0), l) try { return u(t, e) } catch (t) { } if (c(t, e)) return o(!r.f.call(t, e), t[e]) } }, function (t, e) { t.exports = function (t, e) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e } } }, function (t, e, n) { var i = n(16), r = n(25), o = i("keys"); t.exports = function (t) { return o[t] || (o[t] = r(t)) } }, function (t, e) { var n = 0, i = Math.random(); t.exports = function (t) { return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++n + i).toString(36) } }, function (t, e, n) { var i = n(38), r = n(0), o = function (t) { return "function" == typeof t ? t : void 0 }; t.exports = function (t, e) { return arguments.length < 2 ? o(i[t]) || o(r[t]) : i[t] && i[t][e] || r[t] && r[t][e] } }, function (t, e) { var n = Math.ceil, i = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? i : n)(t) } }, function (t, e, n) { var i = n(3), r = n(86), o = n(40), s = n(18), a = n(61), c = n(36), l = n(24)("IE_PROTO"), u = function () { }, h = function () { var t, e = c("iframe"), n = o.length; for (e.style.display = "none", a.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), h = t.F; n--;)delete h.prototype[o[n]]; return h() }; t.exports = Object.create || function (t, e) { var n; return null !== t ? (u.prototype = i(t), n = new u, u.prototype = null, n[l] = t) : n = h(), void 0 === e ? n : r(n, e) }, s[l] = !0 }, function (t, e, n) { var i = n(30); t.exports = function (t, e, n) { if (i(t), void 0 === e) return t; switch (n) { case 0: return function () { return t.call(e) }; case 1: return function (n) { return t.call(e, n) }; case 2: return function (n, i) { return t.call(e, n, i) }; case 3: return function (n, i, r) { return t.call(e, n, i, r) } }return function () { return t.apply(e, arguments) } } }, function (t, e) { t.exports = function (t) { if ("function" != typeof t) throw TypeError(String(t) + " is not a function"); return t } }, function (t, e, n) { var i = n(8), r = n(7); i({ target: "Object", stat: !0, forced: !r, sham: !r }, { defineProperty: n(6).f }) }, function (t, e, n) { var i = n(10), r = n(106), o = Object.prototype; r !== o.toString && i(o, "toString", r, { unsafe: !0 }) }, function (t, e, n) { "use strict"; var i, r, o, s = n(8), a = n(17), c = n(0), l = n(38), u = n(70), h = n(20), d = n(71), f = n(4), p = n(30), m = n(47), g = n(11), v = n(46), y = n(69), _ = n(72), x = n(73).set, b = n(107), w = n(108), M = n(109), T = n(75), S = n(110), E = n(74), A = n(14), P = n(41), L = n(1)("species"), R = "Promise", O = A.get, C = A.set, I = A.getterFor(R), D = c.Promise, N = c.TypeError, k = c.document, B = c.process, z = c.fetch, F = B && B.versions, U = F && F.v8 || "", H = T.f, G = H, j = "process" == g(B), V = !!(k && k.createEvent && c.dispatchEvent), W = P(R, (function () { var t = D.resolve(1), e = function () { }, n = (t.constructor = {})[L] = function (t) { t(e, e) }; return !((j || "function" == typeof PromiseRejectionEvent) && (!a || t.finally) && t.then(e) instanceof n && 0 !== U.indexOf("6.6") && -1 === E.indexOf("Chrome/66")) })), q = W || !y((function (t) { D.all(t).catch((function () { })) })), X = function (t) { var e; return !(!f(t) || "function" != typeof (e = t.then)) && e }, Y = function (t, e, n) { if (!e.notified) { e.notified = !0; var i = e.reactions; b((function () { for (var r = e.value, o = 1 == e.state, s = 0; i.length > s;) { var a, c, l, u = i[s++], h = o ? u.ok : u.fail, d = u.resolve, f = u.reject, p = u.domain; try { h ? (o || (2 === e.rejection && $(t, e), e.rejection = 1), !0 === h ? a = r : (p && p.enter(), a = h(r), p && (p.exit(), l = !0)), a === u.promise ? f(N("Promise-chain cycle")) : (c = X(a)) ? c.call(a, d, f) : d(a)) : f(r) } catch (t) { p && !l && p.exit(), f(t) } } e.reactions = [], e.notified = !1, n && !e.rejection && J(t, e) })) } }, Z = function (t, e, n) { var i, r; V ? ((i = k.createEvent("Event")).promise = e, i.reason = n, i.initEvent(t, !1, !0), c.dispatchEvent(i)) : i = { promise: e, reason: n }, (r = c["on" + t]) ? r(i) : "unhandledrejection" === t && M("Unhandled promise rejection", n) }, J = function (t, e) { x.call(c, (function () { var n, i = e.value; if (Q(e) && (n = S((function () { j ? B.emit("unhandledRejection", i, t) : Z("unhandledrejection", t, i) })), e.rejection = j || Q(e) ? 2 : 1, n.error)) throw n.value })) }, Q = function (t) { return 1 !== t.rejection && !t.parent }, $ = function (t, e) { x.call(c, (function () { j ? B.emit("rejectionHandled", t) : Z("rejectionhandled", t, e.value) })) }, K = function (t, e, n, i) { return function (r) { t(e, n, r, i) } }, tt = function (t, e, n, i) { e.done || (e.done = !0, i && (e = i), e.value = n, e.state = 2, Y(t, e, !0)) }, et = function (t, e, n, i) { if (!e.done) { e.done = !0, i && (e = i); try { if (t === n) throw N("Promise can't be resolved itself"); var r = X(n); r ? b((function () { var i = { done: !1 }; try { r.call(n, K(et, t, i, e), K(tt, t, i, e)) } catch (n) { tt(t, i, n, e) } })) : (e.value = n, e.state = 1, Y(t, e, !1)) } catch (n) { tt(t, { done: !1 }, n, e) } } }; W && (D = function (t) { m(this, D, R), p(t), i.call(this); var e = O(this); try { t(K(et, this, e), K(tt, this, e)) } catch (t) { tt(this, e, t) } }, (i = function (t) { C(this, { type: R, done: !1, notified: !1, parent: !1, reactions: [], rejection: !1, state: 0, value: void 0 }) }).prototype = u(D.prototype, { then: function (t, e) { var n = I(this), i = H(_(this, D)); return i.ok = "function" != typeof t || t, i.fail = "function" == typeof e && e, i.domain = j ? B.domain : void 0, n.parent = !0, n.reactions.push(i), 0 != n.state && Y(this, n, !1), i.promise }, catch: function (t) { return this.then(void 0, t) } }), r = function () { var t = new i, e = O(t); this.promise = t, this.resolve = K(et, t, e), this.reject = K(tt, t, e) }, T.f = H = function (t) { return t === D || t === o ? new r(t) : G(t) }, a || "function" != typeof z || s({ global: !0, enumerable: !0, forced: !0 }, { fetch: function (t) { return w(D, z.apply(c, arguments)) } })), s({ global: !0, wrap: !0, forced: W }, { Promise: D }), h(D, R, !1, !0), d(R), o = l.Promise, s({ target: R, stat: !0, forced: W }, { reject: function (t) { var e = H(this); return e.reject.call(void 0, t), e.promise } }), s({ target: R, stat: !0, forced: a || W }, { resolve: function (t) { return w(a && this === o ? D : this, t) } }), s({ target: R, stat: !0, forced: q }, { all: function (t) { var e = this, n = H(e), i = n.resolve, r = n.reject, o = S((function () { var n = p(e.resolve), o = [], s = 0, a = 1; v(t, (function (t) { var c = s++, l = !1; o.push(void 0), a++, n.call(e, t).then((function (t) { l || (l = !0, o[c] = t, --a || i(o)) }), r) })), --a || i(o) })); return o.error && r(o.value), n.promise }, race: function (t) { var e = this, n = H(e), i = n.reject, r = S((function () { var r = p(e.resolve); v(t, (function (t) { r.call(e, t).then(n.resolve, i) })) })); return r.error && i(r.value), n.promise } }) }, function (t, e, n) { "use strict"; var i, r, o = n(76), s = RegExp.prototype.exec, a = String.prototype.replace, c = s, l = (i = /a/, r = /b*/g, s.call(i, "a"), s.call(r, "a"), 0 !== i.lastIndex || 0 !== r.lastIndex), u = void 0 !== /()??/.exec("")[1]; (l || u) && (c = function (t) { var e, n, i, r, c = this; return u && (n = new RegExp("^" + c.source + "$(?!\\s)", o.call(c))), l && (e = c.lastIndex), i = s.call(c, t), l && i && (c.lastIndex = c.global ? i.index + i[0].length : e), u && i && i.length > 1 && a.call(i[0], n, (function () { for (r = 1; r < arguments.length - 2; r++)void 0 === arguments[r] && (i[r] = void 0) })), i }), t.exports = c }, function (t, e, n) { var i = n(4); t.exports = function (t, e) { if (!i(t)) return t; var n, r; if (e && "function" == typeof (n = t.toString) && !i(r = n.call(t))) return r; if ("function" == typeof (n = t.valueOf) && !i(r = n.call(t))) return r; if (!e && "function" == typeof (n = t.toString) && !i(r = n.call(t))) return r; throw TypeError("Can't convert object to primitive value") } }, function (t, e, n) { var i = n(0), r = n(4), o = i.document, s = r(o) && r(o.createElement); t.exports = function (t) { return s ? o.createElement(t) : {} } }, function (t, e, n) { var i = n(0), r = n(9); t.exports = function (t, e) { try { r(i, t, e) } catch (n) { i[t] = e } return e } }, function (t, e, n) { t.exports = n(0) }, function (t, e, n) { var i = n(56), r = n(40).concat("length", "prototype"); e.f = Object.getOwnPropertyNames || function (t) { return i(t, r) } }, function (t, e) { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] }, function (t, e, n) { var i = n(2), r = /#|\.prototype\./, o = function (t, e) { var n = a[s(t)]; return n == l || n != c && ("function" == typeof e ? i(e) : !!e) }, s = o.normalize = function (t) { return String(t).replace(r, ".").toLowerCase() }, a = o.data = {}, c = o.NATIVE = "N", l = o.POLYFILL = "P"; t.exports = o }, function (t, e, n) { "use strict"; var i = n(8), r = n(93), o = n(43), s = n(44), a = n(20), c = n(9), l = n(10), u = n(1), h = n(17), d = n(21), f = n(65), p = f.IteratorPrototype, m = f.BUGGY_SAFARI_ITERATORS, g = u("iterator"), v = function () { return this }; t.exports = function (t, e, n, u, f, y, _) { r(n, e, u); var x, b, w, M = function (t) { if (t === f && P) return P; if (!m && t in E) return E[t]; switch (t) { case "keys": case "values": case "entries": return function () { return new n(this, t) } }return function () { return new n(this) } }, T = e + " Iterator", S = !1, E = t.prototype, A = E[g] || E["@@iterator"] || f && E[f], P = !m && A || M(f), L = "Array" == e && E.entries || A; if (L && (x = o(L.call(new t)), p !== Object.prototype && x.next && (h || o(x) === p || (s ? s(x, p) : "function" != typeof x[g] && c(x, g, v)), a(x, T, !0, !0), h && (d[T] = v))), "values" == f && A && "values" !== A.name && (S = !0, P = function () { return A.call(this) }), h && !_ || E[g] === P || c(E, g, P), d[e] = P, f) if (b = { values: M("values"), keys: y ? P : M("keys"), entries: M("entries") }, _) for (w in b) !m && !S && w in E || l(E, w, b[w]); else i({ target: e, proto: !0, forced: m || S }, b); return b } }, function (t, e, n) { var i = n(5), r = n(19), o = n(24), s = n(66), a = o("IE_PROTO"), c = Object.prototype; t.exports = s ? Object.getPrototypeOf : function (t) { return t = r(t), i(t, a) ? t[a] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? c : null } }, function (t, e, n) { var i = n(3), r = n(94); t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () { var t, e = !1, n = {}; try { (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), e = n instanceof Array } catch (t) { } return function (n, o) { return i(n), r(o), e ? t.call(n, o) : n.__proto__ = o, n } }() : void 0) }, function (t, e, n) { var i = n(7), r = n(6).f, o = Function.prototype, s = o.toString, a = /^\s*function ([^ (]*)/; !i || "name" in o || r(o, "name", { configurable: !0, get: function () { try { return s.call(this).match(a)[1] } catch (t) { return "" } } }) }, function (t, e, n) { var i = n(3), r = n(99), o = n(15), s = n(29), a = n(100), c = n(101), l = function (t, e) { this.stopped = t, this.result = e }; (t.exports = function (t, e, n, u, h) { var d, f, p, m, g, v, y = s(e, n, u ? 2 : 1); if (h) d = t; else { if ("function" != typeof (f = a(t))) throw TypeError("Target is not iterable"); if (r(f)) { for (p = 0, m = o(t.length); m > p; p++)if ((g = u ? y(i(v = t[p])[0], v[1]) : y(t[p])) && g instanceof l) return g; return new l(!1) } d = f.call(t) } for (; !(v = d.next()).done;)if ((g = c(d, y, v.value, u)) && g instanceof l) return g; return new l(!1) }).stop = function (t) { return new l(!0, t) } }, function (t, e) { t.exports = function (t, e, n) { if (!(t instanceof e)) throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation"); return t } }, function (t, e, n) { "use strict"; var i = n(9), r = n(10), o = n(2), s = n(1), a = n(34), c = s("species"), l = !o((function () { var t = /./; return t.exec = function () { var t = []; return t.groups = { a: "7" }, t }, "7" !== "".replace(t, "$<a>") })), u = !o((function () { var t = /(?:)/, e = t.exec; t.exec = function () { return e.apply(this, arguments) }; var n = "ab".split(t); return 2 !== n.length || "a" !== n[0] || "b" !== n[1] })); t.exports = function (t, e, n, h) { var d = s(t), f = !o((function () { var e = {}; return e[d] = function () { return 7 }, 7 != ""[t](e) })), p = f && !o((function () { var e = !1, n = /a/; return n.exec = function () { return e = !0, null }, "split" === t && (n.constructor = {}, n.constructor[c] = function () { return n }), n[d](""), !e })); if (!f || !p || "replace" === t && !l || "split" === t && !u) { var m = /./[d], g = n(d, ""[t], (function (t, e, n, i, r) { return e.exec === a ? f && !r ? { done: !0, value: m.call(e, n, i) } : { done: !0, value: t.call(n, e, i) } : { done: !1 } })), v = g[0], y = g[1]; r(String.prototype, t, v), r(RegExp.prototype, d, 2 == e ? function (t, e) { return y.call(t, this, e) } : function (t) { return y.call(t, this) }), h && i(RegExp.prototype[d], "sham", !0) } } }, function (t, e, n) { "use strict"; var i = n(77).charAt; t.exports = function (t, e, n) { return e + (n ? i(t, e).length : 1) } }, function (t, e, n) { var i = n(11), r = n(34); t.exports = function (t, e) { var n = t.exec; if ("function" == typeof n) { var o = n.call(t, e); if ("object" != typeof o) throw TypeError("RegExp exec method returned something other than an Object or null"); return o } if ("RegExp" !== i(t)) throw TypeError("RegExp#exec called on incompatible receiver"); return r.call(t, e) } }, function (t, e, n) { "use strict"; var i = {}.propertyIsEnumerable, r = Object.getOwnPropertyDescriptor, o = r && !i.call({ 1: 2 }, 1); e.f = o ? function (t) { var e = r(this, t); return !!e && e.enumerable } : i }, function (t, e, n) { var i = n(2), r = n(11), o = "".split; t.exports = i((function () { return !Object("z").propertyIsEnumerable(0) })) ? function (t) { return "String" == r(t) ? o.call(t, "") : Object(t) } : Object }, function (t, e, n) { var i = n(7), r = n(2), o = n(36); t.exports = !i && !r((function () { return 7 != Object.defineProperty(o("div"), "a", { get: function () { return 7 } }).a })) }, function (t, e, n) { var i = n(16); t.exports = i("native-function-to-string", Function.toString) }, function (t, e, n) { var i = n(5), r = n(83), o = n(22), s = n(6); t.exports = function (t, e) { for (var n = r(e), a = s.f, c = o.f, l = 0; l < n.length; l++) { var u = n[l]; i(t, u) || a(t, u, c(e, u)) } } }, function (t, e, n) { var i = n(5), r = n(13), o = n(84).indexOf, s = n(18); t.exports = function (t, e) { var n, a = r(t), c = 0, l = []; for (n in a) !i(s, n) && i(a, n) && l.push(n); for (; e.length > c;)i(a, n = e[c++]) && (~o(l, n) || l.push(n)); return l } }, function (t, e) { e.f = Object.getOwnPropertySymbols }, function (t, e, n) { var i = n(2); t.exports = !!Object.getOwnPropertySymbols && !i((function () { return !String(Symbol()) })) }, function (t, e, n) { var i = n(11); t.exports = Array.isArray || function (t) { return "Array" == i(t) } }, function (t, e, n) { var i = n(56), r = n(40); t.exports = Object.keys || function (t) { return i(t, r) } }, function (t, e, n) { var i = n(26); t.exports = i("document", "documentElement") }, function (t, e, n) { e.f = n(1) }, function (t, e, n) { var i = n(38), r = n(5), o = n(62), s = n(6).f; t.exports = function (t) { var e = i.Symbol || (i.Symbol = {}); r(e, t) || s(e, t, { value: o.f(t) }) } }, function (t, e, n) { "use strict"; var i = n(13), r = n(92), o = n(21), s = n(14), a = n(42), c = s.set, l = s.getterFor("Array Iterator"); t.exports = a(Array, "Array", (function (t, e) { c(this, { type: "Array Iterator", target: i(t), index: 0, kind: e }) }), (function () { var t = l(this), e = t.target, n = t.kind, i = t.index++; return !e || i >= e.length ? (t.target = void 0, { value: void 0, done: !0 }) : "keys" == n ? { value: i, done: !1 } : "values" == n ? { value: e[i], done: !1 } : { value: [i, e[i]], done: !1 } }), "values"), o.Arguments = o.Array, r("keys"), r("values"), r("entries") }, function (t, e, n) { "use strict"; var i, r, o, s = n(43), a = n(9), c = n(5), l = n(1), u = n(17), h = l("iterator"), d = !1;[].keys && ("next" in (o = [].keys()) ? (r = s(s(o))) !== Object.prototype && (i = r) : d = !0), null == i && (i = {}), u || c(i, h) || a(i, h, (function () { return this })), t.exports = { IteratorPrototype: i, BUGGY_SAFARI_ITERATORS: d } }, function (t, e, n) { var i = n(2); t.exports = !i((function () { function t() { } return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype })) }, function (t, e, n) { var i = n(18), r = n(4), o = n(5), s = n(6).f, a = n(25), c = n(98), l = a("meta"), u = 0, h = Object.isExtensible || function () { return !0 }, d = function (t) { s(t, l, { value: { objectID: "O" + ++u, weakData: {} } }) }, f = t.exports = { REQUIRED: !1, fastKey: function (t, e) { if (!r(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t; if (!o(t, l)) { if (!h(t)) return "F"; if (!e) return "E"; d(t) } return t[l].objectID }, getWeakData: function (t, e) { if (!o(t, l)) { if (!h(t)) return !0; if (!e) return !1; d(t) } return t[l].weakData }, onFreeze: function (t) { return c && f.REQUIRED && h(t) && !o(t, l) && d(t), t } }; i[l] = !0 }, function (t, e, n) { var i = n(11), r = n(1)("toStringTag"), o = "Arguments" == i(function () { return arguments }()); t.exports = function (t) { var e, n, s; return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function (t, e) { try { return t[e] } catch (t) { } }(e = Object(t), r)) ? n : o ? i(e) : "Object" == (s = i(e)) && "function" == typeof e.callee ? "Arguments" : s } }, function (t, e, n) { var i = n(1)("iterator"), r = !1; try { var o = 0, s = { next: function () { return { done: !!o++ } }, return: function () { r = !0 } }; s[i] = function () { return this }, Array.from(s, (function () { throw 2 })) } catch (t) { } t.exports = function (t, e) { if (!e && !r) return !1; var n = !1; try { var o = {}; o[i] = function () { return { next: function () { return { done: n = !0 } } } }, t(o) } catch (t) { } return n } }, function (t, e, n) { var i = n(10); t.exports = function (t, e, n) { for (var r in e) i(t, r, e[r], n); return t } }, function (t, e, n) { "use strict"; var i = n(26), r = n(6), o = n(1), s = n(7), a = o("species"); t.exports = function (t) { var e = i(t), n = r.f; s && e && !e[a] && n(e, a, { configurable: !0, get: function () { return this } }) } }, function (t, e, n) { var i = n(3), r = n(30), o = n(1)("species"); t.exports = function (t, e) { var n, s = i(t).constructor; return void 0 === s || null == (n = i(s)[o]) ? e : r(n) } }, function (t, e, n) { var i, r, o, s = n(0), a = n(2), c = n(11), l = n(29), u = n(61), h = n(36), d = s.location, f = s.setImmediate, p = s.clearImmediate, m = s.process, g = s.MessageChannel, v = s.Dispatch, y = 0, _ = {}, x = function (t) { if (_.hasOwnProperty(t)) { var e = _[t]; delete _[t], e() } }, b = function (t) { return function () { x(t) } }, w = function (t) { x(t.data) }, M = function (t) { s.postMessage(t + "", d.protocol + "//" + d.host) }; f && p || (f = function (t) { for (var e = [], n = 1; arguments.length > n;)e.push(arguments[n++]); return _[++y] = function () { ("function" == typeof t ? t : Function(t)).apply(void 0, e) }, i(y), y }, p = function (t) { delete _[t] }, "process" == c(m) ? i = function (t) { m.nextTick(b(t)) } : v && v.now ? i = function (t) { v.now(b(t)) } : g ? (o = (r = new g).port2, r.port1.onmessage = w, i = l(o.postMessage, o, 1)) : !s.addEventListener || "function" != typeof postMessage || s.importScripts || a(M) ? i = "onreadystatechange" in h("script") ? function (t) { u.appendChild(h("script")).onreadystatechange = function () { u.removeChild(this), x(t) } } : function (t) { setTimeout(b(t), 0) } : (i = M, s.addEventListener("message", w, !1))), t.exports = { set: f, clear: p } }, function (t, e, n) { var i = n(26); t.exports = i("navigator", "userAgent") || "" }, function (t, e, n) { "use strict"; var i = n(30), r = function (t) { var e, n; this.promise = new t((function (t, i) { if (void 0 !== e || void 0 !== n) throw TypeError("Bad Promise constructor"); e = t, n = i })), this.resolve = i(e), this.reject = i(n) }; t.exports.f = function (t) { return new r(t) } }, function (t, e, n) { "use strict"; var i = n(3); t.exports = function () { var t = i(this), e = ""; return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e } }, function (t, e, n) { var i = n(27), r = n(12), o = function (t) { return function (e, n) { var o, s, a = String(r(e)), c = i(n), l = a.length; return c < 0 || c >= l ? t ? "" : void 0 : (o = a.charCodeAt(c)) < 55296 || o > 56319 || c + 1 === l || (s = a.charCodeAt(c + 1)) < 56320 || s > 57343 ? t ? a.charAt(c) : o : t ? a.slice(c, c + 2) : s - 56320 + (o - 55296 << 10) + 65536 } }; t.exports = { codeAt: o(!1), charAt: o(!0) } }, function (t, e, n) { var i = function (t) { "use strict"; var e, n = Object.prototype, i = n.hasOwnProperty, r = "function" == typeof Symbol ? Symbol : {}, o = r.iterator || "@@iterator", s = r.asyncIterator || "@@asyncIterator", a = r.toStringTag || "@@toStringTag"; function c(t, e, n, i) { var r = e && e.prototype instanceof m ? e : m, o = Object.create(r.prototype), s = new A(i || []); return o._invoke = function (t, e, n) { var i = u; return function (r, o) { if (i === d) throw new Error("Generator is already running"); if (i === f) { if ("throw" === r) throw o; return L() } for (n.method = r, n.arg = o; ;) { var s = n.delegate; if (s) { var a = T(s, n); if (a) { if (a === p) continue; return a } } if ("next" === n.method) n.sent = n._sent = n.arg; else if ("throw" === n.method) { if (i === u) throw i = f, n.arg; n.dispatchException(n.arg) } else "return" === n.method && n.abrupt("return", n.arg); i = d; var c = l(t, e, n); if ("normal" === c.type) { if (i = n.done ? f : h, c.arg === p) continue; return { value: c.arg, done: n.done } } "throw" === c.type && (i = f, n.method = "throw", n.arg = c.arg) } } }(t, n, s), o } function l(t, e, n) { try { return { type: "normal", arg: t.call(e, n) } } catch (t) { return { type: "throw", arg: t } } } t.wrap = c; var u = "suspendedStart", h = "suspendedYield", d = "executing", f = "completed", p = {}; function m() { } function g() { } function v() { } var y = {}; y[o] = function () { return this }; var _ = Object.getPrototypeOf, x = _ && _(_(P([]))); x && x !== n && i.call(x, o) && (y = x); var b = v.prototype = m.prototype = Object.create(y); function w(t) { ["next", "throw", "return"].forEach((function (e) { t[e] = function (t) { return this._invoke(e, t) } })) } function M(t) { var e; this._invoke = function (n, r) { function o() { return new Promise((function (e, o) { !function e(n, r, o, s) { var a = l(t[n], t, r); if ("throw" !== a.type) { var c = a.arg, u = c.value; return u && "object" == typeof u && i.call(u, "__await") ? Promise.resolve(u.__await).then((function (t) { e("next", t, o, s) }), (function (t) { e("throw", t, o, s) })) : Promise.resolve(u).then((function (t) { c.value = t, o(c) }), (function (t) { return e("throw", t, o, s) })) } s(a.arg) }(n, r, e, o) })) } return e = e ? e.then(o, o) : o() } } function T(t, n) { var i = t.iterator[n.method]; if (i === e) { if (n.delegate = null, "throw" === n.method) { if (t.iterator.return && (n.method = "return", n.arg = e, T(t, n), "throw" === n.method)) return p; n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method") } return p } var r = l(i, t.iterator, n.arg); if ("throw" === r.type) return n.method = "throw", n.arg = r.arg, n.delegate = null, p; var o = r.arg; return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, p) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, p) } function S(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function E(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function A(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(S, this), this.reset(!0) } function P(t) { if (t) { var n = t[o]; if (n) return n.call(t); if ("function" == typeof t.next) return t; if (!isNaN(t.length)) { var r = -1, s = function n() { for (; ++r < t.length;)if (i.call(t, r)) return n.value = t[r], n.done = !1, n; return n.value = e, n.done = !0, n }; return s.next = s } } return { next: L } } function L() { return { value: e, done: !0 } } return g.prototype = b.constructor = v, v.constructor = g, v[a] = g.displayName = "GeneratorFunction", t.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === g || "GeneratorFunction" === (e.displayName || e.name)) }, t.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, v) : (t.__proto__ = v, a in t || (t[a] = "GeneratorFunction")), t.prototype = Object.create(b), t }, t.awrap = function (t) { return { __await: t } }, w(M.prototype), M.prototype[s] = function () { return this }, t.AsyncIterator = M, t.async = function (e, n, i, r) { var o = new M(c(e, n, i, r)); return t.isGeneratorFunction(n) ? o : o.next().then((function (t) { return t.done ? t.value : o.next() })) }, w(b), b[a] = "Generator", b[o] = function () { return this }, b.toString = function () { return "[object Generator]" }, t.keys = function (t) { var e = []; for (var n in t) e.push(n); return e.reverse(), function n() { for (; e.length;) { var i = e.pop(); if (i in t) return n.value = i, n.done = !1, n } return n.done = !0, n } }, t.values = P, A.prototype = { constructor: A, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(E), !t) for (var n in this) "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (t) { if (this.done) throw t; var n = this; function r(i, r) { return a.type = "throw", a.arg = t, n.next = i, r && (n.method = "next", n.arg = e), !!r } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var s = this.tryEntries[o], a = s.completion; if ("root" === s.tryLoc) return r("end"); if (s.tryLoc <= this.prev) { var c = i.call(s, "catchLoc"), l = i.call(s, "finallyLoc"); if (c && l) { if (this.prev < s.catchLoc) return r(s.catchLoc, !0); if (this.prev < s.finallyLoc) return r(s.finallyLoc) } else if (c) { if (this.prev < s.catchLoc) return r(s.catchLoc, !0) } else { if (!l) throw new Error("try statement without catch or finally"); if (this.prev < s.finallyLoc) return r(s.finallyLoc) } } } }, abrupt: function (t, e) { for (var n = this.tryEntries.length - 1; n >= 0; --n) { var r = this.tryEntries[n]; if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) { var o = r; break } } o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null); var s = o ? o.completion : {}; return s.type = t, s.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, p) : this.complete(s) }, complete: function (t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), p }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), E(n), p } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n.tryLoc === t) { var i = n.completion; if ("throw" === i.type) { var r = i.arg; E(n) } return r } } throw new Error("illegal catch attempt") }, delegateYield: function (t, n, i) { return this.delegate = { iterator: P(t), resultName: n, nextLoc: i }, "next" === this.method && (this.arg = e), p } }, t }(t.exports); try { regeneratorRuntime = i } catch (t) { Function("r", "regeneratorRuntime = r")(i) } }, function (t, e) { function n() { } n.prototype = { on: function (t, e, n) { var i = this.e || (this.e = {}); return (i[t] || (i[t] = [])).push({ fn: e, ctx: n }), this }, once: function (t, e, n) { var i = this; function r() { i.off(t, r), e.apply(n, arguments) } return r._ = e, this.on(t, r, n) }, emit: function (t) { for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++)n[i].fn.apply(n[i].ctx, e); return this }, off: function (t, e) { var n = this.e || (this.e = {}), i = n[t], r = []; if (i && e) for (var o = 0, s = i.length; o < s; o++)i[o].fn !== e && i[o].fn._ !== e && r.push(i[o]); return r.length ? n[t] = r : delete n[t], this } }, t.exports = n, t.exports.TinyEmitter = n }, function (t, e, n) { "use strict"; var i = n(8), r = n(0), o = n(17), s = n(7), a = n(58), c = n(2), l = n(5), u = n(59), h = n(4), d = n(3), f = n(19), p = n(13), m = n(35), g = n(23), v = n(28), y = n(60), _ = n(39), x = n(87), b = n(57), w = n(22), M = n(6), T = n(51), S = n(9), E = n(10), A = n(16), P = n(24), L = n(18), R = n(25), O = n(1), C = n(62), I = n(63), D = n(20), N = n(14), k = n(88).forEach, B = P("hidden"), z = O("toPrimitive"), F = N.set, U = N.getterFor("Symbol"), H = Object.prototype, G = r.Symbol, j = r.JSON, V = j && j.stringify, W = w.f, q = M.f, X = x.f, Y = T.f, Z = A("symbols"), J = A("op-symbols"), Q = A("string-to-symbol-registry"), $ = A("symbol-to-string-registry"), K = A("wks"), tt = r.QObject, et = !tt || !tt.prototype || !tt.prototype.findChild, nt = s && c((function () { return 7 != v(q({}, "a", { get: function () { return q(this, "a", { value: 7 }).a } })).a })) ? function (t, e, n) { var i = W(H, e); i && delete H[e], q(t, e, n), i && t !== H && q(H, e, i) } : q, it = function (t, e) { var n = Z[t] = v(G.prototype); return F(n, { type: "Symbol", tag: t, description: e }), s || (n.description = e), n }, rt = a && "symbol" == typeof G.iterator ? function (t) { return "symbol" == typeof t } : function (t) { return Object(t) instanceof G }, ot = function (t, e, n) { t === H && ot(J, e, n), d(t); var i = m(e, !0); return d(n), l(Z, i) ? (n.enumerable ? (l(t, B) && t[B][i] && (t[B][i] = !1), n = v(n, { enumerable: g(0, !1) })) : (l(t, B) || q(t, B, g(1, {})), t[B][i] = !0), nt(t, i, n)) : q(t, i, n) }, st = function (t, e) { d(t); var n = p(e), i = y(n).concat(ut(n)); return k(i, (function (e) { s && !at.call(n, e) || ot(t, e, n[e]) })), t }, at = function (t) { var e = m(t, !0), n = Y.call(this, e); return !(this === H && l(Z, e) && !l(J, e)) && (!(n || !l(this, e) || !l(Z, e) || l(this, B) && this[B][e]) || n) }, ct = function (t, e) { var n = p(t), i = m(e, !0); if (n !== H || !l(Z, i) || l(J, i)) { var r = W(n, i); return !r || !l(Z, i) || l(n, B) && n[B][i] || (r.enumerable = !0), r } }, lt = function (t) { var e = X(p(t)), n = []; return k(e, (function (t) { l(Z, t) || l(L, t) || n.push(t) })), n }, ut = function (t) { var e = t === H, n = X(e ? J : p(t)), i = []; return k(n, (function (t) { !l(Z, t) || e && !l(H, t) || i.push(Z[t]) })), i }; a || (E((G = function () { if (this instanceof G) throw TypeError("Symbol is not a constructor"); var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0, e = R(t), n = function (t) { this === H && n.call(J, t), l(this, B) && l(this[B], e) && (this[B][e] = !1), nt(this, e, g(1, t)) }; return s && et && nt(H, e, { configurable: !0, set: n }), it(e, t) }).prototype, "toString", (function () { return U(this).tag })), T.f = at, M.f = ot, w.f = ct, _.f = x.f = lt, b.f = ut, s && (q(G.prototype, "description", { configurable: !0, get: function () { return U(this).description } }), o || E(H, "propertyIsEnumerable", at, { unsafe: !0 })), C.f = function (t) { return it(O(t), t) }), i({ global: !0, wrap: !0, forced: !a, sham: !a }, { Symbol: G }), k(y(K), (function (t) { I(t) })), i({ target: "Symbol", stat: !0, forced: !a }, { for: function (t) { var e = String(t); if (l(Q, e)) return Q[e]; var n = G(e); return Q[e] = n, $[n] = e, n }, keyFor: function (t) { if (!rt(t)) throw TypeError(t + " is not a symbol"); if (l($, t)) return $[t] }, useSetter: function () { et = !0 }, useSimple: function () { et = !1 } }), i({ target: "Object", stat: !0, forced: !a, sham: !s }, { create: function (t, e) { return void 0 === e ? v(t) : st(v(t), e) }, defineProperty: ot, defineProperties: st, getOwnPropertyDescriptor: ct }), i({ target: "Object", stat: !0, forced: !a }, { getOwnPropertyNames: lt, getOwnPropertySymbols: ut }), i({ target: "Object", stat: !0, forced: c((function () { b.f(1) })) }, { getOwnPropertySymbols: function (t) { return b.f(f(t)) } }), j && i({ target: "JSON", stat: !0, forced: !a || c((function () { var t = G(); return "[null]" != V([t]) || "{}" != V({ a: t }) || "{}" != V(Object(t)) })) }, { stringify: function (t) { for (var e, n, i = [t], r = 1; arguments.length > r;)i.push(arguments[r++]); if (n = e = i[1], (h(e) || void 0 !== t) && !rt(t)) return u(e) || (e = function (t, e) { if ("function" == typeof n && (e = n.call(this, t, e)), !rt(e)) return e }), i[1] = e, V.apply(j, i) } }), G.prototype[z] || S(G.prototype, z, G.prototype.valueOf), D(G, "Symbol"), L[B] = !0 }, function (t, e) { var n; n = function () { return this }(); try { n = n || new Function("return this")() } catch (t) { "object" == typeof window && (n = window) } t.exports = n }, function (t, e, n) { var i = n(0), r = n(54), o = i.WeakMap; t.exports = "function" == typeof o && /native code/.test(r.call(o)) }, function (t, e, n) { var i = n(26), r = n(39), o = n(57), s = n(3); t.exports = i("Reflect", "ownKeys") || function (t) { var e = r.f(s(t)), n = o.f; return n ? e.concat(n(t)) : e } }, function (t, e, n) { var i = n(13), r = n(15), o = n(85), s = function (t) { return function (e, n, s) { var a, c = i(e), l = r(c.length), u = o(s, l); if (t && n != n) { for (; l > u;)if ((a = c[u++]) != a) return !0 } else for (; l > u; u++)if ((t || u in c) && c[u] === n) return t || u || 0; return !t && -1 } }; t.exports = { includes: s(!0), indexOf: s(!1) } }, function (t, e, n) { var i = n(27), r = Math.max, o = Math.min; t.exports = function (t, e) { var n = i(t); return n < 0 ? r(n + e, 0) : o(n, e) } }, function (t, e, n) { var i = n(7), r = n(6), o = n(3), s = n(60); t.exports = i ? Object.defineProperties : function (t, e) { o(t); for (var n, i = s(e), a = i.length, c = 0; a > c;)r.f(t, n = i[c++], e[n]); return t } }, function (t, e, n) { var i = n(13), r = n(39).f, o = {}.toString, s = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; t.exports.f = function (t) { return s && "[object Window]" == o.call(t) ? function (t) { try { return r(t) } catch (t) { return s.slice() } }(t) : r(i(t)) } }, function (t, e, n) { var i = n(29), r = n(52), o = n(19), s = n(15), a = n(89), c = [].push, l = function (t) { var e = 1 == t, n = 2 == t, l = 3 == t, u = 4 == t, h = 6 == t, d = 5 == t || h; return function (f, p, m, g) { for (var v, y, _ = o(f), x = r(_), b = i(p, m, 3), w = s(x.length), M = 0, T = g || a, S = e ? T(f, w) : n ? T(f, 0) : void 0; w > M; M++)if ((d || M in x) && (y = b(v = x[M], M, _), t)) if (e) S[M] = y; else if (y) switch (t) { case 3: return !0; case 5: return v; case 6: return M; case 2: c.call(S, v) } else if (u) return !1; return h ? -1 : l || u ? u : S } }; t.exports = { forEach: l(0), map: l(1), filter: l(2), some: l(3), every: l(4), find: l(5), findIndex: l(6) } }, function (t, e, n) { var i = n(4), r = n(59), o = n(1)("species"); t.exports = function (t, e) { var n; return r(t) && ("function" != typeof (n = t.constructor) || n !== Array && !r(n.prototype) ? i(n) && null === (n = n[o]) && (n = void 0) : n = void 0), new (void 0 === n ? Array : n)(0 === e ? 0 : e) } }, function (t, e, n) { "use strict"; var i = n(8), r = n(7), o = n(0), s = n(5), a = n(4), c = n(6).f, l = n(55), u = o.Symbol; if (r && "function" == typeof u && (!("description" in u.prototype) || void 0 !== u().description)) { var h = {}, d = function () { var t = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]), e = this instanceof d ? new u(t) : void 0 === t ? u() : u(t); return "" === t && (h[e] = !0), e }; l(d, u); var f = d.prototype = u.prototype; f.constructor = d; var p = f.toString, m = "Symbol(test)" == String(u("test")), g = /^Symbol\((.*)\)[^)]+$/; c(f, "description", { configurable: !0, get: function () { var t = a(this) ? this.valueOf() : this, e = p.call(t); if (s(h, t)) return ""; var n = m ? e.slice(7, -1) : e.replace(g, "$1"); return "" === n ? void 0 : n } }), i({ global: !0, forced: !0 }, { Symbol: d }) } }, function (t, e, n) { n(63)("iterator") }, function (t, e, n) { var i = n(1), r = n(28), o = n(9), s = i("unscopables"), a = Array.prototype; null == a[s] && o(a, s, r(null)), t.exports = function (t) { a[s][t] = !0 } }, function (t, e, n) { "use strict"; var i = n(65).IteratorPrototype, r = n(28), o = n(23), s = n(20), a = n(21), c = function () { return this }; t.exports = function (t, e, n) { var l = e + " Iterator"; return t.prototype = r(i, { next: o(1, n) }), s(t, l, !1, !0), a[l] = c, t } }, function (t, e, n) { var i = n(4); t.exports = function (t) { if (!i(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype"); return t } }, function (t, e, n) { var i = n(10), r = Date.prototype, o = r.toString, s = r.getTime; new Date(NaN) + "" != "Invalid Date" && i(r, "toString", (function () { var t = s.call(this); return t == t ? o.call(this) : "Invalid Date" })) }, function (t, e, n) { "use strict"; var i = n(97), r = n(103); t.exports = i("Map", (function (t) { return function () { return t(this, arguments.length ? arguments[0] : void 0) } }), r, !0) }, function (t, e, n) { "use strict"; var i = n(8), r = n(0), o = n(41), s = n(10), a = n(67), c = n(46), l = n(47), u = n(4), h = n(2), d = n(69), f = n(20), p = n(102); t.exports = function (t, e, n, m, g) { var v = r[t], y = v && v.prototype, _ = v, x = m ? "set" : "add", b = {}, w = function (t) { var e = y[t]; s(y, t, "add" == t ? function (t) { return e.call(this, 0 === t ? 0 : t), this } : "delete" == t ? function (t) { return !(g && !u(t)) && e.call(this, 0 === t ? 0 : t) } : "get" == t ? function (t) { return g && !u(t) ? void 0 : e.call(this, 0 === t ? 0 : t) } : "has" == t ? function (t) { return !(g && !u(t)) && e.call(this, 0 === t ? 0 : t) } : function (t, n) { return e.call(this, 0 === t ? 0 : t, n), this }) }; if (o(t, "function" != typeof v || !(g || y.forEach && !h((function () { (new v).entries().next() }))))) _ = n.getConstructor(e, t, m, x), a.REQUIRED = !0; else if (o(t, !0)) { var M = new _, T = M[x](g ? {} : -0, 1) != M, S = h((function () { M.has(1) })), E = d((function (t) { new v(t) })), A = !g && h((function () { for (var t = new v, e = 5; e--;)t[x](e, e); return !t.has(-0) })); E || ((_ = e((function (e, n) { l(e, _, t); var i = p(new v, e, _); return null != n && c(n, i[x], i, m), i }))).prototype = y, y.constructor = _), (S || A) && (w("delete"), w("has"), m && w("get")), (A || T) && w(x), g && y.clear && delete y.clear } return b[t] = _, i({ global: !0, forced: _ != v }, b), f(_, t), g || n.setStrong(_, t, m), _ } }, function (t, e, n) { var i = n(2); t.exports = !i((function () { return Object.isExtensible(Object.preventExtensions({})) })) }, function (t, e, n) { var i = n(1), r = n(21), o = i("iterator"), s = Array.prototype; t.exports = function (t) { return void 0 !== t && (r.Array === t || s[o] === t) } }, function (t, e, n) { var i = n(68), r = n(21), o = n(1)("iterator"); t.exports = function (t) { if (null != t) return t[o] || t["@@iterator"] || r[i(t)] } }, function (t, e, n) { var i = n(3); t.exports = function (t, e, n, r) { try { return r ? e(i(n)[0], n[1]) : e(n) } catch (e) { var o = t.return; throw void 0 !== o && i(o.call(t)), e } } }, function (t, e, n) { var i = n(4), r = n(44); t.exports = function (t, e, n) { var o, s; return r && "function" == typeof (o = e.constructor) && o !== n && i(s = o.prototype) && s !== n.prototype && r(t, s), t } }, function (t, e, n) { "use strict"; var i = n(6).f, r = n(28), o = n(70), s = n(29), a = n(47), c = n(46), l = n(42), u = n(71), h = n(7), d = n(67).fastKey, f = n(14), p = f.set, m = f.getterFor; t.exports = { getConstructor: function (t, e, n, l) { var u = t((function (t, i) { a(t, u, e), p(t, { type: e, index: r(null), first: void 0, last: void 0, size: 0 }), h || (t.size = 0), null != i && c(i, t[l], t, n) })), f = m(e), g = function (t, e, n) { var i, r, o = f(t), s = v(t, e); return s ? s.value = n : (o.last = s = { index: r = d(e, !0), key: e, value: n, previous: i = o.last, next: void 0, removed: !1 }, o.first || (o.first = s), i && (i.next = s), h ? o.size++ : t.size++, "F" !== r && (o.index[r] = s)), t }, v = function (t, e) { var n, i = f(t), r = d(e); if ("F" !== r) return i.index[r]; for (n = i.first; n; n = n.next)if (n.key == e) return n }; return o(u.prototype, { clear: function () { for (var t = f(this), e = t.index, n = t.first; n;)n.removed = !0, n.previous && (n.previous = n.previous.next = void 0), delete e[n.index], n = n.next; t.first = t.last = void 0, h ? t.size = 0 : this.size = 0 }, delete: function (t) { var e = f(this), n = v(this, t); if (n) { var i = n.next, r = n.previous; delete e.index[n.index], n.removed = !0, r && (r.next = i), i && (i.previous = r), e.first == n && (e.first = i), e.last == n && (e.last = r), h ? e.size-- : this.size-- } return !!n }, forEach: function (t) { for (var e, n = f(this), i = s(t, arguments.length > 1 ? arguments[1] : void 0, 3); e = e ? e.next : n.first;)for (i(e.value, e.key, this); e && e.removed;)e = e.previous }, has: function (t) { return !!v(this, t) } }), o(u.prototype, n ? { get: function (t) { var e = v(this, t); return e && e.value }, set: function (t, e) { return g(this, 0 === t ? 0 : t, e) } } : { add: function (t) { return g(this, t = 0 === t ? 0 : t, t) } }), h && i(u.prototype, "size", { get: function () { return f(this).size } }), u }, setStrong: function (t, e, n) { var i = e + " Iterator", r = m(e), o = m(i); l(t, e, (function (t, e) { p(this, { type: i, target: t, state: r(t), kind: e, last: void 0 }) }), (function () { for (var t = o(this), e = t.kind, n = t.last; n && n.removed;)n = n.previous; return t.target && (t.last = n = n ? n.next : t.state.first) ? "keys" == e ? { value: n.key, done: !1 } : "values" == e ? { value: n.value, done: !1 } : { value: [n.key, n.value], done: !1 } : (t.target = void 0, { value: void 0, done: !0 }) }), n ? "entries" : "values", !n, !0), u(e) } } }, function (t, e, n) { var i = n(8), r = n(2), o = n(19), s = n(43), a = n(66); i({ target: "Object", stat: !0, forced: r((function () { s(1) })), sham: !a }, { getPrototypeOf: function (t) { return s(o(t)) } }) }, function (t, e, n) { n(8)({ target: "Object", stat: !0 }, { setPrototypeOf: n(44) }) }, function (t, e, n) { "use strict"; var i = n(68), r = {}; r[n(1)("toStringTag")] = "z", t.exports = "[object z]" !== String(r) ? function () { return "[object " + i(this) + "]" } : r.toString }, function (t, e, n) { var i, r, o, s, a, c, l, u = n(0), h = n(22).f, d = n(11), f = n(73).set, p = n(74), m = u.MutationObserver || u.WebKitMutationObserver, g = u.process, v = u.Promise, y = "process" == d(g), _ = h(u, "queueMicrotask"), x = _ && _.value; x || (i = function () { var t, e; for (y && (t = g.domain) && t.exit(); r;) { e = r.fn, r = r.next; try { e() } catch (t) { throw r ? s() : o = void 0, t } } o = void 0, t && t.enter() }, y ? s = function () { g.nextTick(i) } : m && !/(iphone|ipod|ipad).*applewebkit/i.test(p) ? (a = !0, c = document.createTextNode(""), new m(i).observe(c, { characterData: !0 }), s = function () { c.data = a = !a }) : v && v.resolve ? (l = v.resolve(void 0), s = function () { l.then(i) }) : s = function () { f.call(u, i) }), t.exports = x || function (t) { var e = { fn: t, next: void 0 }; o && (o.next = e), r || (r = e, s()), o = e } }, function (t, e, n) { var i = n(3), r = n(4), o = n(75); t.exports = function (t, e) { if (i(t), r(e) && e.constructor === t) return e; var n = o.f(t); return (0, n.resolve)(e), n.promise } }, function (t, e, n) { var i = n(0); t.exports = function (t, e) { var n = i.console; n && n.error && (1 === arguments.length ? n.error(t) : n.error(t, e)) } }, function (t, e) { t.exports = function (t) { try { return { error: !1, value: t() } } catch (t) { return { error: !0, value: t } } } }, function (t, e, n) { "use strict"; var i = n(10), r = n(3), o = n(2), s = n(76), a = RegExp.prototype, c = a.toString, l = o((function () { return "/a/b" != c.call({ source: "a", flags: "b" }) })), u = "toString" != c.name; (l || u) && i(RegExp.prototype, "toString", (function () { var t = r(this), e = String(t.source), n = t.flags; return "/" + e + "/" + String(void 0 === n && t instanceof RegExp && !("flags" in a) ? s.call(t) : n) }), { unsafe: !0 }) }, function (t, e, n) { "use strict"; var i = n(77).charAt, r = n(14), o = n(42), s = r.set, a = r.getterFor("String Iterator"); o(String, "String", (function (t) { s(this, { type: "String Iterator", string: String(t), index: 0 }) }), (function () { var t, e = a(this), n = e.string, r = e.index; return r >= n.length ? { value: void 0, done: !0 } : (t = i(n, r), e.index += t.length, { value: t, done: !1 }) })) }, function (t, e, n) { "use strict"; var i = n(8), r = n(114); i({ target: "String", proto: !0, forced: n(115)("anchor") }, { anchor: function (t) { return r(this, "a", "name", t) } }) }, function (t, e, n) { var i = n(12), r = /"/g; t.exports = function (t, e, n, o) { var s = String(i(t)), a = "<" + e; return "" !== n && (a += " " + n + '="' + String(o).replace(r, "&quot;") + '"'), a + ">" + s + "</" + e + ">" } }, function (t, e, n) { var i = n(2); t.exports = function (t) { return i((function () { var e = ""[t]('"'); return e !== e.toLowerCase() || e.split('"').length > 3 })) } }, function (t, e, n) { var i = n(0), r = n(117), o = n(64), s = n(9), a = n(1), c = a("iterator"), l = a("toStringTag"), u = o.values; for (var h in r) { var d = i[h], f = d && d.prototype; if (f) { if (f[c] !== u) try { s(f, c, u) } catch (t) { f[c] = u } if (f[l] || s(f, l, h), r[h]) for (var p in o) if (f[p] !== o[p]) try { s(f, p, o[p]) } catch (t) { f[p] = o[p] } } } }, function (t, e) { t.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 } }, function (t, e, n) { "use strict"; var i = n(8), r = n(34); i({ target: "RegExp", proto: !0, forced: /./.exec !== r }, { exec: r }) }, function (t, e, n) { "use strict"; var i = n(48), r = n(3), o = n(15), s = n(12), a = n(49), c = n(50); i("match", 1, (function (t, e, n) { return [function (e) { var n = s(this), i = null == e ? void 0 : e[t]; return void 0 !== i ? i.call(e, n) : new RegExp(e)[t](String(n)) }, function (t) { var i = n(e, t, this); if (i.done) return i.value; var s = r(t), l = String(this); if (!s.global) return c(s, l); var u = s.unicode; s.lastIndex = 0; for (var h, d = [], f = 0; null !== (h = c(s, l));) { var p = String(h[0]); d[f] = p, "" === p && (s.lastIndex = a(l, o(s.lastIndex), u)), f++ } return 0 === f ? null : d }] })) }, function (t, e, n) { "use strict"; var i = n(48), r = n(3), o = n(19), s = n(15), a = n(27), c = n(12), l = n(49), u = n(50), h = Math.max, d = Math.min, f = Math.floor, p = /\$([$&'`]|\d\d?|<[^>]*>)/g, m = /\$([$&'`]|\d\d?)/g; i("replace", 2, (function (t, e, n) { return [function (n, i) { var r = c(this), o = null == n ? void 0 : n[t]; return void 0 !== o ? o.call(n, r, i) : e.call(String(r), n, i) }, function (t, o) { var c = n(e, t, this, o); if (c.done) return c.value; var f = r(t), p = String(this), m = "function" == typeof o; m || (o = String(o)); var g = f.global; if (g) { var v = f.unicode; f.lastIndex = 0 } for (var y = []; ;) { var _ = u(f, p); if (null === _) break; if (y.push(_), !g) break; "" === String(_[0]) && (f.lastIndex = l(p, s(f.lastIndex), v)) } for (var x, b = "", w = 0, M = 0; M < y.length; M++) { _ = y[M]; for (var T = String(_[0]), S = h(d(a(_.index), p.length), 0), E = [], A = 1; A < _.length; A++)E.push(void 0 === (x = _[A]) ? x : String(x)); var P = _.groups; if (m) { var L = [T].concat(E, S, p); void 0 !== P && L.push(P); var R = String(o.apply(void 0, L)) } else R = i(T, p, S, E, P, o); S >= w && (b += p.slice(w, S) + R, w = S + T.length) } return b + p.slice(w) }]; function i(t, n, i, r, s, a) { var c = i + t.length, l = r.length, u = m; return void 0 !== s && (s = o(s), u = p), e.call(a, u, (function (e, o) { var a; switch (o.charAt(0)) { case "$": return "$"; case "&": return t; case "`": return n.slice(0, i); case "'": return n.slice(c); case "<": a = s[o.slice(1, -1)]; break; default: var u = +o; if (0 === u) return e; if (u > l) { var h = f(u / 10); return 0 === h ? e : h <= l ? void 0 === r[h - 1] ? o.charAt(1) : r[h - 1] + o.charAt(1) : e } a = r[u - 1] }return void 0 === a ? "" : a })) } })) }, function (t, e, n) { "use strict"; var i = n(48), r = n(122), o = n(3), s = n(12), a = n(72), c = n(49), l = n(15), u = n(50), h = n(34), d = n(2), f = [].push, p = Math.min, m = !d((function () { return !RegExp(4294967295, "y") })); i("split", 2, (function (t, e, n) { var i; return i = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function (t, n) { var i = String(s(this)), o = void 0 === n ? 4294967295 : n >>> 0; if (0 === o) return []; if (void 0 === t) return [i]; if (!r(t)) return e.call(i, t, o); for (var a, c, l, u = [], d = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), p = 0, m = new RegExp(t.source, d + "g"); (a = h.call(m, i)) && !((c = m.lastIndex) > p && (u.push(i.slice(p, a.index)), a.length > 1 && a.index < i.length && f.apply(u, a.slice(1)), l = a[0].length, p = c, u.length >= o));)m.lastIndex === a.index && m.lastIndex++; return p === i.length ? !l && m.test("") || u.push("") : u.push(i.slice(p)), u.length > o ? u.slice(0, o) : u } : "0".split(void 0, 0).length ? function (t, n) { return void 0 === t && 0 === n ? [] : e.call(this, t, n) } : e, [function (e, n) { var r = s(this), o = null == e ? void 0 : e[t]; return void 0 !== o ? o.call(e, r, n) : i.call(String(r), e, n) }, function (t, r) { var s = n(i, t, this, r, i !== e); if (s.done) return s.value; var h = o(t), d = String(this), f = a(h, RegExp), g = h.unicode, v = (h.ignoreCase ? "i" : "") + (h.multiline ? "m" : "") + (h.unicode ? "u" : "") + (m ? "y" : "g"), y = new f(m ? h : "^(?:" + h.source + ")", v), _ = void 0 === r ? 4294967295 : r >>> 0; if (0 === _) return []; if (0 === d.length) return null === u(y, d) ? [d] : []; for (var x = 0, b = 0, w = []; b < d.length;) { y.lastIndex = m ? b : 0; var M, T = u(y, m ? d : d.slice(b)); if (null === T || (M = p(l(y.lastIndex + (m ? 0 : b)), d.length)) === x) b = c(d, b, g); else { if (w.push(d.slice(x, b)), w.length === _) return w; for (var S = 1; S <= T.length - 1; S++)if (w.push(T[S]), w.length === _) return w; b = x = M } } return w.push(d.slice(x)), w }] }), !m) }, function (t, e, n) { var i = n(4), r = n(11), o = n(1)("match"); t.exports = function (t) { var e; return i(t) && (void 0 !== (e = t[o]) ? !!e : "RegExp" == r(t)) } }, function (t, e, n) { "use strict"; n.r(e), n(80), n(90), n(91), n(64), n(95), n(45), n(96), n(31), n(104), n(105), n(32), n(33), n(111), n(112), n(113), n(116), n(78); var i = n(79), r = n.n(i); function o(t, e, n, i, r, o, s) { try { var a = t[o](s), c = a.value } catch (t) { return void n(t) } a.done ? e(c) : Promise.resolve(c).then(i, r) } function s(t) { return function () { var e = this, n = arguments; return new Promise((function (i, r) { var s = t.apply(e, n); function a(t) { o(s, i, r, a, c, "next", t) } function c(t) { o(s, i, r, a, c, "throw", t) } a(void 0) })) } } function a(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } n(118), n(119), n(120), n(121); var c = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.wrap = document.querySelector("[data-router-wrapper]"), this.properties = e, this.Transition = e.transition ? new e.transition.class(this.wrap, e.transition.name) : null } var e, n, i; return e = t, (n = [{ key: "setup", value: function () { this.onEnter && this.onEnter(), this.onEnterCompleted && this.onEnterCompleted() } }, { key: "add", value: function () { this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML) } }, { key: "update", value: function () { document.title = this.properties.page.title } }, { key: "show", value: function (t) { var e = this; return new Promise(function () { var n = s(regeneratorRuntime.mark((function n(i) { return regeneratorRuntime.wrap((function (n) { for (; ;)switch (n.prev = n.next) { case 0: if (e.update(), e.onEnter && e.onEnter(), n.t0 = e.Transition, !n.t0) { n.next = 6; break } return n.next = 6, e.Transition.show(t); case 6: e.onEnterCompleted && e.onEnterCompleted(), i(); case 8: case "end": return n.stop() } }), n) }))); return function (t) { return n.apply(this, arguments) } }()) } }, { key: "hide", value: function (t) { var e = this; return new Promise(function () { var n = s(regeneratorRuntime.mark((function n(i) { return regeneratorRuntime.wrap((function (n) { for (; ;)switch (n.prev = n.next) { case 0: if (e.onLeave && e.onLeave(), n.t0 = e.Transition, !n.t0) { n.next = 5; break } return n.next = 5, e.Transition.hide(t); case 5: e.onLeaveCompleted && e.onLeaveCompleted(), i(); case 7: case "end": return n.stop() } }), n) }))); return function (t) { return n.apply(this, arguments) } }()) } }]) && a(e.prototype, n), i && a(e, i), t }(); function l(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } var u = new window.DOMParser, h = function () { function t(e, n) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.renderers = e, this.transitions = n } var e, n, i; return e = t, (n = [{ key: "getOrigin", value: function (t) { var e = t.match(/(https?:\/\/[\w\-.]+)/); return e ? e[1].replace(/https?:\/\//, "") : null } }, { key: "getPathname", value: function (t) { var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/); return e ? e[1] : "/" } }, { key: "getAnchor", value: function (t) { var e = t.match(/(#.*)$/); return e ? e[1] : null } }, { key: "getParams", value: function (t) { var e = t.match(/\?([\w_\-.=&]+)/); if (!e) return null; for (var n = e[1].split("&"), i = {}, r = 0; r < n.length; r++) { var o = n[r].split("="), s = o[0], a = o[1]; i[s] = a } return i } }, { key: "getDOM", value: function (t) { return "string" == typeof t ? u.parseFromString(t, "text/html") : t } }, { key: "getView", value: function (t) { return t.querySelector("[data-router-view]") } }, { key: "getSlug", value: function (t) { return t.getAttribute("data-router-view") } }, { key: "getRenderer", value: function (t) { if (!this.renderers) return Promise.resolve(c); if (t in this.renderers) { var e = this.renderers[t]; return "function" != typeof e || c.isPrototypeOf(e) ? "function" == typeof e.then ? Promise.resolve(e).then((function (t) { return t.default })) : Promise.resolve(e) : Promise.resolve(e()).then((function (t) { return t.default })) } return Promise.resolve(c) } }, { key: "getTransition", value: function (t) { return this.transitions ? t in this.transitions ? { class: this.transitions[t], name: t } : "default" in this.transitions ? { class: this.transitions.default, name: "default" } : null : null } }, { key: "getProperties", value: function (t) { var e = this.getDOM(t), n = this.getView(e), i = this.getSlug(n); return { page: e, view: n, slug: i, renderer: this.getRenderer(i, this.renderers), transition: this.getTransition(i, this.transitions) } } }, { key: "getLocation", value: function (t) { return { href: t, anchor: this.getAnchor(t), origin: this.getOrigin(t), params: this.getParams(t), pathname: this.getPathname(t) } } }]) && l(e.prototype, n), i && l(e, i), t }(); function d(t) { return (d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function f(t, e, n, i, r, o, s) { try { var a = t[o](s), c = a.value } catch (t) { return void n(t) } a.done ? e(c) : Promise.resolve(c).then(i, r) } function p(t) { return function () { var e = this, n = arguments; return new Promise((function (i, r) { var o = t.apply(e, n); function s(t) { f(o, i, r, s, a, "next", t) } function a(t) { f(o, i, r, s, a, "throw", t) } s(void 0) })) } } function m(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function g(t) { return (g = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function v(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function y(t, e) { return (y = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } var _ = function (t) { function e() { var t, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, i = n.renderers, r = n.transitions; return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), (t = function (t, e) { return !e || "object" !== d(e) && "function" != typeof e ? v(t) : e }(this, g(e).call(this))).Helpers = new h(i, r), t.Transitions = r, t.Contextual = !1, t.location = t.Helpers.getLocation(window.location.href), t.properties = t.Helpers.getProperties(document.cloneNode(!0)), t.popping = !1, t.running = !1, t.trigger = null, t.cache = new Map, t.cache.set(t.location.href, t.properties), t.properties.renderer.then((function (e) { t.From = new e(t.properties), t.From.setup() })), t._navigate = t.navigate.bind(v(t)), window.addEventListener("popstate", t.popState.bind(v(t))), t.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), t.attach(t.links), t } var n, i, r, o, s; return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && y(t, e) }(e, t), n = e, (i = [{ key: "attach", value: function (t) { var e = !0, n = !1, i = void 0; try { for (var r, o = t[Symbol.iterator](); !(e = (r = o.next()).done); e = !0)r.value.addEventListener("click", this._navigate) } catch (t) { n = !0, i = t } finally { try { e || null == o.return || o.return() } finally { if (n) throw i } } } }, { key: "detach", value: function (t) { var e = !0, n = !1, i = void 0; try { for (var r, o = t[Symbol.iterator](); !(e = (r = o.next()).done); e = !0)r.value.removeEventListener("click", this._navigate) } catch (t) { n = !0, i = t } finally { try { e || null == o.return || o.return() } finally { if (n) throw i } } } }, { key: "navigate", value: function (t) { if (!t.metaKey && !t.ctrlKey) { t.preventDefault(); var e = !!t.currentTarget.hasAttribute("data-transition") && t.currentTarget.dataset.transition; this.redirect(t.currentTarget.href, e, t.currentTarget) } } }, { key: "redirect", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "script"; if (this.trigger = n, !this.running && t !== this.location.href) { var i = this.Helpers.getLocation(t); this.Contextual = !1, e && (this.Contextual = this.Transitions.contextual[e].prototype, this.Contextual.name = e), i.origin !== this.location.origin || i.anchor && i.pathname === this.location.pathname ? window.location.href = t : (this.location = i, this.beforeFetch()) } } }, { key: "popState", value: function () { this.trigger = "popstate", this.Contextual = !1; var t = this.Helpers.getLocation(window.location.href); this.location.pathname !== t.pathname || !this.location.anchor && !t.anchor ? (this.popping = !0, this.location = t, this.beforeFetch()) : this.location = t } }, { key: "pushState", value: function () { this.popping || window.history.pushState(this.location, "", this.location.href) } }, { key: "fetch", value: function (t) { function e() { return t.apply(this, arguments) } return e.toString = function () { return t.toString() }, e }(p(regeneratorRuntime.mark((function t() { var e; return regeneratorRuntime.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.next = 2, fetch(this.location.href, { mode: "same-origin", method: "GET", headers: { "X-Requested-With": "Highway" }, credentials: "same-origin" }); case 2: if (!((e = t.sent).status >= 200 && e.status < 300)) { t.next = 5; break } return t.abrupt("return", e.text()); case 5: window.location.href = this.location.href; case 6: case "end": return t.stop() } }), t, this) })))) }, { key: "beforeFetch", value: (s = p(regeneratorRuntime.mark((function t() { var e, n; return regeneratorRuntime.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if (this.pushState(), this.running = !0, this.emit("NAVIGATE_OUT", { from: { page: this.From.properties.page, view: this.From.properties.view }, trigger: this.trigger, location: this.location }), e = { trigger: this.trigger, contextual: this.Contextual }, !this.cache.has(this.location.href)) { t.next = 10; break } return t.next = 7, this.From.hide(e); case 7: this.properties = this.cache.get(this.location.href), t.next = 15; break; case 10: return t.next = 12, Promise.all([this.fetch(), this.From.hide(e)]); case 12: n = t.sent, this.properties = this.Helpers.getProperties(n[0]), this.cache.set(this.location.href, this.properties); case 15: this.afterFetch(); case 16: case "end": return t.stop() } }), t, this) }))), function () { return s.apply(this, arguments) }) }, { key: "afterFetch", value: (o = p(regeneratorRuntime.mark((function t() { var e; return regeneratorRuntime.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.next = 2, this.properties.renderer; case 2: return e = t.sent, this.To = new e(this.properties), this.To.add(), this.emit("NAVIGATE_IN", { to: { page: this.To.properties.page, view: this.To.wrap.lastElementChild }, trigger: this.trigger, location: this.location }), t.next = 8, this.To.show({ trigger: this.trigger, contextual: this.Contextual }); case 8: this.popping = !1, this.running = !1, this.detach(this.links), this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), this.attach(this.links), this.emit("NAVIGATE_END", { to: { page: this.To.properties.page, view: this.To.wrap.lastElementChild }, from: { page: this.From.properties.page, view: this.From.properties.view }, trigger: this.trigger, location: this.location }), this.From = this.To, this.trigger = null; case 16: case "end": return t.stop() } }), t, this) }))), function () { return o.apply(this, arguments) }) }]) && m(n.prototype, i), r && m(n, r), e }(r.a); function x(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } var b = function () { function t(e, n) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.wrap = e, this.name = n } var e, n, i; return e = t, (n = [{ key: "show", value: function (t) { var e = this, n = t.trigger, i = t.contextual, r = this.wrap.lastElementChild, o = this.wrap.firstElementChild; return new Promise((function (t) { i ? (r.setAttribute("data-transition-in", i.name), r.removeAttribute("data-transition-out", i.name), i.in && i.in({ to: r, from: o, trigger: n, done: t })) : (r.setAttribute("data-transition-in", e.name), r.removeAttribute("data-transition-out", e.name), e.in && e.in({ to: r, from: o, trigger: n, done: t })) })) } }, { key: "hide", value: function (t) { var e = this, n = t.trigger, i = t.contextual, r = this.wrap.firstElementChild; return new Promise((function (t) { i ? (r.setAttribute("data-transition-out", i.name), r.removeAttribute("data-transition-in", i.name), i.out && i.out({ from: r, trigger: n, done: t })) : (r.setAttribute("data-transition-out", e.name), r.removeAttribute("data-transition-in", e.name), e.out && e.out({ from: r, trigger: n, done: t })) })) } }]) && x(e.prototype, n), i && x(e, i), t }(); e.default = { Core: _, Helpers: h, Renderer: c, Transition: b } }]) }, t.exports = i() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function () { if (screen.width > 460) { var t = function (t) { var e = this.querySelector(".sticky"), n = t.clientX - e.getBoundingClientRect().left, r = t.clientY - e.getBoundingClientRect().top; i.TweenMax.to(e, 1.5, { x: (n - e.getBoundingClientRect().width / 2) / e.getBoundingClientRect().width * 60, y: (r - e.getBoundingClientRect().height / 2) / e.getBoundingClientRect().height * 60, scale: 1.1, ease: i.Power1.easeOut }) }, e = function () { var t = this.querySelector(".sticky"); i.TweenMax.to(t, 1, { x: 0, y: 0, scale: 1, ease: i.Power1.easeOut }) }, n = document.querySelectorAll(".mouse_sticky_wrapper"); n.forEach((function (e) { return e.addEventListener("mousemove", t) })), n.forEach((function (t) { return t.addEventListener("mouseleave", e) })) } }; var i = n(1) }, function (t, e, n) { "use strict"; !function (t, e) { var n = 2147483647, i = Math.floor, r = function (t, e) { return (t << e & 4294967295 | t >>> 32 - e) >>> 0 }, o = function (t) { this.a = 4058668781, this.b = t, this.c = t, this.d = t, this.s = 0 }; o.prototype.seed = function (t) { this.a = 4058668781, this.b = t, this.c = t, this.d = t, this.s = 0 }, o.prototype.seedAll = function (t, e, n) { this.a = 4058668781, this.b = t, this.c = e, this.d = n, this.s = 0 }, o.prototype.randval = function () { var t = (this.a - r(this.b, 27) & 4294967295) >>> 0; return this.a = (4294967295 & (this.b ^ r(this.c, 17))) >>> 0, this.b = (this.c + this.d & 4294967295) >>> 0, this.c = (this.d + t & 4294967295) >>> 0, this.d = (t + this.a & 4294967295) >>> 0, this.s++, this.d }, o.prototype.step = function (t) { 0 === (t = "number" == typeof t ? t : 1) && (t = 1); for (var e = 0; e < t; e++) { var n = (this.a - r(this.b, 27) & 4294967295) >>> 0; this.a = (4294967295 & (this.b ^ r(this.c, 17))) >>> 0, this.b = (this.c + this.d & 4294967295) >>> 0, this.c = (this.d + n & 4294967295) >>> 0, this.d = (n + this.a & 4294967295) >>> 0, this.s++ } }, o.prototype.random = function () { var t = this.randval() % n / n; switch (arguments.length) { case 0: return t; case 1: return (e = arguments[0]) < 1 ? (console.log("upper limit invalid"), null) : i(t * e) + 1; case 2: var e, r = arguments[0]; return r >= (e = arguments[1]) ? (console.log("upper limit invalid"), null) : i(t * (e - r + 1)) + r; default: console.log("invalid amount of arguments") }return null }, t.SmallPRNG = o }(window) }, function (t, e, n) { "use strict"; var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }; window.addEventListener("load", (function (t) { var e; this.Element && Element.prototype.attachEvent && !Element.prototype.addEventListener && function () { function t(t, e) { Window.prototype[t] = HTMLDocument.prototype[t] = Element.prototype[t] = e } function e() { e.interval && document.body && (e.interval = clearInterval(e.interval), document.dispatchEvent(new CustomEvent("DOMContentLoaded"))) } t("addEventListener", (function (t, e) { var n = this, i = n.addEventListener.listeners = n.addEventListener.listeners || {}, r = i[t] = i[t] || []; r.length || n.attachEvent("on" + t, r.event = function (t) { var e = n.document && n.document.documentElement || n.documentElement || { scrollLeft: 0, scrollTop: 0 }; t.currentTarget = n, t.pageX = t.clientX + e.scrollLeft, t.pageY = t.clientY + e.scrollTop, t.preventDefault = function () { t.returnValue = !1 }, t.relatedTarget = t.fromElement || null, t.stopImmediatePropagation = function () { a = !1, t.cancelBubble = !0 }, t.stopPropagation = function () { t.cancelBubble = !0 }, t.target = t.srcElement || n, t.timeStamp = +new Date; for (var i, o = 0, s = [].concat(r), a = !0; a && (i = s[o]); ++o)for (var c, l = 0; c = r[l]; ++l)if (c == i) { c.call(n, t); break } }), r.push(e) })), t("removeEventListener", (function (t, e) { for (var n, i = this, r = i.addEventListener.listeners = i.addEventListener.listeners || {}, o = r[t] = r[t] || [], s = o.length - 1; n = o[s]; --s)if (n == e) { o.splice(s, 1); break } !o.length && o.event && i.detachEvent("on" + t, o.event) })), t("dispatchEvent", (function (t) { var e = this, n = t.type, i = e.addEventListener.listeners = e.addEventListener.listeners || {}, r = i[n] = i[n] || []; try { return e.fireEvent("on" + n, t) } catch (e) { return void (r.event && r.event(t)) } })), Object.defineProperty(Window.prototype, "CustomEvent", { get: function () { var t = this; return function (e, n) { var i, r = t.document.createEventObject(); for (i in r.type = e, n) "cancelable" == i ? r.returnValue = !n.cancelable : "bubbles" == i ? r.cancelBubble = !n.bubbles : "detail" == i && (r.detail = n.detail); return r } } }), e.interval = setInterval(e, 1), window.addEventListener("load", e) }(), !this.CustomEvent && (window.CustomEvent = function (t, e) { var n; e = e || { bubbles: !1, cancelable: !1, detail: void 0 }; try { (n = document.createEvent("CustomEvent")).initCustomEvent(t, e.bubbles, e.cancelable, e.detail) } catch (i) { (n = document.createEvent("Event")).initEvent(t, e.bubbles, e.cancelable), n.detail = e.detail } return n }), window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { window.setTimeout(t, 1e3 / 60) }, "create" in Object && "function" == typeof Object.create || (Object.create = (e = function () { }, function (t) { if (arguments.length > 1) throw Error("Second argument not supported"); if ("object" != (void 0 === t ? "undefined" : i(t))) throw TypeError("Argument must be an object"); e.prototype = t; var n = new e; return e.prototype = null, n })), "extend" in Function.prototype && "function" == typeof Function.prototype.extend || (Function.prototype.extend = function (t) { return function (t, e) { return e.prototype = Object.create(t.prototype), e.parent = t, e.prototype.constructor = e, e }(this, t) }), window.Easing = { linear: function (t) { return t }, easeInQuad: function (t) { return t * t }, easeOutQuad: function (t) { return t * (2 - t) }, easeInOutQuad: function (t) { return .5 > t ? 2 * t * t : (4 - 2 * t) * t - 1 }, easeInCubic: function (t) { return t * t * t }, easeOutCubic: function (t) { return --t * t * t + 1 }, easeInOutCubic: function (t) { return .5 > t ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 }, easeInQuart: function (t) { return t * t * t * t }, easeOutQuart: function (t) { return 1 - --t * t * t * t }, easeInOutQuart: function (t) { return .5 > t ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t }, easeInQuint: function (t) { return t * t * t * t * t }, easeOutQuint: function (t) { return 1 + --t * t * t * t * t }, easeInOutQuint: function (t) { return .5 > t ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t } }, function (t) { "Math" in t || (t.Math = {}), "Util" in t || (t.Util = {}); var e = t.Math, n = t.Util; e.Tau = 2 * e.PI, e.map = function (t, e, n, i, r) { return (t - e) * (r - i) / (n - e) + i }, e.dist = function (t, e, n, i) { var r = t - n, o = e - i; return Math.sqrt(r * r + o * o) }, e.lineIntersect = function (t, e, n, i, r, o, s, a) { return that instanceof PointLine ? (f = ((u = s - r) * (e - o) - (h = a - o) * (t - r)) / (-u * (l = i - e) + (c = n - t) * h), (d = (-l * (t - r) + c * (e - o)) / (-u * l + c * h)) >= 0 && 1 >= d && f >= 0 && 1 >= f ? { x: Math.floor(t + f * c), y: Math.floor(e + f * l) } : null) : null; var c, l, u, h, d, f }, e.rad = function (t) { return t * (Math.PI / 180) }, e.deg = function (t) { return t * (180 / Math.PI) }, e.pointOnCircle = function (t, n, i, r) { return { x: t + i * Math.cos(e.rad(r)), y: n + i * Math.sin(e.rad(r)) } }, e.lineProgress = function (t, e, n, i, r) { return { x: t + (n - t) * r, y: e + (i - e) * r } }, e.randInt = function (t, e) { return Math.floor(Math.random() * (e - t + 1)) + t }, e.mrandInt = function (t) { return Math.floor(Math.random() * t) }, e.randFloat = function (t, e) { return Math.random() * (e - t + 1) + t }, e.mrandFloat = function (t) { return Math.random() * t }, e.randSign = function () { return Math.random() > .5 ? -1 : 1 }, e.scale = function (t, e, n, i) { var r, o; return t > n && (r = n, o = n / t * e), e > i && (r = i / e * t, o = i), { w: Math.floor(r), h: Math.floor(o) } }, n.easer = function (t, e, n) { var i = Date.now() - e, r = t(i / n); return i >= n && (r = 1), r } }(window), function (t) { var e = function (t) { return 2 !== t.length ? t + t : t }, n = /\#([0-9a-f]{1,2})([0-9a-f]{1,2})([0-9a-f]{1,2})/i, i = function (t, e, n, i) { i = i || 1, this.r = t, this.g = e, this.b = n, this.a = i }; i.prototype.toString = function () { return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.a + ")" }, i.fromHex = function (t) { if ("string" != typeof t) throw new TypeError("hexadecimal color must be a string"); if (4 !== t.length && 7 !== t.length) throw new TypeError("invalid hexadecimal format"); var r = new i, o = t.match(n); if (!o) throw new TypeError("invalid hexadecimal format"); return r.r = parseInt(e(o[1]), 16), r.g = parseInt(e(o[2]), 16), r.b = parseInt(e(o[3]), 16), r.a = 1, r }, i.random = function (t, e) { return new i(Math.randInt(t, e), Math.randInt(t, e), Math.randInt(t, e), 1) }, i.randomEx = function (t) { return new i(Math.randInt(t.rmin, t.rmax), Math.randInt(t.gmin, t.gmax), Math.randInt(t.bmin, t.bmax), 1) }; var r = function (t, e, n) { this.r = t, this.g = e, this.b = n }; r.prototype.toString = function () { return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")" }, r.fromHex = function (t) { if ("string" != typeof t) throw new TypeError("hexadecimal color must be a string"); if (4 !== t.length && 7 !== t.length) throw new TypeError("invalid hexadecimal format"); var i = new r, o = t.match(n); if (!o) throw new TypeError("invalid hexadecimal format"); return i.r = parseInt(e(o[1]), 16), i.g = parseInt(e(o[2]), 16), i.b = parseInt(e(o[3]), 16), i }, r.random = function (t, e) { return new r(Math.randInt(t, e), Math.randInt(t, e), Math.randInt(t, e)) }, r.randomEx = function (t) { return new r(Math.randInt(t.rmin, t.rmax), Math.randInt(t.gmin, t.gmax), Math.randInt(t.bmin, t.bmax)) }, t.RGBA = i, t.RGB = r }(window) }), !1) }, function (t, e) { t.exports = function (t, { tagName: e = "span", split: n, setClassName: i = function (t) { return "char" + t } } = {}) { t.normalize(); let r = 1; function o(t) { const o = t.parentNode, s = t.nodeValue; (n ? n(s) : s.split("")).forEach((function (n) { const s = document.createElement(e), a = i(r++, n); a && (s.className = a), s.appendChild(document.createTextNode(n)), s.setAttribute("aria-hidden", "true"), o.insertBefore(s, t) })), "" !== s.trim() && o.setAttribute("aria-label", s), o.removeChild(t) } !function t(e) { if (3 === e.nodeType) return o(e); const n = Array.prototype.slice.call(e.childNodes); if (1 === n.length && 3 === n[0].nodeType) return o(n[0]); n.forEach((function (e) { t(e) })) }(t) } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Distortion = void 0; var i = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return function (t, e) { var n = [], i = !0, r = !1, o = void 0; try { for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); i = !0); } catch (t) { r = !0, o = t } finally { try { !i && a.return && a.return() } finally { if (r) throw o } } return n }(t, e); throw new TypeError("Invalid attempt to destructure non-iterable instance") }, r = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), o = function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e.default = t, e }(n(28)), s = u(n(29)), a = u(n(30)), c = n(31), l = n(32); function u(t) { return t && t.__esModule ? t : { default: t } } e.Distortion = function () { function t(e, n) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), e && (this.$el = document.querySelector(e), this.options = n, this.imgSize = this.options.fullScreen ? 0 : 1, this.waveIntensity = this.options.fullScreen ? .005 : .2, this.$wrapper = document.querySelector(".js-wrapper"), this.width = window.innerWidth, this.height = window.innerHeight, this.scrollDisbled = this.options.fullScreen, this.mouse = { x: 0, y: 0 }, this.lastmouse = { x: 0, y: 0 }, this.init()) } var e, n; return r(t, [{ key: "init", value: function () { var t = this; this.gl = { renderer: new o.WebGLRenderer({ antialias: !0 }), camera: new o.PerspectiveCamera(45, 1, .1, 1e4), scene: new o.Scene, loader: new o.TextureLoader, clock: new o.Clock }, this.textures = this.options.textures, this.texturesLoaded = [], this.textureLoading(), this.loadCanvas = function (e) { t.texturesLoaded = e, t.setup(), t.clickHandler = function (e) { e.ctrlKey || e.metaKey || (t.scrollDisbled = !0, (0, c.clickAnimation)(t.uniforms)) }, t.options.fullScreen || t.$wrapper.addEventListener("click", t.clickHandler), t.render = function () { return t.gl.renderer.render(t.gl.scene, t.gl.camera) }, t.start = performance.now(), t.addScene(), t.mouseEmitter = new l.MouseMove({ mouse: t.mouse, lastmouse: t.lastmouse, uniforms: t.uniforms }), t.mouseMoveHandler = t.mouseEmitter.mouseMoveHandler.bind(t), document.body.addEventListener("mousemove", t.mouseMoveHandler), t.update = t.update.bind(t), t.update(), t.resize = t.resize.bind(t), t.resize(), window.addEventListener("resize", t.resize) } } }, { key: "setup", value: function () { this.factors = this.textures.map((function () { return new o.Vector2(1, 1) })), this.currentIndex = 0, this.uniforms = { u_time: { type: "f", value: 0 }, u_res: { type: "v2", value: new o.Vector2(this.width, this.height) }, u_mouse: { type: "v2", value: new o.Vector2(0, 0) }, u_directionMouse: { type: "v2", value: new o.Vector2(0, 0) }, u_text0: { value: this.texturesLoaded[this.currentIndex] }, u_progress: { type: "f", value: this.imgSize }, u_waveIntensity: { type: "f", value: this.waveIntensity }, u_direction: { type: "f", value: this.imgSize }, u_offset: { type: "f", value: 7 }, u_volatility: { type: "f", value: 0 }, u_textureFactor: { type: "v2", value: this.factors[this.currentIndex] } } } }, { key: "calculateAspectRatioFactor", value: function (t, e) { var n = i(this.getPlaneSize, 2), r = n[0] / n[1] * (this.width / this.height), s = e.image.width / e.image.height, a = 1, c = 1; r > s ? (a = 1, c = 1 / r * s) : (a = 1 * r / s, c = 1), this.factors[t] = new o.Vector2(a, c), this.currentIndex === t && (this.uniforms.u_textureFactor.value = this.factors[t], this.uniforms.u_textureFactor.needsUpdate = !0) } }, { key: "addScene", value: function () { this.gl.renderer.setSize(this.width, this.height), this.gl.renderer.setPixelRatio(window.devicePixelRatio), this.$el.append(this.gl.renderer.domElement), this.gl.camera.position.z = this.width > this.height ? 5 : 12, this.gl.scene.add(this.gl.camera), this.addMesh() } }, { key: "addMesh", value: function () { var t = i(this.getPlaneSize, 2), e = t[0], n = t[1]; this.geometry = new o.PlaneGeometry(e, n, 60, 60), this.material = new o.ShaderMaterial({ uniforms: this.uniforms, vertexShader: a.default, fragmentShader: s.default }), this.gl.mesh = new o.Mesh(this.geometry, this.material), this.gl.scene.add(this.gl.mesh) } }, { key: "resize", value: function () { var t = window.innerWidth, e = window.innerHeight; this.gl.renderer.setSize(t, e), this.uniforms.u_res.value.x = t, this.uniforms.u_res.value.y = e; var n = !0, r = !1, o = void 0; try { for (var s, a = this.texturesLoaded.entries()[Symbol.iterator](); !(n = (s = a.next()).done); n = !0) { var c = s.value, l = i(c, 2), u = l[0], h = l[1]; this.calculateAspectRatioFactor(u, h) } } catch (t) { r = !0, o = t } finally { try { !n && a.return && a.return() } finally { if (r) throw o } } this.gl.camera.updateProjectionMatrix() } }, { key: "changeTexture", value: function (t) { t = Math.round(t), this.scrollDisbled || (this.uniforms.u_textureFactor.value = this.factors[t], this.uniforms.u_text0.value = this.texturesLoaded[t]) } }, { key: "update", value: function () { this.uniforms.u_time.value = this.gl.clock.getElapsedTime(); var t = performance.now(), e = t - this.start; this.mouseEmitter.onMouse(e), this.start = t, this.render(), this.raf = requestAnimationFrame(this.update) } }, { key: "textureDidLoaded", value: function () { } }, { key: "textureLoading", value: (e = regeneratorRuntime.mark((function t() { var e = this; return regeneratorRuntime.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return this.results = [], this.textures.map((function (t) { var n = e.gl.loader.loadAsync(t); e.results.push(n) })), t.prev = 2, t.next = 5, Promise.all(this.results).then((function (t) { t.map((function (t, n) { e.texturesLoaded.push(t), n + 1 === e.textures.length && (e.loadCanvas(e.texturesLoaded), e.textureDidLoaded()) })) })); case 5: t.next = 10; break; case 7: t.prev = 7, t.t0 = t.catch(2), console.log(t.t0); case 10: case "end": return t.stop() } }), t, this, [[2, 7]]) })), n = function () { var t = e.apply(this, arguments); return new Promise((function (e, n) { return function i(r, o) { try { var s = t[r](o), a = s.value } catch (t) { return void n(t) } if (!s.done) return Promise.resolve(a).then((function (t) { i("next", t) }), (function (t) { i("throw", t) })); e(a) }("next") })) }, function () { return n.apply(this, arguments) }) }, { key: "destroy", value: function () { this.gl.scene.remove(this.gl.mesh), cancelAnimationFrame(this.raf), this.geometry.dispose(), this.material.dispose(), this.texturesLoaded.forEach((function (t) { t.dispose() })), window.removeEventListener("resize", this.resize), this.options.fullScreen || this.$wrapper.removeEventListener("click", this.clickHandler), document.body.removeEventListener("mousemove", this.mouseMoveHandler), this.$el.removeChild(this.gl.renderer.domElement) } }, { key: "getPlaneSize", get: function () { return this.fovRadians = this.gl.camera.fov * Math.PI / 180, this.viewSize = Math.abs(this.gl.camera.position.z * Math.tan(this.fovRadians / 2) * 2), [this.viewSize, this.viewSize] } }]), t }() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function () { if (screen.width > 330) { var t, e, n, i = new SmallPRNG, r = new Perlin, o = document.getElementById("container"), s = o.getContext("2d"), a = new MouseMonitor(o), c = screen.width, l = 0, u = [], h = new Vector3D(0, 0, 0), d = { particleNum: c > 460 ? 2e3 : 300 }; r.init((function () { return i.random(0, 255) })), (t = function () { o.width = e = h.x = window.innerWidth, o.height = n = h.y = window.innerHeight, s.fillStyle = "#ffffff", s.fillRect(0, 0, e, n) })(), window.addEventListener("resize", t); for (var f = 0; f < d.particleNum; f += 1)u.push(new Particle(r, h, i, a)); !function t() { requestAnimFrame(t), s.beginPath(); for (var i = 0; i < u.length; i += 1)u[i].step(), u[i].render(s); s.globalCompositeOperation = "source-over", s.fillStyle = "#131116", s.fillRect(0, 0, e, n), s.globalCompositeOperation = "lighter", s.strokeStyle = "#a03adb", s.stroke(), s.closePath(), l = (l + .5) % 360 }() } } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.splitLines = e.navLinksDetect = e.langCurrentPage = e.TextSplit = void 0; var i, r = n(10), o = (i = r) && i.__esModule ? i : { default: i }; e.TextSplit = function (t, e) { var n = !0, i = !1, r = void 0; try { for (var s, a = t[Symbol.iterator](); !(n = (s = a.next()).done); n = !0) { var c = s.value; (0, o.default)({ target: c, by: e }) } } catch (t) { i = !0, r = t } finally { try { !n && a.return && a.return() } finally { if (i) throw r } } }, e.langCurrentPage = function () { var t = document.querySelector(".lang"), e = /\/ru/gi, n = void 0; switch (document.documentElement.lang) { case "ru": n = location.pathname.replace(e, ""), t.setAttribute("href", ".." + n), t.setAttribute("hreflang", "ua"), t.innerText = "UA"; break; case "uk": n = location.pathname.replace(e, ""), t.setAttribute("href", "./ru" + n), t.setAttribute("hreflang", "ru"), t.innerText = "EU" } }, e.navLinksDetect = function () { var t = document.querySelectorAll("nav a"), e = !0, n = !1, i = void 0; try { for (var r, o = t[Symbol.iterator](); !(e = (r = o.next()).done); e = !0) { var s = r.value; s.classList.remove("active"), s.href === location.href && s.classList.add("active") } } catch (t) { n = !0, i = t } finally { try { !e && o.return && o.return() } finally { if (n) throw i } } }, e.splitLines = function (t) { var e = function () { for (var e = [], n = void 0, i = t.querySelectorAll(".word"), r = void 0, o = 0; o < i.length; o++) { var s = i[o]; s.offsetTop !== r && (r = s.offsetTop, n = [], e.push(n)), n.push(s) } return e }().map((function (t) { return t.map((function (t) { return t.innerText })).join(" ") })); t.innerHTML = ""; for (var n = 0; n < e.length; n++) { var i = e[n].toLowerCase(); t.innerHTML += '<span class="splitter">' + i + "</span>" } } }, function (t, e, n) { t.exports = function () { "use strict"; var t = document, e = t.createTextNode.bind(t); function n(t, e, n) { t.style.setProperty(e, n) } function i(t, e) { return t.appendChild(e) } function r(e, n, r, o) { var s = t.createElement("span"); return n && (s.className = n), r && (!o && s.setAttribute("data-" + n, r), s.textContent = r), e && i(e, s) || s } function o(t, e) { return t.getAttribute("data-" + e) } function s(e, n) { return e && 0 != e.length ? e.nodeName ? [e] : [].slice.call(e[0].nodeName ? e : (n || t).querySelectorAll(e)) : [] } function a(t) { for (var e = []; t--;)e[t] = []; return e } function c(t, e) { t && t.some(e) } function l(t) { return function (e) { return t[e] } } var u = {}; function h(t, e, n, i) { return { by: t, depends: e, key: n, split: i } } function d(t) { return function t(e, n, i) { var r = i.indexOf(e); if (-1 == r) i.unshift(e), c(u[e].depends, (function (n) { t(n, e, i) })); else { var o = i.indexOf(n); i.splice(r, 1), i.splice(o, 0, e) } return i }(t, 0, []).map(l(u)) } function f(t) { u[t.by] = t } function p(t, n, o, a, l) { t.normalize(); var u = [], h = document.createDocumentFragment(); a && u.push(t.previousSibling); var d = []; return s(t.childNodes).some((function (t) { if (!t.tagName || t.hasChildNodes()) { if (t.childNodes && t.childNodes.length) return d.push(t), void u.push.apply(u, p(t, n, o, a, l)); var i = t.wholeText || "", s = i.trim(); s.length && (" " === i[0] && d.push(e(" ")), c(s.split(o), (function (t, e) { e && l && d.push(r(h, "whitespace", " ", l)); var i = r(h, n, t); u.push(i), d.push(i) })), " " === i[i.length - 1] && d.push(e(" "))) } else d.push(t) })), c(d, (function (t) { i(h, t) })), t.innerHTML = "", i(t, h), u } var m = h("words", 0, "word", (function (t) { return p(t, "word", /\s+/, 0, 1) })), g = "chars", v = h(g, ["words"], "char", (function (t, e, n) { var i = []; return c(n.words, (function (t, n) { i.push.apply(i, p(t, "char", "", e.whitespace && n)) })), i })); function y(t) { var e = (t = t || {}).key; return s(t.target || "[data-splitting]").map((function (i) { var r = i["🍌"]; if (!t.force && r) return r; r = i["🍌"] = { el: i }; var s = d(t.by || o(i, "splitting") || g), a = function (t, e) { for (var n in e) t[n] = e[n]; return t }({}, t); return c(s, (function (t) { if (t.split) { var o = t.by, s = (e ? "-" + e : "") + t.key, l = t.split(i, a, r); s && function (t, e, i) { var r = "--" + e, o = r + "-index"; c(i, (function (t, e) { Array.isArray(t) ? c(t, (function (t) { n(t, o, e) })) : n(t, o, e) })), n(t, r + "-total", i.length) }(i, s, l), r[o] = l, i.classList.add(o) } })), i.classList.add("splitting"), r })) } function _(t, e, n) { var i = s(e.matching || t.children, t), r = {}; return c(i, (function (t) { var e = Math.round(t[n]); (r[e] || (r[e] = [])).push(t) })), Object.keys(r).map(Number).sort(x).map(l(r)) } function x(t, e) { return t - e } y.html = function (t) { var e = (t = t || {}).target = r(); return e.innerHTML = t.content, y(t), e.outerHTML }, y.add = f; var b = h("lines", ["words"], "line", (function (t, e, n) { return _(t, { matching: n.words }, "offsetTop") })), w = h("items", 0, "item", (function (t, e) { return s(e.matching || t.children, t) })), M = h("rows", 0, "row", (function (t, e) { return _(t, e, "offsetTop") })), T = h("cols", 0, "col", (function (t, e) { return _(t, e, "offsetLeft") })), S = h("grid", ["rows", "cols"]), E = h("layout", 0, 0, (function (t, e) { var a = e.rows = +(e.rows || o(t, "rows") || 1), c = e.columns = +(e.columns || o(t, "columns") || 1); if (e.image = e.image || o(t, "image") || t.currentSrc || t.src, e.image) { var l = s("img", t)[0]; e.image = l && (l.currentSrc || l.src) } e.image && n(t, "background-image", "url(" + e.image + ")"); for (var u = a * c, h = [], d = r(0, "cell-grid"); u--;) { var f = r(d, "cell"); r(f, "cell-inner"), h.push(f) } return i(t, d), h })), A = h("cellRows", ["layout"], "row", (function (t, e, n) { var i = e.rows, r = a(i); return c(n.layout, (function (t, e, n) { r[Math.floor(e / (n.length / i))].push(t) })), r })), P = h("cellColumns", ["layout"], "col", (function (t, e, n) { var i = e.columns, r = a(i); return c(n.layout, (function (t, e) { r[e % i].push(t) })), r })), L = h("cells", ["cellRows", "cellColumns"], "cell", (function (t, e, n) { return n.layout })); return f(m), f(v), f(b), f(w), f(M), f(T), f(S), f(E), f(A), f(P), f(L), y }() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.cb = e || function () { } } return i(t, [{ key: "init", value: function () { this.cb(), this.resizeHandler = this.resizeHandler.bind(this), window.addEventListener("resize", this.resizeHandler) } }, { key: "resizeHandler", value: function () { this.cb() } }, { key: "destroy", value: function () { window.removeEventListener("resize", this.resizeHandler), this.cb = function () { } } }]), t }(); e.default = r }, function (t, e, n) { "use strict"; function i() { document.querySelector("#yes"); !function (t) { var e = function (t, e, n) { this.set(t, e, n) }, n = e.prototype; n.dot2d = function (t, e) { return this.x * t + this.y * e }, n.dot3d = function (t, e, n) { return this.x * t + this.y * e + this.z * n }, n.set = function (t, e, n) { return this.x = t, this.y = e, this.z = n, this }, n.add = function (t) { return "number" == typeof t ? (this.x += t, this.y += t, this.z += t, this) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, n.sub = function (t) { return "number" == typeof t ? (this.x -= t, this.y -= t, this.z -= t, this) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, n.mul = function (t) { return "number" == typeof t ? (this.x *= t, this.y *= t, this.z *= t, this) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, n.div = function (t) { return "number" == typeof t ? (this.x /= t, this.y /= t, this.z /= t, this) : (this.x /= t.x, this.y /= t.y, this.z /= t.z, this) }, n.move = function (t) { return t instanceof e && (t.x = this.x, t.y = this.y, t.z = this.z), this }, n.within2d = function (t) { return this.x >= 0 && this.x < t.x && this.y >= 0 && this.y < t.y }, n.wrap2d = function (t) { return this.x > t.x ? (this.x = 0, !0) : this.x < 0 ? (this.x = t.x, !0) : this.y > t.y ? (this.y = 0, !0) : this.y < 0 ? (this.y = t.y, !0) : void 0 }, n.eq = function (t) { return t instanceof e && this.x === t.x && this.y === t.y && this.z === t.z }, n.distance = function (t) { var e = this.x - t.x, n = this.y - t.y; return Math.sqrt(e * e + n * n) }, n.clone = function () { return new e(this.x, this.y, this.z) }, t.Vector3D = e }(window), function (t) { var e = function () { this.grad3 = [new Vector3D(1, 1, 0), new Vector3D(-1, 1, 0), new Vector3D(1, -1, 0), new Vector3D(-1, -1, 0), new Vector3D(1, 0, 1), new Vector3D(-1, 0, 1), new Vector3D(1, 0, -1), new Vector3D(-1, 0, -1), new Vector3D(0, 1, 1), new Vector3D(0, -1, 1), new Vector3D(0, 1, -1), new Vector3D(0, -1, -1)], this.p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], this.permutation = new Array(512), this.gradP = new Array(512), this.F2 = .5 * (Math.sqrt(3) - 1), this.G2 = (3 - Math.sqrt(3)) / 6, this.F3 = 1 / 3, this.G3 = 1 / 6 }, n = e.prototype; n.init = function (t) { if ("function" != typeof t) throw new TypeError("prng needs to be a function returning an int between 0 and 255"); for (var e = 0; e < 256; e += 1) { var n = this.p[e] ^ t(); this.permutation[e] = this.permutation[e + 256] = n, this.gradP[e] = this.gradP[e + 256] = this.grad3[n % this.grad3.length] } }, n.simplex3d = function (t, e, n) { var i, r, o, s, a, c, l, u, h, d, f, p, m, g, v, y, _, x, b, w, M, T, S, E = (t + e + n) * this.F3, A = Math.floor(t + E), P = Math.floor(e + E), L = Math.floor(n + E), R = (A + P + L) * this.G3, O = t - A + R, C = e - P + R, I = n - L + R; return O >= C ? C >= I ? (i = 1, r = 0, o = 0, s = 1, a = 1, c = 0) : O >= I ? (i = 1, r = 0, o = 0, s = 1, a = 0, c = 1) : (i = 0, r = 0, o = 1, s = 1, a = 0, c = 1) : C < I ? (i = 0, r = 0, o = 1, s = 0, a = 1, c = 1) : O < I ? (i = 0, r = 1, o = 0, s = 0, a = 1, c = 1) : (i = 0, r = 1, o = 0, s = 1, a = 1, c = 0), l = O - i + this.G3, u = C - r + this.G3, h = I - o + this.G3, d = O - s + 2 * this.G3, f = C - a + 2 * this.G3, p = I - c + 2 * this.G3, m = O - 1 + 3 * this.G3, g = C - 1 + 3 * this.G3, v = I - 1 + 3 * this.G3, A &= 255, P &= 255, L &= 255, y = this.gradP[A + this.permutation[P + this.permutation[L]]], _ = this.gradP[A + i + this.permutation[P + r + this.permutation[L + o]]], x = this.gradP[A + s + this.permutation[P + a + this.permutation[L + c]]], b = this.gradP[A + 1 + this.permutation[P + 1 + this.permutation[L + 1]]], M = .6 - l * l - u * u - h * h, T = .6 - d * d - f * f - p * p, S = .6 - m * m - g * g - v * v, 32 * (((w = .6 - O * O - C * C - I * I) < 0 ? 0 : (w *= w) * w * y.dot3d(O, C, I)) + (M < 0 ? 0 : (M *= M) * M * _.dot3d(l, u, h)) + (T < 0 ? 0 : (T *= T) * T * x.dot3d(d, f, p)) + (S < 0 ? 0 : (S *= S) * S * b.dot3d(m, g, v))) }, t.Perlin = e }(window), window.MouseMonitor = function (t) { this.position = new Vector3D(0, 0, 0), this.state = { left: !1, middle: !1, right: !1 }, this.element = t; var e = this; t.addEventListener("mousemove", (function (t) { var n, i, r; null == (t = t || window.event).pageX && null != t.clientX && (i = (n = t.target && t.target.ownerDocument || document).documentElement, r = n.body, t.pageX = t.clientX + (i && i.scrollLeft || r && r.scrollLeft || 0) - (i && i.clientLeft || r && r.clientLeft || 0), t.pageY = t.clientY + (i && i.scrollTop || r && r.scrollTop || 0) - (i && i.clientTop || r && r.clientTop || 0)), e.position.x = t.pageX, e.position.y = t.pageY })) }, function (t) { var e = function (t, e, n, i) { this.p = new Vector3D, this.t = new Vector3D, this.v = new Vector3D, this.g = t, this.b = e, this.r = n, this.m = i, this.reset() }, n = e.prototype; n.reset = function () { this.p.x = this.t.x = Math.floor(this.r.random() * this.b.x), this.p.y = this.t.y = Math.floor(this.r.random() * this.b.y), this.v.set(1, 1, 0), this.i = 0, this.l = this.r.random(1e3, 1e4) }, n.step = function () { this.i++ > this.l && this.reset(); var t = this.p.x / 200, e = this.p.y / 200, n = Date.now() / 5e3, i = this.r.random() * Math.Tau, r = this.r.random() / 4; if (this.v.x += r * Math.sin(i) + this.g.simplex3d(t, e, -n) / 1.5, this.v.y += r * Math.cos(i) + this.g.simplex3d(t, e, n) / 1.5, this.m.state.left && this.v.add(this.m.position.clone().sub(this.p).mul(85e-5)), this.m.state.right && this.p.distance(this.m.position) < this.r.random(200, 250) && this.v.add(this.p.clone().sub(this.m.position).mul(.02)), this.m.state.middle) { var o = this.p.distance(this.m.position), s = this.r.random(200, 250); o < s && this.v.mul(o / s) } this.p.move(this.t).add(this.v.mul(.94)), this.p.wrap2d(this.b) && this.p.move(this.t) }, n.render = function (t) { t.moveTo(this.t.x, this.t.y), t.lineTo(this.p.x, this.p.y) }, t.Particle = e }(window) } Object.defineProperty(e, "__esModule", { value: !0 }), e.default = i, n(4), n(5), i() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t) { var e = this; this.endThreshold = .05, this.requestId = null, this.maxDepth = 10, this.viewHeight = 0, this.halfViewHeight = 0, this.maxDistance = 0, this.scrollHeight = 0, this.endScroll = 0, this.currentScroll = 0, this.resizeRequest = 1, this.scrollRequest = 0, this.scrollItems = [], this.lastTime = -1, this.maxElapsedMS = 100, this.targetFPMS = .06, this._onResize = function () { e.resizeRequest++, e.requestId || (e.lastTime = performance.now(), e.requestId = requestAnimationFrame(e._update)) }, this._onScroll = function () { e.scrollRequest++, e.requestId || (e.lastTime = performance.now(), e.requestId = requestAnimationFrame(e._update)) }, this._update = function (t) { void 0 === t && (t = performance.now()); var n = t - e.lastTime; n > e.maxElapsedMS && (n = e.maxElapsedMS); var i = n * e.targetFPMS, r = 1 - Math.pow(1 - e.scrollEase, i), o = e.resizeRequest > 0, s = window.pageYOffset; if (o) { var a = e.target.clientHeight; document.body.style.height = a + "px", e.scrollHeight = a, e.viewHeight = window.innerHeight, e.halfViewHeight = e.viewHeight / 2, e.maxDistance = 2 * e.viewHeight, e.resizeRequest = 0 } e.endScroll = s, e.currentScroll += (s - e.currentScroll) * r, (Math.abs(s - e.currentScroll) < e.endThreshold || o) && (e.currentScroll = s, e.scrollRequest = 0); var c = e.currentScroll + e.halfViewHeight; e.target.style.transform = "translate3d(0px,-" + e.currentScroll + "px,0px)"; for (var l = 0; l < e.scrollItems.length; l++) { var u = e.scrollItems[l], h = (c - u.top) / e.maxDistance; u.endOffset = Math.round(e.maxOffset * u.depthRatio * h), Math.abs(u.endOffset - u.currentOffset < e.endThreshold) ? u.currentOffset = u.endOffset : u.currentOffset += (u.endOffset - u.currentOffset) * r, u.target.style.transform = "translate3d(0px,-" + u.currentOffset + "px,0px)" } e.lastTime = t, e.requestId = e.scrollRequest > 0 ? requestAnimationFrame(e._update) : null }, this.target = t.target, this.scrollEase = null != t.scrollEase ? t.scrollEase : .1, this.maxOffset = null != t.maxOffset ? t.maxOffset : 500, this.addItems(), window.addEventListener("resize", this._onResize), window.addEventListener("scroll", this._onScroll), this._update() } return t.prototype.addItems = function () { this.scrollItems = []; for (var t = document.querySelectorAll("*[data-depth]"), e = 0; e < t.length; e++) { var n = t[e], i = +n.getAttribute("data-depth"), r = n.getBoundingClientRect(), o = { target: n, depth: i, top: r.top + window.pageYOffset, depthRatio: i / this.maxDepth, currentOffset: 0, endOffset: 0 }; this.scrollItems.push(o) } return this }, t }(); e.default = i }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1); var o = n(6), s = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.h1 = document.querySelector("h1"), this.h3 = document.querySelectorAll("h3"), this.p = document.querySelector(".contacts-wrapper"), o(this.h1), this.h1Span = this.h1.querySelectorAll("span"), this.tl = new r.TimelineMax, this.load() } return i(t, [{ key: "load", value: function () { this.h1.style.opacity = "1", this.tl.to(this.h1, .1, { opacity: 1 }, .1).staggerTo(this.h1Span, 1, { opacity: 1, y: 0, ease: r.Power2.easeOut }, .07).to(this.p, 1, { opacity: 1, ease: r.Power2.easeInOut }, .5) } }]), t }(); e.default = s }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function (t, e) { var n = new Date, i = new Date(n.getUTCFullYear(), n.getUTCMonth(), n.getUTCDate(), n.getUTCHours() + 2, n.getUTCMinutes(), n.getUTCSeconds()), r = new Array(7); r[0] = "вс", r[1] = "пн", r[2] = "вт", r[3] = "ср", r[4] = "чт", r[5] = "пт", r[6] = "сб"; var o = new Date(i), s = { dWeek: r[n.getDay()], hours: ("0" + o.getHours()).substr(-2), minutes: ("0" + o.getMinutes()).substr(-2), seconds: ("0" + o.getSeconds()).substr(-2) }; if ("contacts" === document.querySelector("[data-router-view]").getAttribute("data-router-view")) return e.innerHTML = 14 == +s.hours && "вс" !== s.dWeek ? e.getAttribute("data-lunch") : +s.hours > 18 || "вс" === s.dWeek || +s.hours < 9 ? e.getAttribute("data-rest") : e.getAttribute("data-work"), t.innerHTML = s.dWeek + ", " + s.hours + ":" + s.minutes } }, function (t, e, n) { "use strict"; var i = _(n(2)), r = _(n(17)), o = _(n(20)), s = n(9), a = _(n(21)), c = _(n(24)), l = _(n(11)), u = _(n(25)), h = _(n(38)), d = _(n(42)), f = _(n(44)), p = _(n(46)), m = _(n(49)), g = _(n(51)), v = _(n(54)), y = _(n(56)); function _(t) { return t && t.__esModule ? t : { default: t } } n(57), n(58), n(59), n(60), n(61), n(62); var x = new l.default((function () { var t = .01 * window.innerHeight; document.body.style.setProperty("--vh", t + "px") })), b = new i.default.Core({ renderers: { main: h.default, portfolio: u.default, services: d.default, portfolioitem: p.default, servicesItem: f.default, about: m.default, faq: g.default, contacts: v.default, errorpage: y.default }, transitions: { default: r.default, contextual: { distort: o.default } } }); b.on("NAVIGATE_IN", (function () { (0, s.navLinksDetect)(), (0, s.langCurrentPage)() })), b.on("NAVIGATE_END", (function (t) { t.from, t.to, t.location; x.init(), "about" === document.querySelector("[data-router-view]").getAttribute("data-router-view") && "faq" === document.querySelector("[data-router-view]").getAttribute("data-router-view") && "portfolio" === document.querySelector("[data-router-view]").getAttribute("data-router-view") || (0, a.default)(), window.scrollTo(0, 0), new c.default, "main" !== document.querySelector("[data-router-view]").getAttribute("data-router-view") && (document.querySelector(".logo").style.width = document.querySelector("#emotion-e").getBoundingClientRect().width + "px") })), window.addEventListener("load", (function () { x.init(), "about" === document.querySelector("[data-router-view]").getAttribute("data-router-view") && "faq" === document.querySelector("[data-router-view]").getAttribute("data-router-view") && "portfolio" === document.querySelector("[data-router-view]").getAttribute("data-router-view") || ((0, a.default)(), new c.default, (0, s.navLinksDetect)(), (0, s.langCurrentPage)()) })) }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i, r = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), o = n(1), s = n(2); var a = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), r(e, [{ key: "out", value: function (t) { var e = t.from, n = (t.trigger, t.done); new o.TimelineMax({ onComplete: n }).to(e, .4, { opacity: 0, ease: Power3.easeInOut }) } }, { key: "in", value: function (t) { var e = t.from, n = t.to, i = (t.trigger, t.done); e.remove(), window.scrollTo(0, 0), new o.TimelineMax({ onComplete: i }).fromTo(n, .4, { opacity: 0 }, { opacity: 1, ease: Power3.easeInOut }) } }]), e }(((i = s) && i.__esModule ? i : { default: i }).default.Transition); e.default = a }, function (t, e) { t.exports = function (t) { if (!t.webpackPolyfill) { var e = Object.create(t); e.children || (e.children = []), Object.defineProperty(e, "loaded", { enumerable: !0, get: function () { return e.l } }), Object.defineProperty(e, "id", { enumerable: !0, get: function () { return e.i } }), Object.defineProperty(e, "exports", { enumerable: !0 }), e.webpackPolyfill = 1 } return e } }, function (t, e) { var n; n = function () { return this }(); try { n = n || new Function("return this")() } catch (t) { "object" == typeof window && (n = window) } t.exports = n }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i, r = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), o = n(2); var s = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), r(e, [{ key: "out", value: function (t) { var e = t.done; setTimeout((function () { e() }), 2e3) } }, { key: "in", value: function (t) { var e = t.from, n = t.to, i = t.done; window.scrollTo(0, 0); var r = e.querySelector("#app"), o = document.querySelector(".js-clonned"); n.querySelector(".case-wrapper").appendChild(r), n.querySelector(".case-wrapper").appendChild(o), o.style.position = "absolute", document.querySelector(".portfolio-item-h1").style.display = "none", e.remove(), i() } }]), e }(((i = o) && i.__esModule ? i : { default: i }).default.Transition); e.default = s }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function () { var t = document.querySelectorAll(".input-wrapper input"), e = document.querySelector("form"), n = document.getElementById("phone"), s = document.querySelector(".input-checkbox"), a = document.querySelector(".form-validate-text"), c = document.querySelector(".form .button"), l = document.querySelector(".thank-you-screen .button"), u = document.querySelector(".button.pop-up"), h = document.querySelector(".form-pop-up"), d = document.querySelector(".close-pop-up"), f = document.querySelector(".thank-you-screen"), p = document.querySelector(".thank-you-bg"), m = document.querySelector(".thank-you-bg-white"), g = document.querySelector(".thank-you-content"), v = document.querySelectorAll("label")[2]; if ((0, r.default)(), e) { var y = function () { this.classList.add("focus"), document.body.classList.add("form-focused") }, _ = function () { "" === this.value && (this.classList.remove("focus"), document.body.classList.remove("form-focused")) }; if (h) { u.addEventListener("click", (function () { h.style.opacity = "1", h.style.pointerEvents = "auto" })), d.addEventListener("click", (function () { h.style.opacity = "0", h.style.pointerEvents = "none" })) } for (var x = 0; x < t.length; x++)t[x].addEventListener("focus", y); for (var b = 0; b < t.length; b++)t[b].addEventListener("blur", _); document.body.onclick = function () { a.style.opacity = "0", v.classList = "label" }, n.oninput = function () { a.style.opacity = "0", v.pseudoStyle().classList = "label" }, e.onsubmit = function (r) { if ("" === n.value) return a.innerHTML = "ru" === document.documentElement.lang ? "поле не может быть пустым" : "поле не може бути порожнім", a.style.opacity = "1", r.preventDefault(), n.focus(), document.querySelectorAll("label")[2].pseudoStyle("after", "border-color", "#F44336!important"), !1; if (n.value.length <= 5 || null === n.value) return a.innerHTML = "ru" === document.documentElement.lang ? "не меньше 6 символов" : "не менше 6 символів", a.style.opacity = "1", r.preventDefault(), n.focus(), document.querySelectorAll("label")[2].pseudoStyle("after", "border-color", "#F44336!important"), !1; if (n.value.match(/^\d[\d\(\)\ -]{4,14}\d$/)) { a.style.opacity = "0"; var s = new XMLHttpRequest; s.open("POST", "./mail.php", !0), s.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"); var c = (0, i.default)(e); return s.onload = function () { this.status >= 200 && this.status < 400 && setTimeout((function () { (new o.TimelineMax).to(f, .01, { display: "flex", ease: o.Power1.easeInOut }).to(m, 1, { opacity: .8, ease: o.Power1.easeInOut }).fromTo(p, 1.5, { y: "100%" }, { y: "0%", ease: o.Power1.easeInOut }, .2).to(g, 1, { opacity: 1, ease: o.Power1.easeInOut }, .8), e.reset(), window.dataLayer.push({ event: "otpravka_form" }), document.body.classList.remove("form-focused"); for (var n = 0; n < t.length; n++)t[n].classList.remove("focus"); h && (h.style.opacity = "0", h.style.pointerEvents = "none") }), 1e3) }, s.send(c), !1 } return a.innerHTML = "ru" === document.documentElement.lang ? "должны быть только цифры" : "повинні бути тільки цифри", a.style.opacity = "1", r.preventDefault(), n.focus(), document.querySelectorAll("label")[2].pseudoStyle("after", "border-color", "#F44336!important"), !1 }, s.onchange = function () { c.style.transition = "opacity .3s ease", s.checked ? (c.style.pointerEvents = "auto", c.style.opacity = "1") : (c.style.pointerEvents = "none", c.style.opacity = "0.7") }, l.onclick = function () { (new o.TimelineMax).to(g, 1, { opacity: 0, ease: o.Power1.easeInOut }).to(p, 1.5, { y: "-100%", ease: o.Power1.easeInOut }, .5).to(m, 1, { opacity: 0, ease: o.Power1.easeInOut }, 1).to(f, .01, { display: "none", ease: o.Power1.easeInOut }) } } }; var i = s(n(22)), r = s(n(23)), o = n(1); function s(t) { return t && t.__esModule ? t : { default: t } } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = function (t) { for (var e = [], n = 0; n < t.elements.length; n++) { var i = t.elements[n]; if (i.name && !i.disabled && "file" !== i.type && "reset" !== i.type && "submit" !== i.type && "button" !== i.type) if ("select-multiple" === i.type) for (var r = 0; r < i.options.length; r++)i.options[r].selected && e.push(encodeURIComponent(i.name) + "=" + encodeURIComponent(i.options[r].value)); else ("checkbox" !== i.type && "radio" !== i.type || i.checked) && e.push(encodeURIComponent(i.name) + "=" + encodeURIComponent(i.value)) } return e.join("&") } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function () { HTMLElement.prototype.pseudoStyle = function (t, e, n) { var i = document.head || document.getElementsByTagName("head")[0], r = document.getElementById("pseudoStyles") || document.createElement("style"); r.id = "pseudoStyles"; return this.className += " pseudoStyle", r.innerHTML += "\n.pseudoStyle:" + t + "{" + e + ":" + n + "}", i.appendChild(r), this } } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.landscapeItems = [document.querySelector(".phone"), document.querySelector(".message"), document.querySelector(".for-landscape")], this.input = document.querySelectorAll(".input-wrapper input"), this.render(), window.addEventListener("resize", this.render.bind(this)) } return i(t, [{ key: "render", value: function () { var t = this; screen.width < 813 && window.innerHeight < window.innerWidth && !document.body.classList.contains("form-focused") ? this.landscapeItems.forEach((function (e) { return t.show(e) })) : this.landscapeItems.forEach((function (e) { return t.hide(e) })) } }, { key: "show", value: function (t) { t.classList.add("landscape-true") } }, { key: "hide", value: function (t) { t.classList.remove("landscape-true") } }]), t }(); e.default = r }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = c(n(2)), o = c(n(26)), s = c(n(3)), a = n(27); function c(t) { return t && t.__esModule ? t : { default: t } } var l = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnter", value: function () { var t = document.querySelector(".line-loader"), e = document.querySelector(".loader"); t.style.opacity = "1", e.style.opacity = "1", e.style.pointerEvents = "auto", e.style.zIndex = "100" } }, { key: "onLeave", value: function () { var t = document.querySelector(".line-loader"), e = document.querySelector(".loader"); t.style.opacity = "0", e.style.opacity = "0", e.style.pointerEvents = "none", e.style.zIndex = "10000", this.distort.scrollDestroy() } }, { key: "onLeaveCompleted", value: function () { var t = this, e = this.wrap; setTimeout((function () { "portfolioitem" !== e.querySelector("[data-router-view]").getAttribute("data-router-view") && t.distort.distortDestroy() }), 200) } }, { key: "onEnterCompleted", value: function () { (0, s.default)(); var t = document.querySelector(".line-loader"), e = document.querySelector(".loader"); t.style.opacity = "0", e.style.opacity = "0", e.style.pointerEvents = "none", e.style.zIndex = "10000", this.distort = (0, a.scrollDistortion)(), this.distort.distortLoaded((function () { new o.default })), window.addEventListener("load", (function () { document.body.style.position = "fixed", document.querySelector(".loader").style.opacity = "0", document.querySelector(".loader").style.pointerEvents = "none" })), "10000" === document.querySelector(".loader").style.zIndex && (document.body.style.position = "fixed") } }]), e }(r.default.Renderer); e.default = l }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1); var o = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.$canvas = document.querySelector("#app"), this.$headers = document.querySelectorAll(".js-h2-span"), this.$scroller = document.querySelectorAll(".scroll-progress"), this.load() } return i(t, [{ key: "load", value: function () { this.tl = new r.TimelineMax, this.tl.staggerTo(this.$headers, 1, { y: 0, ease: r.Power4.easeOut }, .2, .6).fromTo(this.$canvas, 1, { opacity: 0 }, { opacity: 1, ease: r.Power1.easeOut }, .9).fromTo(this.$scroller, 1, { opacity: 0 }, { opacity: 1, ease: r.Power1.easeOut }, .9) } }]), t }(); e.default = o }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.scrollDistortion = void 0; var i = n(1), r = n(7), o = n(34); e.scrollDistortion = function () { var t = [].concat(function (t) { if (Array.isArray(t)) { for (var e = 0, n = Array(t.length); e < t.length; e++)n[e] = t[e]; return n } return Array.from(t) }(document.querySelectorAll(".js-item"))), e = document.querySelector(".js-scroller"), n = document.querySelector(".js-wrapper"), s = document.querySelector(".js-scroll-thumb"), a = t.map((function (t) { return t.getAttribute("data-img") })), c = new r.Distortion("#app", { fullScreen: !1, textures: a }), l = new o.MouseScroll(t, e, n); return l.onUpdate = function () { var t = -100 - l.handlers.distance + 100 * l.ofssetPercent + "%"; i.TweenMax.to(s, .5, { y: t }) }, l.onScroll = function () { c.changeTexture(-l.handlers.distance / l.handlers.step) }, { scrollDestroy: function () { return l.destroy() }, distortDestroy: function () { return c.destroy() }, distortLoaded: function (t) { return c.textureDidLoaded = function () { t() } } } } }, function (t, e, n) { "use strict"; n.r(e), n.d(e, "ACESFilmicToneMapping", (function () { return nt })), n.d(e, "AddEquation", (function () { return S })), n.d(e, "AddOperation", (function () { return Q })), n.d(e, "AdditiveAnimationBlendMode", (function () { return qe })), n.d(e, "AdditiveBlending", (function () { return b })), n.d(e, "AlphaFormat", (function () { return kt })), n.d(e, "AlwaysDepth", (function () { return G })), n.d(e, "AlwaysStencilFunc", (function () { return Tn })), n.d(e, "AmbientLight", (function () { return Sh })), n.d(e, "AmbientLightProbe", (function () { return Yh })), n.d(e, "AnimationClip", (function () { return Cu })), n.d(e, "AnimationLoader", (function () { return Uu })), n.d(e, "AnimationMixer", (function () { return Td })), n.d(e, "AnimationObjectGroup", (function () { return wd })), n.d(e, "AnimationUtils", (function () { return _u })), n.d(e, "ArcCurve", (function () { return Yu })), n.d(e, "ArrayCamera", (function () { return Ba })), n.d(e, "ArrowHelper", (function () { return ff })), n.d(e, "Audio", (function () { return rd })), n.d(e, "AudioAnalyser", (function () { return ud })), n.d(e, "AudioContext", (function () { return Wh })), n.d(e, "AudioListener", (function () { return id })), n.d(e, "AudioLoader", (function () { return qh })), n.d(e, "AxesHelper", (function () { return pf })), n.d(e, "AxisHelper", (function () { return dp })), n.d(e, "BackSide", (function () { return m })), n.d(e, "BasicDepthPacking", (function () { return on })), n.d(e, "BasicShadowMap", (function () { return u })), n.d(e, "BinaryTextureLoader", (function () { return vp })), n.d(e, "Bone", (function () { return yc })), n.d(e, "BooleanKeyframeTrack", (function () { return Su })), n.d(e, "BoundingBoxHelper", (function () { return fp })), n.d(e, "Box2", (function () { return Id })), n.d(e, "Box3", (function () { return Bi })), n.d(e, "Box3Helper", (function () { return cf })), n.d(e, "BoxBufferGeometry", (function () { return go })), n.d(e, "BoxGeometry", (function () { return mo })), n.d(e, "BoxHelper", (function () { return af })), n.d(e, "BufferAttribute", (function () { return Mr })), n.d(e, "BufferGeometry", (function () { return Gr })), n.d(e, "BufferGeometryLoader", (function () { return Ih })), n.d(e, "ByteType", (function () { return St })), n.d(e, "Cache", (function () { return Du })), n.d(e, "Camera", (function () { return Mo })), n.d(e, "CameraHelper", (function () { return rf })), n.d(e, "CanvasRenderer", (function () { return xp })), n.d(e, "CanvasTexture", (function () { return Vc })), n.d(e, "CatmullRomCurve3", (function () { return th })), n.d(e, "CineonToneMapping", (function () { return et })), n.d(e, "CircleBufferGeometry", (function () { return su })), n.d(e, "CircleGeometry", (function () { return ou })), n.d(e, "ClampToEdgeWrapping", (function () { return dt })), n.d(e, "Clock", (function () { return $h })), n.d(e, "ClosedSplineCurve3", (function () { return lp })), n.d(e, "Color", (function () { return fr })), n.d(e, "ColorKeyframeTrack", (function () { return Eu })), n.d(e, "CompressedTexture", (function () { return jc })), n.d(e, "CompressedTextureLoader", (function () { return Hu })), n.d(e, "ConeBufferGeometry", (function () { return ru })), n.d(e, "ConeGeometry", (function () { return iu })), n.d(e, "CubeCamera", (function () { return Ao })), n.d(e, "CubeGeometry", (function () { return mo })), n.d(e, "CubeReflectionMapping", (function () { return ot })), n.d(e, "CubeRefractionMapping", (function () { return st })), n.d(e, "CubeTexture", (function () { return Ko })), n.d(e, "CubeTextureLoader", (function () { return Vu })), n.d(e, "CubeUVReflectionMapping", (function () { return lt })), n.d(e, "CubeUVRefractionMapping", (function () { return ut })), n.d(e, "CubicBezierCurve", (function () { return rh })), n.d(e, "CubicBezierCurve3", (function () { return oh })), n.d(e, "CubicInterpolant", (function () { return bu })), n.d(e, "CullFaceBack", (function () { return a })), n.d(e, "CullFaceFront", (function () { return c })), n.d(e, "CullFaceFrontBack", (function () { return l })), n.d(e, "CullFaceNone", (function () { return s })), n.d(e, "Curve", (function () { return qu })), n.d(e, "CurvePath", (function () { return dh })), n.d(e, "CustomBlending", (function () { return T })), n.d(e, "CustomToneMapping", (function () { return it })), n.d(e, "CylinderBufferGeometry", (function () { return nu })), n.d(e, "CylinderGeometry", (function () { return eu })), n.d(e, "Cylindrical", (function () { return Od })), n.d(e, "DataTexture", (function () { return Lo })), n.d(e, "DataTexture2DArray", (function () { return ts })), n.d(e, "DataTexture3D", (function () { return es })), n.d(e, "DataTextureLoader", (function () { return Gu })), n.d(e, "DecrementStencilOp", (function () { return fn })), n.d(e, "DecrementWrapStencilOp", (function () { return mn })), n.d(e, "DefaultLoadingManager", (function () { return ku })), n.d(e, "DepthFormat", (function () { return Gt })), n.d(e, "DepthStencilFormat", (function () { return jt })), n.d(e, "DepthTexture", (function () { return Wc })), n.d(e, "DirectionalLight", (function () { return Th })), n.d(e, "DirectionalLightHelper", (function () { return tf })), n.d(e, "DirectionalLightShadow", (function () { return Mh })), n.d(e, "DiscreteInterpolant", (function () { return Mu })), n.d(e, "DodecahedronBufferGeometry", (function () { return rl })), n.d(e, "DodecahedronGeometry", (function () { return il })), n.d(e, "DoubleSide", (function () { return g })), n.d(e, "DstAlphaFactor", (function () { return k })), n.d(e, "DstColorFactor", (function () { return z })), n.d(e, "DynamicBufferAttribute", (function () { return Kf })), n.d(e, "DynamicCopyUsage", (function () { return Cn })), n.d(e, "DynamicDrawUsage", (function () { return En })), n.d(e, "DynamicReadUsage", (function () { return Ln })), n.d(e, "EdgesGeometry", (function () { return tu })), n.d(e, "EdgesHelper", (function () { return pp })), n.d(e, "EllipseCurve", (function () { return Xu })), n.d(e, "EqualDepth", (function () { return W })), n.d(e, "EqualStencilFunc", (function () { return _n })), n.d(e, "EquirectangularReflectionMapping", (function () { return at })), n.d(e, "EquirectangularRefractionMapping", (function () { return ct })), n.d(e, "Euler", (function () { return ai })), n.d(e, "EventDispatcher", (function () { return Dn })), n.d(e, "ExtrudeBufferGeometry", (function () { return Ul })), n.d(e, "ExtrudeGeometry", (function () { return Fl })), n.d(e, "Face3", (function () { return vr })), n.d(e, "Face4", (function () { return zf })), n.d(e, "FaceColors", (function () { return Gf })), n.d(e, "FileLoader", (function () { return Fu })), n.d(e, "FlatShading", (function () { return v })), n.d(e, "Float32Attribute", (function () { return ap })), n.d(e, "Float32BufferAttribute", (function () { return Or })), n.d(e, "Float64Attribute", (function () { return cp })), n.d(e, "Float64BufferAttribute", (function () { return Cr })), n.d(e, "FloatType", (function () { return Rt })), n.d(e, "Fog", (function () { return Wa })), n.d(e, "FogExp2", (function () { return Va })), n.d(e, "Font", (function () { return Hh })), n.d(e, "FontLoader", (function () { return jh })), n.d(e, "FrontSide", (function () { return p })), n.d(e, "Frustum", (function () { return Co })), n.d(e, "GammaEncoding", (function () { return $e })), n.d(e, "Geometry", (function () { return po })), n.d(e, "GeometryUtils", (function () { return _p })), n.d(e, "GreaterDepth", (function () { return X })), n.d(e, "GreaterEqualDepth", (function () { return q })), n.d(e, "GreaterEqualStencilFunc", (function () { return Mn })), n.d(e, "GreaterStencilFunc", (function () { return bn })), n.d(e, "GridHelper", (function () { return Zd })), n.d(e, "Group", (function () { return za })), n.d(e, "HalfFloatType", (function () { return Ot })), n.d(e, "HemisphereLight", (function () { return gh })), n.d(e, "HemisphereLightHelper", (function () { return Yd })), n.d(e, "HemisphereLightProbe", (function () { return Xh })), n.d(e, "IcosahedronBufferGeometry", (function () { return nl })), n.d(e, "IcosahedronGeometry", (function () { return el })), n.d(e, "ImageBitmapLoader", (function () { return Fh })), n.d(e, "ImageLoader", (function () { return ju })), n.d(e, "ImageUtils", (function () { return Hn })), n.d(e, "ImmediateRenderObject", (function () { return Bd })), n.d(e, "IncrementStencilOp", (function () { return dn })), n.d(e, "IncrementWrapStencilOp", (function () { return pn })), n.d(e, "InstancedBufferAttribute", (function () { return Ch })), n.d(e, "InstancedBufferGeometry", (function () { return Oh })), n.d(e, "InstancedInterleavedBuffer", (function () { return Ed })), n.d(e, "InstancedMesh", (function () { return Mc })), n.d(e, "Int16Attribute", (function () { return ip })), n.d(e, "Int16BufferAttribute", (function () { return Ar })), n.d(e, "Int32Attribute", (function () { return op })), n.d(e, "Int32BufferAttribute", (function () { return Lr })), n.d(e, "Int8Attribute", (function () { return tp })), n.d(e, "Int8BufferAttribute", (function () { return Tr })), n.d(e, "IntType", (function () { return Pt })), n.d(e, "InterleavedBuffer", (function () { return qa })), n.d(e, "InterleavedBufferAttribute", (function () { return Ya })), n.d(e, "Interpolant", (function () { return xu })), n.d(e, "InterpolateDiscrete", (function () { return Fe })), n.d(e, "InterpolateLinear", (function () { return Ue })), n.d(e, "InterpolateSmooth", (function () { return He })), n.d(e, "InvertStencilOp", (function () { return gn })), n.d(e, "JSONLoader", (function () { return bp })), n.d(e, "KeepStencilOp", (function () { return un })), n.d(e, "KeyframeTrack", (function () { return Tu })), n.d(e, "LOD", (function () { return fc })), n.d(e, "LatheBufferGeometry", (function () { return Jl })), n.d(e, "LatheGeometry", (function () { return Zl })), n.d(e, "Layers", (function () { return ci })), n.d(e, "LensFlare", (function () { return Mp })), n.d(e, "LessDepth", (function () { return j })), n.d(e, "LessEqualDepth", (function () { return V })), n.d(e, "LessEqualStencilFunc", (function () { return xn })), n.d(e, "LessStencilFunc", (function () { return yn })), n.d(e, "Light", (function () { return mh })), n.d(e, "LightProbe", (function () { return Ph })), n.d(e, "LightShadow", (function () { return vh })), n.d(e, "Line", (function () { return Rc })), n.d(e, "Line3", (function () { return kd })), n.d(e, "LineBasicMaterial", (function () { return Tc })), n.d(e, "LineCurve", (function () { return sh })), n.d(e, "LineCurve3", (function () { return ah })), n.d(e, "LineDashedMaterial", (function () { return vu })), n.d(e, "LineLoop", (function () { return Dc })), n.d(e, "LinePieces", (function () { return Uf })), n.d(e, "LineSegments", (function () { return Ic })), n.d(e, "LineStrip", (function () { return Ff })), n.d(e, "LinearEncoding", (function () { return Je })), n.d(e, "LinearFilter", (function () { return _t })), n.d(e, "LinearInterpolant", (function () { return wu })), n.d(e, "LinearMipMapLinearFilter", (function () { return Mt })), n.d(e, "LinearMipMapNearestFilter", (function () { return bt })), n.d(e, "LinearMipmapLinearFilter", (function () { return wt })), n.d(e, "LinearMipmapNearestFilter", (function () { return xt })), n.d(e, "LinearToneMapping", (function () { return K })), n.d(e, "Loader", (function () { return Bu })), n.d(e, "LoaderUtils", (function () { return Rh })), n.d(e, "LoadingManager", (function () { return Nu })), n.d(e, "LogLuvEncoding", (function () { return tn })), n.d(e, "LoopOnce", (function () { return ke })), n.d(e, "LoopPingPong", (function () { return ze })), n.d(e, "LoopRepeat", (function () { return Be })), n.d(e, "LuminanceAlphaFormat", (function () { return Ut })), n.d(e, "LuminanceFormat", (function () { return Ft })), n.d(e, "MOUSE", (function () { return r })), n.d(e, "Material", (function () { return _r })), n.d(e, "MaterialLoader", (function () { return Lh })), n.d(e, "Math", (function () { return Bn })), n.d(e, "MathUtils", (function () { return Bn })), n.d(e, "Matrix3", (function () { return Fn })), n.d(e, "Matrix4", (function () { return ri })), n.d(e, "MaxEquation", (function () { return L })), n.d(e, "Mesh", (function () { return so })), n.d(e, "MeshBasicMaterial", (function () { return xr })), n.d(e, "MeshDepthMaterial", (function () { return La })), n.d(e, "MeshDistanceMaterial", (function () { return Ra })), n.d(e, "MeshFaceMaterial", (function () { return Vf })), n.d(e, "MeshLambertMaterial", (function () { return mu })), n.d(e, "MeshMatcapMaterial", (function () { return gu })), n.d(e, "MeshNormalMaterial", (function () { return pu })), n.d(e, "MeshPhongMaterial", (function () { return du })), n.d(e, "MeshPhysicalMaterial", (function () { return hu })), n.d(e, "MeshStandardMaterial", (function () { return uu })), n.d(e, "MeshToonMaterial", (function () { return fu })), n.d(e, "MinEquation", (function () { return P })), n.d(e, "MirroredRepeatWrapping", (function () { return ft })), n.d(e, "MixOperation", (function () { return J })), n.d(e, "MultiMaterial", (function () { return Wf })), n.d(e, "MultiplyBlending", (function () { return M })), n.d(e, "MultiplyOperation", (function () { return Z })), n.d(e, "NearestFilter", (function () { return pt })), n.d(e, "NearestMipMapLinearFilter", (function () { return yt })), n.d(e, "NearestMipMapNearestFilter", (function () { return gt })), n.d(e, "NearestMipmapLinearFilter", (function () { return vt })), n.d(e, "NearestMipmapNearestFilter", (function () { return mt })), n.d(e, "NeverDepth", (function () { return H })), n.d(e, "NeverStencilFunc", (function () { return vn })), n.d(e, "NoBlending", (function () { return _ })), n.d(e, "NoColors", (function () { return Hf })), n.d(e, "NoToneMapping", (function () { return $ })), n.d(e, "NormalAnimationBlendMode", (function () { return We })), n.d(e, "NormalBlending", (function () { return x })), n.d(e, "NotEqualDepth", (function () { return Y })), n.d(e, "NotEqualStencilFunc", (function () { return wn })), n.d(e, "NumberKeyframeTrack", (function () { return Au })), n.d(e, "Object3D", (function () { return wi })), n.d(e, "ObjectLoader", (function () { return Nh })), n.d(e, "ObjectSpaceNormalMap", (function () { return cn })), n.d(e, "OctahedronBufferGeometry", (function () { return tl })), n.d(e, "OctahedronGeometry", (function () { return Kc })), n.d(e, "OneFactor", (function () { return O })), n.d(e, "OneMinusDstAlphaFactor", (function () { return B })), n.d(e, "OneMinusDstColorFactor", (function () { return F })), n.d(e, "OneMinusSrcAlphaFactor", (function () { return N })), n.d(e, "OneMinusSrcColorFactor", (function () { return I })), n.d(e, "OrthographicCamera", (function () { return wh })), n.d(e, "PCFShadowMap", (function () { return h })), n.d(e, "PCFSoftShadowMap", (function () { return d })), n.d(e, "PMREMGenerator", (function () { return Rf })), n.d(e, "ParametricBufferGeometry", (function () { return Yc })), n.d(e, "ParametricGeometry", (function () { return Xc })), n.d(e, "Particle", (function () { return Xf })), n.d(e, "ParticleBasicMaterial", (function () { return Jf })), n.d(e, "ParticleSystem", (function () { return Yf })), n.d(e, "ParticleSystemMaterial", (function () { return Qf })), n.d(e, "Path", (function () { return fh })), n.d(e, "PerspectiveCamera", (function () { return To })), n.d(e, "Plane", (function () { return $i })), n.d(e, "PlaneBufferGeometry", (function () { return Bo })), n.d(e, "PlaneGeometry", (function () { return ko })), n.d(e, "PlaneHelper", (function () { return lf })), n.d(e, "PointCloud", (function () { return qf })), n.d(e, "PointCloudMaterial", (function () { return Zf })), n.d(e, "PointLight", (function () { return bh })), n.d(e, "PointLightHelper", (function () { return Vd })), n.d(e, "Points", (function () { return Uc })), n.d(e, "PointsMaterial", (function () { return Nc })), n.d(e, "PolarGridHelper", (function () { return Jd })), n.d(e, "PolyhedronBufferGeometry", (function () { return Jc })), n.d(e, "PolyhedronGeometry", (function () { return Zc })), n.d(e, "PositionalAudio", (function () { return ld })), n.d(e, "PropertyBinding", (function () { return bd })), n.d(e, "PropertyMixer", (function () { return hd })), n.d(e, "QuadraticBezierCurve", (function () { return ch })), n.d(e, "QuadraticBezierCurve3", (function () { return lh })), n.d(e, "Quaternion", (function () { return Xn })), n.d(e, "QuaternionKeyframeTrack", (function () { return Lu })), n.d(e, "QuaternionLinearInterpolant", (function () { return Pu })), n.d(e, "REVISION", (function () { return i })), n.d(e, "RGBADepthPacking", (function () { return sn })), n.d(e, "RGBAFormat", (function () { return zt })), n.d(e, "RGBAIntegerFormat", (function () { return Zt })), n.d(e, "RGBA_ASTC_10x10_Format", (function () { return ye })), n.d(e, "RGBA_ASTC_10x5_Format", (function () { return me })), n.d(e, "RGBA_ASTC_10x6_Format", (function () { return ge })), n.d(e, "RGBA_ASTC_10x8_Format", (function () { return ve })), n.d(e, "RGBA_ASTC_12x10_Format", (function () { return _e })), n.d(e, "RGBA_ASTC_12x12_Format", (function () { return xe })), n.d(e, "RGBA_ASTC_4x4_Format", (function () { return ae })), n.d(e, "RGBA_ASTC_5x4_Format", (function () { return ce })), n.d(e, "RGBA_ASTC_5x5_Format", (function () { return le })), n.d(e, "RGBA_ASTC_6x5_Format", (function () { return ue })), n.d(e, "RGBA_ASTC_6x6_Format", (function () { return he })), n.d(e, "RGBA_ASTC_8x5_Format", (function () { return de })), n.d(e, "RGBA_ASTC_8x6_Format", (function () { return fe })), n.d(e, "RGBA_ASTC_8x8_Format", (function () { return pe })), n.d(e, "RGBA_BPTC_Format", (function () { return be })), n.d(e, "RGBA_ETC2_EAC_Format", (function () { return se })), n.d(e, "RGBA_PVRTC_2BPPV1_Format", (function () { return ie })), n.d(e, "RGBA_PVRTC_4BPPV1_Format", (function () { return ne })), n.d(e, "RGBA_S3TC_DXT1_Format", (function () { return Qt })), n.d(e, "RGBA_S3TC_DXT3_Format", (function () { return $t })), n.d(e, "RGBA_S3TC_DXT5_Format", (function () { return Kt })), n.d(e, "RGBDEncoding", (function () { return rn })), n.d(e, "RGBEEncoding", (function () { return Ke })), n.d(e, "RGBEFormat", (function () { return Ht })), n.d(e, "RGBFormat", (function () { return Bt })), n.d(e, "RGBIntegerFormat", (function () { return Yt })), n.d(e, "RGBM16Encoding", (function () { return nn })), n.d(e, "RGBM7Encoding", (function () { return en })), n.d(e, "RGB_ETC1_Format", (function () { return re })), n.d(e, "RGB_ETC2_Format", (function () { return oe })), n.d(e, "RGB_PVRTC_2BPPV1_Format", (function () { return ee })), n.d(e, "RGB_PVRTC_4BPPV1_Format", (function () { return te })), n.d(e, "RGB_S3TC_DXT1_Format", (function () { return Jt })), n.d(e, "RGFormat", (function () { return qt })), n.d(e, "RGIntegerFormat", (function () { return Xt })), n.d(e, "RawShaderMaterial", (function () { return lu })), n.d(e, "Ray", (function () { return Yi })), n.d(e, "Raycaster", (function () { return Ad })), n.d(e, "RectAreaLight", (function () { return Eh })), n.d(e, "RedFormat", (function () { return Vt })), n.d(e, "RedIntegerFormat", (function () { return Wt })), n.d(e, "ReinhardToneMapping", (function () { return tt })), n.d(e, "RepeatWrapping", (function () { return ht })), n.d(e, "ReplaceStencilOp", (function () { return hn })), n.d(e, "ReverseSubtractEquation", (function () { return A })), n.d(e, "RingBufferGeometry", (function () { return Yl })), n.d(e, "RingGeometry", (function () { return Xl })), n.d(e, "SRGB8_ALPHA8_ASTC_10x10_Format", (function () { return Ie })), n.d(e, "SRGB8_ALPHA8_ASTC_10x5_Format", (function () { return Re })), n.d(e, "SRGB8_ALPHA8_ASTC_10x6_Format", (function () { return Oe })), n.d(e, "SRGB8_ALPHA8_ASTC_10x8_Format", (function () { return Ce })), n.d(e, "SRGB8_ALPHA8_ASTC_12x10_Format", (function () { return De })), n.d(e, "SRGB8_ALPHA8_ASTC_12x12_Format", (function () { return Ne })), n.d(e, "SRGB8_ALPHA8_ASTC_4x4_Format", (function () { return we })), n.d(e, "SRGB8_ALPHA8_ASTC_5x4_Format", (function () { return Me })), n.d(e, "SRGB8_ALPHA8_ASTC_5x5_Format", (function () { return Te })), n.d(e, "SRGB8_ALPHA8_ASTC_6x5_Format", (function () { return Se })), n.d(e, "SRGB8_ALPHA8_ASTC_6x6_Format", (function () { return Ee })), n.d(e, "SRGB8_ALPHA8_ASTC_8x5_Format", (function () { return Ae })), n.d(e, "SRGB8_ALPHA8_ASTC_8x6_Format", (function () { return Pe })), n.d(e, "SRGB8_ALPHA8_ASTC_8x8_Format", (function () { return Le })), n.d(e, "Scene", (function () { return Mi })), n.d(e, "SceneUtils", (function () { return wp })), n.d(e, "ShaderChunk", (function () { return zo })), n.d(e, "ShaderLib", (function () { return Fo })), n.d(e, "ShaderMaterial", (function () { return wo })), n.d(e, "ShadowMaterial", (function () { return cu })), n.d(e, "Shape", (function () { return ph })), n.d(e, "ShapeBufferGeometry", (function () { return $l })), n.d(e, "ShapeGeometry", (function () { return Ql })), n.d(e, "ShapePath", (function () { return Uh })), n.d(e, "ShapeUtils", (function () { return kl })), n.d(e, "ShortType", (function () { return Et })), n.d(e, "Skeleton", (function () { return vc })), n.d(e, "SkeletonHelper", (function () { return jd })), n.d(e, "SkinnedMesh", (function () { return pc })), n.d(e, "SmoothShading", (function () { return y })), n.d(e, "Sphere", (function () { return Ui })), n.d(e, "SphereBufferGeometry", (function () { return ql })), n.d(e, "SphereGeometry", (function () { return Wl })), n.d(e, "Spherical", (function () { return Rd })), n.d(e, "SphericalHarmonics3", (function () { return Ah })), n.d(e, "Spline", (function () { return hp })), n.d(e, "SplineCurve", (function () { return uh })), n.d(e, "SplineCurve3", (function () { return up })), n.d(e, "SpotLight", (function () { return _h })), n.d(e, "SpotLightHelper", (function () { return Fd })), n.d(e, "SpotLightShadow", (function () { return yh })), n.d(e, "Sprite", (function () { return lc })), n.d(e, "SpriteMaterial", (function () { return Za })), n.d(e, "SrcAlphaFactor", (function () { return D })), n.d(e, "SrcAlphaSaturateFactor", (function () { return U })), n.d(e, "SrcColorFactor", (function () { return C })), n.d(e, "StaticCopyUsage", (function () { return On })), n.d(e, "StaticDrawUsage", (function () { return Sn })), n.d(e, "StaticReadUsage", (function () { return Pn })), n.d(e, "StereoCamera", (function () { return Qh })), n.d(e, "StreamCopyUsage", (function () { return In })), n.d(e, "StreamDrawUsage", (function () { return An })), n.d(e, "StreamReadUsage", (function () { return Rn })), n.d(e, "StringKeyframeTrack", (function () { return Ru })), n.d(e, "SubtractEquation", (function () { return E })), n.d(e, "SubtractiveBlending", (function () { return w })), n.d(e, "TOUCH", (function () { return o })), n.d(e, "TangentSpaceNormalMap", (function () { return an })), n.d(e, "TetrahedronBufferGeometry", (function () { return $c })), n.d(e, "TetrahedronGeometry", (function () { return Qc })), n.d(e, "TextBufferGeometry", (function () { return Vl })), n.d(e, "TextGeometry", (function () { return jl })), n.d(e, "Texture", (function () { return jn })), n.d(e, "TextureLoader", (function () { return Wu })), n.d(e, "TorusBufferGeometry", (function () { return ul })), n.d(e, "TorusGeometry", (function () { return ll })), n.d(e, "TorusKnotBufferGeometry", (function () { return cl })), n.d(e, "TorusKnotGeometry", (function () { return al })), n.d(e, "Triangle", (function () { return lr })), n.d(e, "TriangleFanDrawMode", (function () { return Ze })), n.d(e, "TriangleStripDrawMode", (function () { return Ye })), n.d(e, "TrianglesDrawMode", (function () { return Xe })), n.d(e, "TubeBufferGeometry", (function () { return sl })), n.d(e, "TubeGeometry", (function () { return ol })), n.d(e, "UVMapping", (function () { return rt })), n.d(e, "Uint16Attribute", (function () { return rp })), n.d(e, "Uint16BufferAttribute", (function () { return Pr })), n.d(e, "Uint32Attribute", (function () { return sp })), n.d(e, "Uint32BufferAttribute", (function () { return Rr })), n.d(e, "Uint8Attribute", (function () { return ep })), n.d(e, "Uint8BufferAttribute", (function () { return Sr })), n.d(e, "Uint8ClampedAttribute", (function () { return np })), n.d(e, "Uint8ClampedBufferAttribute", (function () { return Er })), n.d(e, "Uniform", (function () { return Sd })), n.d(e, "UniformsLib", (function () { return Io })), n.d(e, "UniformsUtils", (function () { return _o })), n.d(e, "UnsignedByteType", (function () { return Tt })), n.d(e, "UnsignedInt248Type", (function () { return Nt })), n.d(e, "UnsignedIntType", (function () { return Lt })), n.d(e, "UnsignedShort4444Type", (function () { return Ct })), n.d(e, "UnsignedShort5551Type", (function () { return It })), n.d(e, "UnsignedShort565Type", (function () { return Dt })), n.d(e, "UnsignedShortType", (function () { return At })), n.d(e, "VSMShadowMap", (function () { return f })), n.d(e, "Vector2", (function () { return zn })), n.d(e, "Vector3", (function () { return Jn })), n.d(e, "Vector4", (function () { return Vn })), n.d(e, "VectorKeyframeTrack", (function () { return Ou })), n.d(e, "Vertex", (function () { return $f })), n.d(e, "VertexColors", (function () { return jf })), n.d(e, "VideoTexture", (function () { return Gc })), n.d(e, "WebGL1Renderer", (function () { return ja })), n.d(e, "WebGLCubeRenderTarget", (function () { return Po })), n.d(e, "WebGLMultisampleRenderTarget", (function () { return qn })), n.d(e, "WebGLRenderTarget", (function () { return Wn })), n.d(e, "WebGLRenderTargetCube", (function () { return yp })), n.d(e, "WebGLRenderer", (function () { return Ga })), n.d(e, "WebGLUtils", (function () { return ka })), n.d(e, "WireframeGeometry", (function () { return qc })), n.d(e, "WireframeHelper", (function () { return mp })), n.d(e, "WrapAroundEnding", (function () { return Ve })), n.d(e, "XHRLoader", (function () { return gp })), n.d(e, "ZeroCurvatureEnding", (function () { return Ge })), n.d(e, "ZeroFactor", (function () { return R })), n.d(e, "ZeroSlopeEnding", (function () { return je })), n.d(e, "ZeroStencilOp", (function () { return ln })), n.d(e, "sRGBEncoding", (function () { return Qe })), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }), void 0 === Math.sign && (Math.sign = function (t) { return t < 0 ? -1 : t > 0 ? 1 : +t }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); const e = Object(t); for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; if (null != n) for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]) } return e }); const i = "119", r = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, o = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, s = 0, a = 1, c = 2, l = 3, u = 0, h = 1, d = 2, f = 3, p = 0, m = 1, g = 2, v = 1, y = 2, _ = 0, x = 1, b = 2, w = 3, M = 4, T = 5, S = 100, E = 101, A = 102, P = 103, L = 104, R = 200, O = 201, C = 202, I = 203, D = 204, N = 205, k = 206, B = 207, z = 208, F = 209, U = 210, H = 0, G = 1, j = 2, V = 3, W = 4, q = 5, X = 6, Y = 7, Z = 0, J = 1, Q = 2, $ = 0, K = 1, tt = 2, et = 3, nt = 4, it = 5, rt = 300, ot = 301, st = 302, at = 303, ct = 304, lt = 306, ut = 307, ht = 1e3, dt = 1001, ft = 1002, pt = 1003, mt = 1004, gt = 1004, vt = 1005, yt = 1005, _t = 1006, xt = 1007, bt = 1007, wt = 1008, Mt = 1008, Tt = 1009, St = 1010, Et = 1011, At = 1012, Pt = 1013, Lt = 1014, Rt = 1015, Ot = 1016, Ct = 1017, It = 1018, Dt = 1019, Nt = 1020, kt = 1021, Bt = 1022, zt = 1023, Ft = 1024, Ut = 1025, Ht = zt, Gt = 1026, jt = 1027, Vt = 1028, Wt = 1029, qt = 1030, Xt = 1031, Yt = 1032, Zt = 1033, Jt = 33776, Qt = 33777, $t = 33778, Kt = 33779, te = 35840, ee = 35841, ne = 35842, ie = 35843, re = 36196, oe = 37492, se = 37496, ae = 37808, ce = 37809, le = 37810, ue = 37811, he = 37812, de = 37813, fe = 37814, pe = 37815, me = 37816, ge = 37817, ve = 37818, ye = 37819, _e = 37820, xe = 37821, be = 36492, we = 37840, Me = 37841, Te = 37842, Se = 37843, Ee = 37844, Ae = 37845, Pe = 37846, Le = 37847, Re = 37848, Oe = 37849, Ce = 37850, Ie = 37851, De = 37852, Ne = 37853, ke = 2200, Be = 2201, ze = 2202, Fe = 2300, Ue = 2301, He = 2302, Ge = 2400, je = 2401, Ve = 2402, We = 2500, qe = 2501, Xe = 0, Ye = 1, Ze = 2, Je = 3e3, Qe = 3001, $e = 3007, Ke = 3002, tn = 3003, en = 3004, nn = 3005, rn = 3006, on = 3200, sn = 3201, an = 0, cn = 1, ln = 0, un = 7680, hn = 7681, dn = 7682, fn = 7683, pn = 34055, mn = 34056, gn = 5386, vn = 512, yn = 513, _n = 514, xn = 515, bn = 516, wn = 517, Mn = 518, Tn = 519, Sn = 35044, En = 35048, An = 35040, Pn = 35045, Ln = 35049, Rn = 35041, On = 35046, Cn = 35050, In = 35042; function Dn() { } Object.assign(Dn.prototype, { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) }, removeEventListener: function (t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); -1 !== t && n.splice(t, 1) } }, dispatchEvent: function (t) { if (void 0 === this._listeners) return; const e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; const n = e.slice(0); for (let e = 0, i = n.length; e < i; e++)n[e].call(this, t) } } }); const Nn = []; for (let t = 0; t < 256; t++)Nn[t] = (t < 16 ? "0" : "") + t.toString(16); let kn = 1234567; const Bn = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0; return (Nn[255 & t] + Nn[t >> 8 & 255] + Nn[t >> 16 & 255] + Nn[t >> 24 & 255] + "-" + Nn[255 & e] + Nn[e >> 8 & 255] + "-" + Nn[e >> 16 & 15 | 64] + Nn[e >> 24 & 255] + "-" + Nn[63 & n | 128] + Nn[n >> 8 & 255] + "-" + Nn[n >> 16 & 255] + Nn[n >> 24 & 255] + Nn[255 & i] + Nn[i >> 8 & 255] + Nn[i >> 16 & 255] + Nn[i >> 24 & 255]).toUpperCase() }, clamp: function (t, e, n) { return Math.max(e, Math.min(n, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) }, lerp: function (t, e, n) { return (1 - n) * t + n * e }, smoothstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, seededRandom: function (t) { return void 0 !== t && (kn = t % 2147483647), ((kn = 16807 * kn % 2147483647) - 1) / 2147483646 }, degToRad: function (t) { return t * Bn.DEG2RAD }, radToDeg: function (t) { return t * Bn.RAD2DEG }, isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, ceilPowerOfTwo: function (t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, floorPowerOfTwo: function (t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) }, setQuaternionFromProperEuler: function (t, e, n, i, r) { const o = Math.cos, s = Math.sin, a = o(n / 2), c = s(n / 2), l = o((e + i) / 2), u = s((e + i) / 2), h = o((e - i) / 2), d = s((e - i) / 2), f = o((i - e) / 2), p = s((i - e) / 2); switch (r) { case "XYX": t.set(a * u, c * h, c * d, a * l); break; case "YZY": t.set(c * d, a * u, c * h, a * l); break; case "ZXZ": t.set(c * h, c * d, a * u, a * l); break; case "XZX": t.set(a * u, c * p, c * f, a * l); break; case "YXY": t.set(c * f, a * u, c * p, a * l); break; case "ZYZ": t.set(c * p, c * f, a * u, a * l); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } }; function zn(t = 0, e = 0) { this.x = t, this.y = e } function Fn() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } let Un; Object.defineProperties(zn.prototype, { width: { get: function () { return this.x }, set: function (t) { this.x = t } }, height: { get: function () { return this.y }, set: function (t) { this.y = t } } }), Object.assign(zn.prototype, { isVector2: !0, set: function (t, e) { return this.x = t, this.y = e, this }, setScalar: function (t) { return this.x = t, this.y = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (t) { return this.x = t.x, this.y = t.y, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }, addScalar: function (t) { return this.x += t, this.y += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, applyMatrix3: function (t) { const e = this.x, n = this.y, i = t.elements; return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this }, clampLength: function (t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, cross: function (t) { return this.x * t.y - this.y * t.x }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length() || 1) }, angle: function () { return Math.atan2(-this.y, -this.x) + Math.PI }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { const e = this.x - t.x, n = this.y - t.y; return e * e + n * n }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, lerpVectors: function (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this }, equals: function (t) { return t.x === this.x && t.y === this.y }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }, rotateAround: function (t, e) { const n = Math.cos(e), i = Math.sin(e), r = this.x - t.x, o = this.y - t.y; return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this }, random: function () { return this.x = Math.random(), this.y = Math.random(), this } }), Object.assign(Fn.prototype, { isMatrix3: !0, set: function (t, e, n, i, r, o, s, a, c) { const l = this.elements; return l[0] = t, l[1] = i, l[2] = s, l[3] = e, l[4] = r, l[5] = a, l[6] = n, l[7] = o, l[8] = c, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function () { return (new this.constructor).fromArray(this.elements) }, copy: function (t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this }, extractBasis: function (t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this }, setFromMatrix4: function (t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this }, multiply: function (t) { return this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { const n = t.elements, i = e.elements, r = this.elements, o = n[0], s = n[3], a = n[6], c = n[1], l = n[4], u = n[7], h = n[2], d = n[5], f = n[8], p = i[0], m = i[3], g = i[6], v = i[1], y = i[4], _ = i[7], x = i[2], b = i[5], w = i[8]; return r[0] = o * p + s * v + a * x, r[3] = o * m + s * y + a * b, r[6] = o * g + s * _ + a * w, r[1] = c * p + l * v + u * x, r[4] = c * m + l * y + u * b, r[7] = c * g + l * _ + u * w, r[2] = h * p + d * v + f * x, r[5] = h * m + d * y + f * b, r[8] = h * g + d * _ + f * w, this }, multiplyScalar: function (t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, determinant: function () { const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], o = t[4], s = t[5], a = t[6], c = t[7], l = t[8]; return e * o * l - e * s * c - n * r * l + n * s * a + i * r * c - i * o * a }, getInverse: function (t, e) { void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."); const n = t.elements, i = this.elements, r = n[0], o = n[1], s = n[2], a = n[3], c = n[4], l = n[5], u = n[6], h = n[7], d = n[8], f = d * c - l * h, p = l * u - d * a, m = h * a - c * u, g = r * f + o * p + s * m; if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const v = 1 / g; return i[0] = f * v, i[1] = (s * h - d * o) * v, i[2] = (l * o - s * c) * v, i[3] = p * v, i[4] = (d * r - s * u) * v, i[5] = (s * a - l * r) * v, i[6] = m * v, i[7] = (o * u - h * r) * v, i[8] = (c * r - o * a) * v, this }, transpose: function () { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }, getNormalMatrix: function (t) { return this.setFromMatrix4(t).getInverse(this).transpose() }, transposeIntoArray: function (t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, setUvTransform: function (t, e, n, i, r, o, s) { const a = Math.cos(r), c = Math.sin(r); this.set(n * a, n * c, -n * (a * o + c * s) + o + t, -i * c, i * a, -i * (-c * o + a * s) + s + e, 0, 0, 1) }, scale: function (t, e) { const n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this }, rotate: function (t) { const e = Math.cos(t), n = Math.sin(t), i = this.elements, r = i[0], o = i[3], s = i[6], a = i[1], c = i[4], l = i[7]; return i[0] = e * r + n * a, i[3] = e * o + n * c, i[6] = e * s + n * l, i[1] = -n * r + e * a, i[4] = -n * o + e * c, i[7] = -n * s + e * l, this }, translate: function (t, e) { const n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this }, equals: function (t) { const e = this.elements, n = t.elements; for (let t = 0; t < 9; t++)if (e[t] !== n[t]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (let n = 0; n < 9; n++)this.elements[n] = t[n + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } }); const Hn = { getDataURL: function (t) { if (/^data:/i.test(t.src)) return t.src; if ("undefined" == typeof HTMLCanvasElement) return t.src; let e; if (t instanceof HTMLCanvasElement) e = t; else { void 0 === Un && (Un = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Un.width = t.width, Un.height = t.height; const n = Un.getContext("2d"); t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Un } return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png") } }; let Gn = 0; function jn(t, e, n, i, r, o, s, a, c, l) { Object.defineProperty(this, "id", { value: Gn++ }), this.uuid = Bn.generateUUID(), this.name = "", this.image = void 0 !== t ? t : jn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : jn.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : dt, this.wrapT = void 0 !== i ? i : dt, this.magFilter = void 0 !== r ? r : _t, this.minFilter = void 0 !== o ? o : wt, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== s ? s : zt, this.internalFormat = null, this.type = void 0 !== a ? a : Tt, this.offset = new zn(0, 0), this.repeat = new zn(1, 1), this.center = new zn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Fn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : Je, this.version = 0, this.onUpdate = null } function Vn(t = 0, e = 0, n = 0, i = 1) { this.x = t, this.y = e, this.z = n, this.w = i } function Wn(t, e, n) { this.width = t, this.height = e, this.scissor = new Vn(0, 0, t, e), this.scissorTest = !1, this.viewport = new Vn(0, 0, t, e), n = n || {}, this.texture = new jn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : _t, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } function qn(t, e, n) { Wn.call(this, t, e, n), this.samples = 4 } function Xn(t = 0, e = 0, n = 0, i = 1) { this._x = t, this._y = e, this._z = n, this._w = i } jn.DEFAULT_IMAGE = void 0, jn.DEFAULT_MAPPING = rt, jn.prototype = Object.assign(Object.create(Dn.prototype), { constructor: jn, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const i = this.image; if (void 0 === i.uuid && (i.uuid = Bn.generateUUID()), !e && void 0 === t.images[i.uuid]) { let e; if (Array.isArray(i)) { e = []; for (let t = 0, n = i.length; t < n; t++)e.push(Hn.getDataURL(i[t])) } else e = Hn.getDataURL(i); t.images[i.uuid] = { uuid: i.uuid, url: e } } n.image = i.uuid } return e || (t.textures[this.uuid] = n), n }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (t) { if (this.mapping !== rt) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case ht: t.x = t.x - Math.floor(t.x); break; case dt: t.x = t.x < 0 ? 0 : 1; break; case ft: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case ht: t.y = t.y - Math.floor(t.y); break; case dt: t.y = t.y < 0 ? 0 : 1; break; case ft: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } }), Object.defineProperty(jn.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.defineProperties(Vn.prototype, { width: { get: function () { return this.z }, set: function (t) { this.z = t } }, height: { get: function () { return this.w }, set: function (t) { this.w = t } } }), Object.assign(Vn.prototype, { isVector4: !0, set: function (t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this.w = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setW: function (t) { return this.w = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }, applyMatrix4: function (t) { const e = this.x, n = this.y, i = this.z, r = this.w, o = t.elements; return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, setAxisAngleFromQuaternion: function (t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, setAxisAngleFromRotationMatrix: function (t) { let e, n, i, r; const o = t.elements, s = o[0], a = o[4], c = o[8], l = o[1], u = o[5], h = o[9], d = o[2], f = o[6], p = o[10]; if (Math.abs(a - l) < .01 && Math.abs(c - d) < .01 && Math.abs(h - f) < .01) { if (Math.abs(a + l) < .1 && Math.abs(c + d) < .1 && Math.abs(h + f) < .1 && Math.abs(s + u + p - 3) < .1) return this.set(1, 0, 0, 0), this; e = Math.PI; const t = (s + 1) / 2, o = (u + 1) / 2, m = (p + 1) / 2, g = (a + l) / 4, v = (c + d) / 4, y = (h + f) / 4; return t > o && t > m ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = g / (n = Math.sqrt(t)), r = v / n) : o > m ? o < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = g / (i = Math.sqrt(o)), r = y / i) : m < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = v / (r = Math.sqrt(m)), i = y / r), this.set(n, i, r, e), this } let m = Math.sqrt((f - h) * (f - h) + (c - d) * (c - d) + (l - a) * (l - a)); return Math.abs(m) < .001 && (m = 1), this.x = (f - h) / m, this.y = (c - d) / m, this.z = (l - a) / m, this.w = Math.acos((s + u + p - 1) / 2), this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this }, clampLength: function (t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, lerpVectors: function (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this }, random: function () { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } }), Wn.prototype = Object.assign(Object.create(Dn.prototype), { constructor: Wn, isWebGLRenderTarget: !0, setSize: function (t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), qn.prototype = Object.assign(Object.create(Wn.prototype), { constructor: qn, isWebGLMultisampleRenderTarget: !0, copy: function (t) { return Wn.prototype.copy.call(this, t), this.samples = t.samples, this } }), Object.assign(Xn, { slerp: function (t, e, n, i) { return n.copy(t).slerp(e, i) }, slerpFlat: function (t, e, n, i, r, o, s) { let a = n[i + 0], c = n[i + 1], l = n[i + 2], u = n[i + 3]; const h = r[o + 0], d = r[o + 1], f = r[o + 2], p = r[o + 3]; if (u !== p || a !== h || c !== d || l !== f) { let t = 1 - s, e = a * h + c * d + l * f + u * p, n = e >= 0 ? 1 : -1, i = 1 - e * e; if (i > Number.EPSILON) { const r = Math.sqrt(i), o = Math.atan2(r, e * n); t = Math.sin(t * o) / r, s = Math.sin(s * o) / r } const r = s * n; if (a = a * t + h * r, c = c * t + d * r, l = l * t + f * r, u = u * t + p * r, t === 1 - s) { const t = 1 / Math.sqrt(a * a + c * c + l * l + u * u); a *= t, c *= t, l *= t, u *= t } } t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u }, multiplyQuaternionsFlat: function (t, e, n, i, r, o) { const s = n[i], a = n[i + 1], c = n[i + 2], l = n[i + 3], u = r[o], h = r[o + 1], d = r[o + 2], f = r[o + 3]; return t[e] = s * f + l * u + a * d - c * h, t[e + 1] = a * f + l * h + c * u - s * d, t[e + 2] = c * f + l * d + s * h - a * u, t[e + 3] = l * f - s * u - a * h - c * d, t } }), Object.defineProperties(Xn.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this._onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this._onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this._onChangeCallback() } }, w: { get: function () { return this._w }, set: function (t) { this._w = t, this._onChangeCallback() } } }), Object.assign(Xn.prototype, { isQuaternion: !0, set: function (t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this }, setFromEuler: function (t, e) { if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = t._x, i = t._y, r = t._z, o = t.order, s = Math.cos, a = Math.sin, c = s(n / 2), l = s(i / 2), u = s(r / 2), h = a(n / 2), d = a(i / 2), f = a(r / 2); switch (o) { case "XYZ": this._x = h * l * u + c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u - h * d * f; break; case "YXZ": this._x = h * l * u + c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u + h * d * f; break; case "ZXY": this._x = h * l * u - c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u - h * d * f; break; case "ZYX": this._x = h * l * u - c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u + h * d * f; break; case "YZX": this._x = h * l * u + c * d * f, this._y = c * d * u + h * l * f, this._z = c * l * f - h * d * u, this._w = c * l * u - h * d * f; break; case "XZY": this._x = h * l * u - c * d * f, this._y = c * d * u - h * l * f, this._z = c * l * f + h * d * u, this._w = c * l * u + h * d * f; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return !1 !== e && this._onChangeCallback(), this }, setFromAxisAngle: function (t, e) { const n = e / 2, i = Math.sin(n); return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this }, setFromRotationMatrix: function (t) { const e = t.elements, n = e[0], i = e[4], r = e[8], o = e[1], s = e[5], a = e[9], c = e[2], l = e[6], u = e[10], h = n + s + u; if (h > 0) { const t = .5 / Math.sqrt(h + 1); this._w = .25 / t, this._x = (l - a) * t, this._y = (r - c) * t, this._z = (o - i) * t } else if (n > s && n > u) { const t = 2 * Math.sqrt(1 + n - s - u); this._w = (l - a) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (r + c) / t } else if (s > u) { const t = 2 * Math.sqrt(1 + s - n - u); this._w = (r - c) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (a + l) / t } else { const t = 2 * Math.sqrt(1 + u - n - s); this._w = (o - i) / t, this._x = (r + c) / t, this._y = (a + l) / t, this._z = .25 * t } return this._onChangeCallback(), this }, setFromUnitVectors: function (t, e) { let n = t.dot(e) + 1; return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() }, angleTo: function (t) { return 2 * Math.acos(Math.abs(Bn.clamp(this.dot(t), -1, 1))) }, rotateTowards: function (t, e) { const n = this.angleTo(t); if (0 === n) return this; const i = Math.min(1, e / n); return this.slerp(t, i), this }, identity: function () { return this.set(0, 0, 0, 1) }, inverse: function () { return this.conjugate() }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this }, dot: function (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }, premultiply: function (t) { return this.multiplyQuaternions(t, this) }, multiplyQuaternions: function (t, e) { const n = t._x, i = t._y, r = t._z, o = t._w, s = e._x, a = e._y, c = e._z, l = e._w; return this._x = n * l + o * s + i * c - r * a, this._y = i * l + o * a + r * s - n * c, this._z = r * l + o * c + n * a - i * s, this._w = o * l - n * s - i * a - r * c, this._onChangeCallback(), this }, slerp: function (t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); const n = this._x, i = this._y, r = this._z, o = this._w; let s = o * t._w + n * t._x + i * t._y + r * t._z; if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this; const a = 1 - s * s; if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this } const c = Math.sqrt(a), l = Math.atan2(c, s), u = Math.sin((1 - e) * l) / c, h = Math.sin(e * l) / c; return this._w = o * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, fromBufferAttribute: function (t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this }, _onChange: function (t) { return this._onChangeCallback = t, this }, _onChangeCallback: function () { } }); const Yn = new Jn, Zn = new Xn; function Jn(t = 0, e = 0, n = 0) { this.x = t, this.y = e, this.z = n } Object.assign(Jn.prototype, { isVector3: !0, set: function (t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this }, setScalar: function (t) { return this.x = t, this.y = t, this.z = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyEuler: function (t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Zn.setFromEuler(t)) }, applyAxisAngle: function (t, e) { return this.applyQuaternion(Zn.setFromAxisAngle(t, e)) }, applyMatrix3: function (t) { const e = this.x, n = this.y, i = this.z, r = t.elements; return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this }, applyNormalMatrix: function (t) { return this.applyMatrix3(t).normalize() }, applyMatrix4: function (t) { const e = this.x, n = this.y, i = this.z, r = t.elements, o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]); return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this }, applyQuaternion: function (t) { const e = this.x, n = this.y, i = this.z, r = t.x, o = t.y, s = t.z, a = t.w, c = a * e + o * i - s * n, l = a * n + s * e - r * i, u = a * i + r * n - o * e, h = -r * e - o * n - s * i; return this.x = c * a + h * -r + l * -s - u * -o, this.y = l * a + h * -o + u * -r - c * -s, this.z = u * a + h * -s + c * -o - l * -r, this }, project: function (t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }, unproject: function (t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) }, transformDirection: function (t) { const e = this.x, n = this.y, i = this.z, r = t.elements; return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize() }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this }, clampLength: function (t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, lerpVectors: function (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this }, cross: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }, crossVectors: function (t, e) { const n = t.x, i = t.y, r = t.z, o = e.x, s = e.y, a = e.z; return this.x = i * a - r * s, this.y = r * o - n * a, this.z = n * s - i * o, this }, projectOnVector: function (t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) }, projectOnPlane: function (t) { return Yn.copy(this).projectOnVector(t), this.sub(Yn) }, reflect: function (t) { return this.sub(Yn.copy(t).multiplyScalar(2 * this.dot(t))) }, angleTo: function (t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(Bn.clamp(n, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { const e = this.x - t.x, n = this.y - t.y, i = this.z - t.z; return e * e + n * n + i * i }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }, setFromSpherical: function (t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }, setFromSphericalCoords: function (t, e, n) { const i = Math.sin(e) * t; return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this }, setFromCylindrical: function (t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }, setFromCylindricalCoords: function (t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this }, setFromMatrixPosition: function (t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this }, setFromMatrixScale: function (t) { const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = n, this.z = i, this }, setFromMatrixColumn: function (t, e) { return this.fromArray(t.elements, 4 * e) }, setFromMatrix3Column: function (t, e) { return this.fromArray(t.elements, 3 * e) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, fromBufferAttribute: function (t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this }, random: function () { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } }); const Qn = new Jn, $n = new ri, Kn = new Jn(0, 0, 0), ti = new Jn(1, 1, 1), ei = new Jn, ni = new Jn, ii = new Jn; function ri() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } Object.assign(ri.prototype, { isMatrix4: !0, set: function (t, e, n, i, r, o, s, a, c, l, u, h, d, f, p, m) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = d, g[7] = f, g[11] = p, g[15] = m, this }, identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function () { return (new ri).fromArray(this.elements) }, copy: function (t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this }, copyPosition: function (t) { const e = this.elements, n = t.elements; return e[12] = n[12], e[13] = n[13], e[14] = n[14], this }, extractBasis: function (t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this }, makeBasis: function (t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this }, extractRotation: function (t) { const e = this.elements, n = t.elements, i = 1 / Qn.setFromMatrixColumn(t, 0).length(), r = 1 / Qn.setFromMatrixColumn(t, 1).length(), o = 1 / Qn.setFromMatrixColumn(t, 2).length(); return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, makeRotationFromEuler: function (t) { t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const e = this.elements, n = t.x, i = t.y, r = t.z, o = Math.cos(n), s = Math.sin(n), a = Math.cos(i), c = Math.sin(i), l = Math.cos(r), u = Math.sin(r); if ("XYZ" === t.order) { const t = o * l, n = o * u, i = s * l, r = s * u; e[0] = a * l, e[4] = -a * u, e[8] = c, e[1] = n + i * c, e[5] = t - r * c, e[9] = -s * a, e[2] = r - t * c, e[6] = i + n * c, e[10] = o * a } else if ("YXZ" === t.order) { const t = a * l, n = a * u, i = c * l, r = c * u; e[0] = t + r * s, e[4] = i * s - n, e[8] = o * c, e[1] = o * u, e[5] = o * l, e[9] = -s, e[2] = n * s - i, e[6] = r + t * s, e[10] = o * a } else if ("ZXY" === t.order) { const t = a * l, n = a * u, i = c * l, r = c * u; e[0] = t - r * s, e[4] = -o * u, e[8] = i + n * s, e[1] = n + i * s, e[5] = o * l, e[9] = r - t * s, e[2] = -o * c, e[6] = s, e[10] = o * a } else if ("ZYX" === t.order) { const t = o * l, n = o * u, i = s * l, r = s * u; e[0] = a * l, e[4] = i * c - n, e[8] = t * c + r, e[1] = a * u, e[5] = r * c + t, e[9] = n * c - i, e[2] = -c, e[6] = s * a, e[10] = o * a } else if ("YZX" === t.order) { const t = o * a, n = o * c, i = s * a, r = s * c; e[0] = a * l, e[4] = r - t * u, e[8] = i * u + n, e[1] = u, e[5] = o * l, e[9] = -s * l, e[2] = -c * l, e[6] = n * u + i, e[10] = t - r * u } else if ("XZY" === t.order) { const t = o * a, n = o * c, i = s * a, r = s * c; e[0] = a * l, e[4] = -u, e[8] = c * l, e[1] = t * u + r, e[5] = o * l, e[9] = n * u - i, e[2] = i * u - n, e[6] = s * l, e[10] = r * u + t } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, makeRotationFromQuaternion: function (t) { return this.compose(Kn, t, ti) }, lookAt: function (t, e, n) { const i = this.elements; return ii.subVectors(t, e), 0 === ii.lengthSq() && (ii.z = 1), ii.normalize(), ei.crossVectors(n, ii), 0 === ei.lengthSq() && (1 === Math.abs(n.z) ? ii.x += 1e-4 : ii.z += 1e-4, ii.normalize(), ei.crossVectors(n, ii)), ei.normalize(), ni.crossVectors(ii, ei), i[0] = ei.x, i[4] = ni.x, i[8] = ii.x, i[1] = ei.y, i[5] = ni.y, i[9] = ii.y, i[2] = ei.z, i[6] = ni.z, i[10] = ii.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { const n = t.elements, i = e.elements, r = this.elements, o = n[0], s = n[4], a = n[8], c = n[12], l = n[1], u = n[5], h = n[9], d = n[13], f = n[2], p = n[6], m = n[10], g = n[14], v = n[3], y = n[7], _ = n[11], x = n[15], b = i[0], w = i[4], M = i[8], T = i[12], S = i[1], E = i[5], A = i[9], P = i[13], L = i[2], R = i[6], O = i[10], C = i[14], I = i[3], D = i[7], N = i[11], k = i[15]; return r[0] = o * b + s * S + a * L + c * I, r[4] = o * w + s * E + a * R + c * D, r[8] = o * M + s * A + a * O + c * N, r[12] = o * T + s * P + a * C + c * k, r[1] = l * b + u * S + h * L + d * I, r[5] = l * w + u * E + h * R + d * D, r[9] = l * M + u * A + h * O + d * N, r[13] = l * T + u * P + h * C + d * k, r[2] = f * b + p * S + m * L + g * I, r[6] = f * w + p * E + m * R + g * D, r[10] = f * M + p * A + m * O + g * N, r[14] = f * T + p * P + m * C + g * k, r[3] = v * b + y * S + _ * L + x * I, r[7] = v * w + y * E + _ * R + x * D, r[11] = v * M + y * A + _ * O + x * N, r[15] = v * T + y * P + _ * C + x * k, this }, multiplyScalar: function (t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, determinant: function () { const t = this.elements, e = t[0], n = t[4], i = t[8], r = t[12], o = t[1], s = t[5], a = t[9], c = t[13], l = t[2], u = t[6], h = t[10], d = t[14]; return t[3] * (+r * a * u - i * c * u - r * s * h + n * c * h + i * s * d - n * a * d) + t[7] * (+e * a * d - e * c * h + r * o * h - i * o * d + i * c * l - r * a * l) + t[11] * (+e * c * u - e * s * d - r * o * u + n * o * d + r * s * l - n * c * l) + t[15] * (-i * s * l - e * a * u + e * s * h + i * o * u - n * o * h + n * a * l) }, transpose: function () { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }, setPosition: function (t, e, n) { const i = this.elements; return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this }, getInverse: function (t, e) { void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."); const n = this.elements, i = t.elements, r = i[0], o = i[1], s = i[2], a = i[3], c = i[4], l = i[5], u = i[6], h = i[7], d = i[8], f = i[9], p = i[10], m = i[11], g = i[12], v = i[13], y = i[14], _ = i[15], x = f * y * h - v * p * h + v * u * m - l * y * m - f * u * _ + l * p * _, b = g * p * h - d * y * h - g * u * m + c * y * m + d * u * _ - c * p * _, w = d * v * h - g * f * h + g * l * m - c * v * m - d * l * _ + c * f * _, M = g * f * u - d * v * u - g * l * p + c * v * p + d * l * y - c * f * y, T = r * x + o * b + s * w + a * M; if (0 === T) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const S = 1 / T; return n[0] = x * S, n[1] = (v * p * a - f * y * a - v * s * m + o * y * m + f * s * _ - o * p * _) * S, n[2] = (l * y * a - v * u * a + v * s * h - o * y * h - l * s * _ + o * u * _) * S, n[3] = (f * u * a - l * p * a - f * s * h + o * p * h + l * s * m - o * u * m) * S, n[4] = b * S, n[5] = (d * y * a - g * p * a + g * s * m - r * y * m - d * s * _ + r * p * _) * S, n[6] = (g * u * a - c * y * a - g * s * h + r * y * h + c * s * _ - r * u * _) * S, n[7] = (c * p * a - d * u * a + d * s * h - r * p * h - c * s * m + r * u * m) * S, n[8] = w * S, n[9] = (g * f * a - d * v * a - g * o * m + r * v * m + d * o * _ - r * f * _) * S, n[10] = (c * v * a - g * l * a + g * o * h - r * v * h - c * o * _ + r * l * _) * S, n[11] = (d * l * a - c * f * a - d * o * h + r * f * h + c * o * m - r * l * m) * S, n[12] = M * S, n[13] = (d * v * s - g * f * s + g * o * p - r * v * p - d * o * y + r * f * y) * S, n[14] = (g * l * s - c * v * s - g * o * u + r * v * u + c * o * y - r * l * y) * S, n[15] = (c * f * s - d * l * s + d * o * u - r * f * u - c * o * p + r * l * p) * S, this }, scale: function (t) { const e = this.elements, n = t.x, i = t.y, r = t.z; return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this }, getMaxScaleOnAxis: function () { const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, n, i)) }, makeTranslation: function (t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this }, makeRotationX: function (t) { const e = Math.cos(t), n = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this }, makeRotationY: function (t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this }, makeRotationZ: function (t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function (t, e) { const n = Math.cos(e), i = Math.sin(e), r = 1 - n, o = t.x, s = t.y, a = t.z, c = r * o, l = r * s; return this.set(c * o + n, c * s - i * a, c * a + i * s, 0, c * s + i * a, l * s + n, l * a - i * o, 0, c * a - i * s, l * a + i * o, r * a * a + n, 0, 0, 0, 0, 1), this }, makeScale: function (t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this }, makeShear: function (t, e, n) { return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this }, compose: function (t, e, n) { const i = this.elements, r = e._x, o = e._y, s = e._z, a = e._w, c = r + r, l = o + o, u = s + s, h = r * c, d = r * l, f = r * u, p = o * l, m = o * u, g = s * u, v = a * c, y = a * l, _ = a * u, x = n.x, b = n.y, w = n.z; return i[0] = (1 - (p + g)) * x, i[1] = (d + _) * x, i[2] = (f - y) * x, i[3] = 0, i[4] = (d - _) * b, i[5] = (1 - (h + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (f + y) * w, i[9] = (m - v) * w, i[10] = (1 - (h + p)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this }, decompose: function (t, e, n) { const i = this.elements; let r = Qn.set(i[0], i[1], i[2]).length(), o = Qn.set(i[4], i[5], i[6]).length(), s = Qn.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], $n.copy(this); const a = 1 / r, c = 1 / o, l = 1 / s; return $n.elements[0] *= a, $n.elements[1] *= a, $n.elements[2] *= a, $n.elements[4] *= c, $n.elements[5] *= c, $n.elements[6] *= c, $n.elements[8] *= l, $n.elements[9] *= l, $n.elements[10] *= l, e.setFromRotationMatrix($n), n.x = r, n.y = o, n.z = s, this }, makePerspective: function (t, e, n, i, r, o) { void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const s = this.elements, a = 2 * r / (e - t), c = 2 * r / (n - i), l = (e + t) / (e - t), u = (n + i) / (n - i), h = -(o + r) / (o - r), d = -2 * o * r / (o - r); return s[0] = a, s[4] = 0, s[8] = l, s[12] = 0, s[1] = 0, s[5] = c, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this }, makeOrthographic: function (t, e, n, i, r, o) { const s = this.elements, a = 1 / (e - t), c = 1 / (n - i), l = 1 / (o - r), u = (e + t) * a, h = (n + i) * c, d = (o + r) * l; return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * l, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this }, equals: function (t) { const e = this.elements, n = t.elements; for (let t = 0; t < 16; t++)if (e[t] !== n[t]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (let n = 0; n < 16; n++)this.elements[n] = t[n + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t } }); const oi = new ri, si = new Xn; function ai(t = 0, e = 0, n = 0, i = ai.DefaultOrder) { this._x = t, this._y = e, this._z = n, this._order = i } function ci() { this.mask = 1 } ai.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], ai.DefaultOrder = "XYZ", Object.defineProperties(ai.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this._onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this._onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this._onChangeCallback() } }, order: { get: function () { return this._order }, set: function (t) { this._order = t, this._onChangeCallback() } } }), Object.assign(ai.prototype, { isEuler: !0, set: function (t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this }, setFromRotationMatrix: function (t, e, n) { const i = Bn.clamp, r = t.elements, o = r[0], s = r[4], a = r[8], c = r[1], l = r[5], u = r[9], h = r[2], d = r[6], f = r[10]; switch (e = e || this._order) { case "XYZ": this._y = Math.asin(i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(d, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, o), this._z = 0); break; case "ZXY": this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(c, o)); break; case "ZYX": this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(a, f)); break; case "XZY": this._z = Math.asin(-i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-u, f), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e) }return this._order = e, !1 !== n && this._onChangeCallback(), this }, setFromQuaternion: function (t, e, n) { return oi.makeRotationFromQuaternion(t), this.setFromRotationMatrix(oi, e, n) }, setFromVector3: function (t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, reorder: function (t) { return si.setFromEuler(this), this.setFromQuaternion(si, t) }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, fromArray: function (t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, toVector3: function (t) { return t ? t.set(this._x, this._y, this._z) : new Jn(this._x, this._y, this._z) }, _onChange: function (t) { return this._onChangeCallback = t, this }, _onChangeCallback: function () { } }), Object.assign(ci.prototype, { set: function (t) { this.mask = 1 << t | 0 }, enable: function (t) { this.mask |= 1 << t | 0 }, enableAll: function () { this.mask = -1 }, toggle: function (t) { this.mask ^= 1 << t | 0 }, disable: function (t) { this.mask &= ~(1 << t | 0) }, disableAll: function () { this.mask = 0 }, test: function (t) { return 0 != (this.mask & t.mask) } }); let li = 0; const ui = new Jn, hi = new Xn, di = new ri, fi = new Jn, pi = new Jn, mi = new Jn, gi = new Xn, vi = new Jn(1, 0, 0), yi = new Jn(0, 1, 0), _i = new Jn(0, 0, 1), xi = { type: "added" }, bi = { type: "removed" }; function wi() { Object.defineProperty(this, "id", { value: li++ }), this.uuid = Bn.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = wi.DefaultUp.clone(); const t = new Jn, e = new ai, n = new Xn, i = new Jn(1, 1, 1); e._onChange((function () { n.setFromEuler(e, !1) })), n._onChange((function () { e.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new ri }, normalMatrix: { value: new Fn } }), this.matrix = new ri, this.matrixWorld = new ri, this.matrixAutoUpdate = wi.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ci, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } function Mi() { wi.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } wi.DefaultUp = new Jn(0, 1, 0), wi.DefaultMatrixAutoUpdate = !0, wi.prototype = Object.assign(Object.create(Dn.prototype), { constructor: wi, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix4: function (t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (t) { return this.quaternion.premultiply(t), this }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: function (t, e) { return hi.setFromAxisAngle(t, e), this.quaternion.multiply(hi), this }, rotateOnWorldAxis: function (t, e) { return hi.setFromAxisAngle(t, e), this.quaternion.premultiply(hi), this }, rotateX: function (t) { return this.rotateOnAxis(vi, t) }, rotateY: function (t) { return this.rotateOnAxis(yi, t) }, rotateZ: function (t) { return this.rotateOnAxis(_i, t) }, translateOnAxis: function (t, e) { return ui.copy(t).applyQuaternion(this.quaternion), this.position.add(ui.multiplyScalar(e)), this }, translateX: function (t) { return this.translateOnAxis(vi, t) }, translateY: function (t) { return this.translateOnAxis(yi, t) }, translateZ: function (t) { return this.translateOnAxis(_i, t) }, localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: function (t) { return t.applyMatrix4(di.getInverse(this.matrixWorld)) }, lookAt: function (t, e, n) { t.isVector3 ? fi.copy(t) : fi.set(t, e, n); const i = this.parent; this.updateWorldMatrix(!0, !1), pi.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? di.lookAt(pi, fi, this.up) : di.lookAt(fi, pi, this.up), this.quaternion.setFromRotationMatrix(di), i && (di.extractRotation(i.matrixWorld), hi.setFromRotationMatrix(di), this.quaternion.premultiply(hi.inverse())) }, add: function (t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(xi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }, remove: function (t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(bi)), this }, attach: function (t) { return this.updateWorldMatrix(!0, !1), di.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), di.multiply(t.parent.matrixWorld)), t.applyMatrix4(di), t.updateWorldMatrix(!1, !1), this.add(t), this }, getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(t, e); if (void 0 !== i) return i } }, getWorldPosition: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Jn), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new Xn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(pi, t, mi), t }, getWorldScale: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new Jn), this.updateMatrixWorld(!0), this.matrixWorld.decompose(pi, gi, t), t }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Jn), this.updateMatrixWorld(!0); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }, raycast: function () { }, traverse: function (t) { t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].traverse(t) }, traverseVisible: function (t) { if (!1 === this.visible) return; t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].traverseVisible(t) }, traverseAncestors: function (t) { const e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].updateMatrixWorld(t) }, updateWorldMatrix: function (t, e) { const n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++)t[e].updateWorldMatrix(!1, !0) } }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t, n = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const i = {}; function r(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) { i.geometry = r(t.geometries, this.geometry); const e = this.geometry.parameters; if (void 0 !== e && void 0 !== e.shapes) { const n = e.shapes; if (Array.isArray(n)) for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; r(t.shapes, i) } else r(t.shapes, n) } } if (void 0 !== this.material) if (Array.isArray(this.material)) { const e = []; for (let n = 0, i = this.material.length; n < i; n++)e.push(r(t.materials, this.material[n])); i.material = e } else i.material = r(t.materials, this.material); if (this.children.length > 0) { i.children = []; for (let e = 0; e < this.children.length; e++)i.children.push(this.children[e].toJSON(t).object) } if (e) { const e = o(t.geometries), i = o(t.materials), r = o(t.textures), s = o(t.images), a = o(t.shapes); e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a) } return n.object = i, n; function o(t) { const e = []; for (const n in t) { const i = t[n]; delete i.metadata, e.push(i) } return e } }, clone: function (t) { return (new this.constructor).copy(this, t) }, copy: function (t, e) { if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) { const n = t.children[e]; this.add(n.clone()) } return this } }), Mi.prototype = Object.assign(Object.create(wi.prototype), { constructor: Mi, isScene: !0, copy: function (t, e) { return wi.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }, toJSON: function (t) { const e = wi.prototype.toJSON.call(this, t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); const Ti = [new Jn, new Jn, new Jn, new Jn, new Jn, new Jn, new Jn, new Jn], Si = new Jn, Ei = new Bi, Ai = new Jn, Pi = new Jn, Li = new Jn, Ri = new Jn, Oi = new Jn, Ci = new Jn, Ii = new Jn, Di = new Jn, Ni = new Jn, ki = new Jn; function Bi(t, e) { this.min = void 0 !== t ? t : new Jn(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Jn(-1 / 0, -1 / 0, -1 / 0) } function zi(t, e, n, i, r) { for (let o = 0, s = t.length - 3; o <= s; o += 3) { ki.fromArray(t, o); const s = r.x * Math.abs(ki.x) + r.y * Math.abs(ki.y) + r.z * Math.abs(ki.z), a = e.dot(ki), c = n.dot(ki), l = i.dot(ki); if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1 } return !0 } Object.assign(Bi.prototype, { isBox3: !0, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromArray: function (t) { let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0; for (let a = 0, c = t.length; a < c; a += 3) { const c = t[a], l = t[a + 1], u = t[a + 2]; c < e && (e = c), l < n && (n = l), u < i && (i = u), c > r && (r = c), l > o && (o = l), u > s && (s = u) } return this.min.set(e, n, i), this.max.set(r, o, s), this }, setFromBufferAttribute: function (t) { let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0; for (let a = 0, c = t.count; a < c; a++) { const c = t.getX(a), l = t.getY(a), u = t.getZ(a); c < e && (e = c), l < n && (n = l), u < i && (i = u), c > r && (r = c), l > o && (o = l), u > s && (s = u) } return this.min.set(e, n, i), this.max.set(r, o, s), this }, setFromPoints: function (t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function (t, e) { const n = Si.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }, setFromObject: function (t) { return this.makeEmpty(), this.expandByObject(t) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Jn), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Jn), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, expandByObject: function (t) { t.updateWorldMatrix(!1, !1); const e = t.geometry; void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Ei.copy(e.boundingBox), Ei.applyMatrix4(t.matrixWorld), this.union(Ei)); const n = t.children; for (let t = 0, e = n.length; t < e; t++)this.expandByObject(n[t]); return this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Jn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, intersectsSphere: function (t) { return this.clampPoint(t.center, Si), Si.distanceToSquared(t.center) <= t.radius * t.radius }, intersectsPlane: function (t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant }, intersectsTriangle: function (t) { if (this.isEmpty()) return !1; this.getCenter(Ii), Di.subVectors(this.max, Ii), Ai.subVectors(t.a, Ii), Pi.subVectors(t.b, Ii), Li.subVectors(t.c, Ii), Ri.subVectors(Pi, Ai), Oi.subVectors(Li, Pi), Ci.subVectors(Ai, Li); let e = [0, -Ri.z, Ri.y, 0, -Oi.z, Oi.y, 0, -Ci.z, Ci.y, Ri.z, 0, -Ri.x, Oi.z, 0, -Oi.x, Ci.z, 0, -Ci.x, -Ri.y, Ri.x, 0, -Oi.y, Oi.x, 0, -Ci.y, Ci.x, 0]; return !!zi(e, Ai, Pi, Li, Di) && (!!zi(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], Ai, Pi, Li, Di) && (Ni.crossVectors(Ri, Oi), zi(e = [Ni.x, Ni.y, Ni.z], Ai, Pi, Li, Di))) }, clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Jn), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: function (t) { return Si.copy(t).clamp(this.min, this.max).sub(t).length() }, getBoundingSphere: function (t) { return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(Si).length(), t }, intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, applyMatrix4: function (t) { return this.isEmpty() ? this : (Ti[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ti[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ti[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ti[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ti[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ti[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ti[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ti[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ti), this) }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }); const Fi = new Bi; function Ui(t, e) { this.center = void 0 !== t ? t : new Jn, this.radius = void 0 !== e ? e : -1 } Object.assign(Ui.prototype, { set: function (t, e) { return this.center.copy(t), this.radius = e, this }, setFromPoints: function (t, e) { const n = this.center; void 0 !== e ? n.copy(e) : Fi.setFromPoints(t).getCenter(n); let i = 0; for (let e = 0, r = t.length; e < r; e++)i = Math.max(i, n.distanceToSquared(t[e])); return this.radius = Math.sqrt(i), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.center.copy(t.center), this.radius = t.radius, this }, isEmpty: function () { return this.radius < 0 }, makeEmpty: function () { return this.center.set(0, 0, 0), this.radius = -1, this }, containsPoint: function (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (t) { return t.distanceTo(this.center) - this.radius }, intersectsSphere: function (t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, intersectsBox: function (t) { return t.intersectsSphere(this) }, intersectsPlane: function (t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }, clampPoint: function (t, e) { const n = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Jn), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }, getBoundingBox: function (t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Bi), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) }, applyMatrix4: function (t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this }, translate: function (t) { return this.center.add(t), this }, equals: function (t) { return t.center.equals(this.center) && t.radius === this.radius } }); const Hi = new Jn, Gi = new Jn, ji = new Jn, Vi = new Jn, Wi = new Jn, qi = new Jn, Xi = new Jn; function Yi(t, e) { this.origin = void 0 !== t ? t : new Jn, this.direction = void 0 !== e ? e : new Jn(0, 0, -1) } Object.assign(Yi.prototype, { set: function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Jn), e.copy(this.direction).multiplyScalar(t).add(this.origin) }, lookAt: function (t) { return this.direction.copy(t).sub(this.origin).normalize(), this }, recast: function (t) { return this.origin.copy(this.at(t, Hi)), this }, closestPointToPoint: function (t, e) { void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Jn), e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) }, distanceToPoint: function (t) { return Math.sqrt(this.distanceSqToPoint(t)) }, distanceSqToPoint: function (t) { const e = Hi.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (Hi.copy(this.direction).multiplyScalar(e).add(this.origin), Hi.distanceToSquared(t)) }, distanceSqToSegment: function (t, e, n, i) { Gi.copy(t).add(e).multiplyScalar(.5), ji.copy(e).sub(t).normalize(), Vi.copy(this.origin).sub(Gi); const r = .5 * t.distanceTo(e), o = -this.direction.dot(ji), s = Vi.dot(this.direction), a = -Vi.dot(ji), c = Vi.lengthSq(), l = Math.abs(1 - o * o); let u, h, d, f; if (l > 0) if (h = o * s - a, f = r * l, (u = o * a - s) >= 0) if (h >= -f) if (h <= f) { const t = 1 / l; d = (u *= t) * (u + o * (h *= t) + 2 * s) + h * (o * u + h + 2 * a) + c } else h = r, d = -(u = Math.max(0, -(o * h + s))) * u + h * (h + 2 * a) + c; else h = -r, d = -(u = Math.max(0, -(o * h + s))) * u + h * (h + 2 * a) + c; else h <= -f ? d = -(u = Math.max(0, -(-o * r + s))) * u + (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)) * (h + 2 * a) + c : h <= f ? (u = 0, d = (h = Math.min(Math.max(-r, -a), r)) * (h + 2 * a) + c) : d = -(u = Math.max(0, -(o * r + s))) * u + (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)) * (h + 2 * a) + c; else h = o > 0 ? -r : r, d = -(u = Math.max(0, -(o * h + s))) * u + h * (h + 2 * a) + c; return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(ji).multiplyScalar(h).add(Gi), d }, intersectSphere: function (t, e) { Hi.subVectors(t.center, this.origin); const n = Hi.dot(this.direction), i = Hi.dot(Hi) - n * n, r = t.radius * t.radius; if (i > r) return null; const o = Math.sqrt(r - i), s = n - o, a = n + o; return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e) }, intersectsSphere: function (t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }, distanceToPlane: function (t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null }, intersectPlane: function (t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) }, intersectsPlane: function (t) { const e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 }, intersectBox: function (t, e) { let n, i, r, o, s, a; const c = 1 / this.direction.x, l = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin; return c >= 0 ? (n = (t.min.x - h.x) * c, i = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, i = (t.min.x - h.x) * c), l >= 0 ? (r = (t.min.y - h.y) * l, o = (t.max.y - h.y) * l) : (r = (t.max.y - h.y) * l, o = (t.min.y - h.y) * l), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), u >= 0 ? (s = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (s = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || s > i ? null : ((s > n || n != n) && (n = s), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e))) }, intersectsBox: function (t) { return null !== this.intersectBox(t, Hi) }, intersectTriangle: function (t, e, n, i, r) { Wi.subVectors(e, t), qi.subVectors(n, t), Xi.crossVectors(Wi, qi); let o, s = this.direction.dot(Xi); if (s > 0) { if (i) return null; o = 1 } else { if (!(s < 0)) return null; o = -1, s = -s } Vi.subVectors(this.origin, t); const a = o * this.direction.dot(qi.crossVectors(Vi, qi)); if (a < 0) return null; const c = o * this.direction.dot(Wi.cross(Vi)); if (c < 0) return null; if (a + c > s) return null; const l = -o * Vi.dot(Xi); return l < 0 ? null : this.at(l / s, r) }, applyMatrix4: function (t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }, equals: function (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } }); const Zi = new Jn, Ji = new Jn, Qi = new Fn; function $i(t, e) { this.normal = void 0 !== t ? t : new Jn(1, 0, 0), this.constant = void 0 !== e ? e : 0 } Object.assign($i.prototype, { isPlane: !0, set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: function (t, e, n) { const i = Zi.subVectors(n, e).cross(Ji.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(i, t), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Jn), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }, intersectLine: function (t, e) { void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new Jn); const n = t.delta(Zi), i = this.normal.dot(n); if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0; const r = -(t.start.dot(this.normal) + this.constant) / i; return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start) }, intersectsLine: function (t) { const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end); return e < 0 && n > 0 || n < 0 && e > 0 }, intersectsBox: function (t) { return t.intersectsPlane(this) }, intersectsSphere: function (t) { return t.intersectsPlane(this) }, coplanarPoint: function (t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Jn), t.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function (t, e) { const n = e || Qi.getNormalMatrix(t), i = this.coplanarPoint(Zi).applyMatrix4(t), r = this.normal.applyMatrix3(n).normalize(); return this.constant = -i.dot(r), this }, translate: function (t) { return this.constant -= t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant === this.constant } }); const Ki = new Jn, tr = new Jn, er = new Jn, nr = new Jn, ir = new Jn, rr = new Jn, or = new Jn, sr = new Jn, ar = new Jn, cr = new Jn; function lr(t, e, n) { this.a = void 0 !== t ? t : new Jn, this.b = void 0 !== e ? e : new Jn, this.c = void 0 !== n ? n : new Jn } Object.assign(lr, { getNormal: function (t, e, n, i) { void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Jn), i.subVectors(n, e), Ki.subVectors(t, e), i.cross(Ki); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) }, getBarycoord: function (t, e, n, i, r) { Ki.subVectors(i, e), tr.subVectors(n, e), er.subVectors(t, e); const o = Ki.dot(Ki), s = Ki.dot(tr), a = Ki.dot(er), c = tr.dot(tr), l = tr.dot(er), u = o * c - s * s; if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Jn), 0 === u) return r.set(-2, -1, -1); const h = 1 / u, d = (c * a - s * l) * h, f = (o * l - s * a) * h; return r.set(1 - d - f, f, d) }, containsPoint: function (t, e, n, i) { return lr.getBarycoord(t, e, n, i, nr), nr.x >= 0 && nr.y >= 0 && nr.x + nr.y <= 1 }, getUV: function (t, e, n, i, r, o, s, a) { return this.getBarycoord(t, e, n, i, nr), a.set(0, 0), a.addScaledVector(r, nr.x), a.addScaledVector(o, nr.y), a.addScaledVector(s, nr.z), a }, isFrontFacing: function (t, e, n, i) { return Ki.subVectors(n, e), tr.subVectors(t, e), Ki.cross(tr).dot(i) < 0 } }), Object.assign(lr.prototype, { set: function (t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this }, setFromPointsAndIndices: function (t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, getArea: function () { return Ki.subVectors(this.c, this.b), tr.subVectors(this.a, this.b), .5 * Ki.cross(tr).length() }, getMidpoint: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Jn), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function (t) { return lr.getNormal(this.a, this.b, this.c, t) }, getPlane: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new $i), t.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function (t, e) { return lr.getBarycoord(t, this.a, this.b, this.c, e) }, getUV: function (t, e, n, i, r) { return lr.getUV(t, this.a, this.b, this.c, e, n, i, r) }, containsPoint: function (t) { return lr.containsPoint(t, this.a, this.b, this.c) }, isFrontFacing: function (t) { return lr.isFrontFacing(this.a, this.b, this.c, t) }, intersectsBox: function (t) { return t.intersectsTriangle(this) }, closestPointToPoint: function (t, e) { void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new Jn); const n = this.a, i = this.b, r = this.c; let o, s; ir.subVectors(i, n), rr.subVectors(r, n), sr.subVectors(t, n); const a = ir.dot(sr), c = rr.dot(sr); if (a <= 0 && c <= 0) return e.copy(n); ar.subVectors(t, i); const l = ir.dot(ar), u = rr.dot(ar); if (l >= 0 && u <= l) return e.copy(i); const h = a * u - l * c; if (h <= 0 && a >= 0 && l <= 0) return o = a / (a - l), e.copy(n).addScaledVector(ir, o); cr.subVectors(t, r); const d = ir.dot(cr), f = rr.dot(cr); if (f >= 0 && d <= f) return e.copy(r); const p = d * c - a * f; if (p <= 0 && c >= 0 && f <= 0) return s = c / (c - f), e.copy(n).addScaledVector(rr, s); const m = l * f - d * u; if (m <= 0 && u - l >= 0 && d - f >= 0) return or.subVectors(r, i), s = (u - l) / (u - l + (d - f)), e.copy(i).addScaledVector(or, s); const g = 1 / (m + p + h); return o = p * g, s = h * g, e.copy(n).addScaledVector(ir, o).addScaledVector(rr, s) }, equals: function (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } }); const ur = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, hr = { h: 0, s: 0, l: 0 }, dr = { h: 0, s: 0, l: 0 }; function fr(t, e, n) { return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) } function pr(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t } function mr(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function gr(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } function vr(t, e, n, i, r, o) { this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new Jn, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new fr, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0 } Object.assign(fr.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function (t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }, setScalar: function (t) { return this.r = t, this.g = t, this.b = t, this }, setHex: function (t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, setRGB: function (t, e, n) { return this.r = t, this.g = e, this.b = n, this }, setHSL: function (t, e, n) { if (t = Bn.euclideanModulo(t, 1), e = Bn.clamp(e, 0, 1), n = Bn.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n; else { const i = n <= .5 ? n * (1 + e) : n + e - n * e, r = 2 * n - i; this.r = pr(r, i, t + 1 / 3), this.g = pr(r, i, t), this.b = pr(r, i, t - 1 / 3) } return this }, setStyle: function (t) { function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let n; if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) { let t; const i = n[1], r = n[2]; switch (i) { case "rgb": case "rgba": if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[5]), this; if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[5]), this; break; case "hsl": case "hsla": if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) { const n = parseFloat(t[1]) / 360, i = parseInt(t[2], 10) / 100, r = parseInt(t[3], 10) / 100; return e(t[5]), this.setHSL(n, i, r) } } } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) { const t = n[1], e = t.length; if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this; if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this } return t && t.length > 0 ? this.setColorName(t) : this }, setColorName: function (t) { const e = ur[t]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, copyGammaToLinear: function (t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, copyLinearToGamma: function (t, e) { void 0 === e && (e = 2); const n = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this }, convertGammaToLinear: function (t) { return this.copyGammaToLinear(this, t), this }, convertLinearToGamma: function (t) { return this.copyLinearToGamma(this, t), this }, copySRGBToLinear: function (t) { return this.r = mr(t.r), this.g = mr(t.g), this.b = mr(t.b), this }, copyLinearToSRGB: function (t) { return this.r = gr(t.r), this.g = gr(t.g), this.b = gr(t.b), this }, convertSRGBToLinear: function () { return this.copySRGBToLinear(this), this }, convertLinearToSRGB: function () { return this.copyLinearToSRGB(this), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (t) { void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 }); const e = this.r, n = this.g, i = this.b, r = Math.max(e, n, i), o = Math.min(e, n, i); let s, a; const c = (o + r) / 2; if (o === r) s = 0, a = 0; else { const t = r - o; switch (a = c <= .5 ? t / (r + o) : t / (2 - r - o), r) { case e: s = (n - i) / t + (n < i ? 6 : 0); break; case n: s = (i - e) / t + 2; break; case i: s = (e - n) / t + 4 }s /= 6 } return t.h = s, t.s = a, t.l = c, t }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function (t, e, n) { return this.getHSL(hr), hr.h += t, hr.s += e, hr.l += n, this.setHSL(hr.h, hr.s, hr.l), this }, add: function (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, addColors: function (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, addScalar: function (t) { return this.r += t, this.g += t, this.b += t, this }, sub: function (t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }, multiply: function (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, multiplyScalar: function (t) { return this.r *= t, this.g *= t, this.b *= t, this }, lerp: function (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, lerpHSL: function (t, e) { this.getHSL(hr), t.getHSL(dr); const n = Bn.lerp(hr.h, dr.h, e), i = Bn.lerp(hr.s, dr.s, e), r = Bn.lerp(hr.l, dr.l, e); return this.setHSL(n, i, r), this }, equals: function (t) { return t.r === this.r && t.g === this.g && t.b === this.b }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, fromBufferAttribute: function (t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this }, toJSON: function () { return this.getHex() } }), fr.NAMES = ur, Object.assign(vr.prototype, { clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (let e = 0, n = t.vertexNormals.length; e < n; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (let e = 0, n = t.vertexColors.length; e < n; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } }); let yr = 0; function _r() { Object.defineProperty(this, "id", { value: yr++ }), this.uuid = Bn.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = x, this.side = p, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = D, this.blendDst = N, this.blendEquation = S, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = V, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Tn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = un, this.stencilZFail = un, this.stencilZPass = un, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } function xr(t) { _r.call(this), this.type = "MeshBasicMaterial", this.color = new fr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t) } _r.prototype = Object.assign(Object.create(Dn.prototype), { constructor: _r, isMaterial: !0, onBeforeCompile: function () { }, customProgramCacheKey: function () { return this.onBeforeCompile.toString() }, setValues: function (t) { if (void 0 !== t) for (const e in t) { const n = t[e]; if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue } if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === v; continue } const i = this[e]; void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function i(t) { const e = []; for (const n in t) { const i = t[n]; delete i.metadata, e.push(i) } return e } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== x && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== p && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) { const e = i(t.textures), r = i(t.images); e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r) } return n }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const e = t.clippingPlanes; let n = null; if (null !== e) { const t = e.length; n = new Array(t); for (let i = 0; i !== t; ++i)n[i] = e[i].clone() } return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(_r.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), xr.prototype = Object.create(_r.prototype), xr.prototype.constructor = xr, xr.prototype.isMeshBasicMaterial = !0, xr.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }; const br = new Jn, wr = new zn; function Mr(t, e, n) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = Sn, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Tr(t, e, n) { Mr.call(this, new Int8Array(t), e, n) } function Sr(t, e, n) { Mr.call(this, new Uint8Array(t), e, n) } function Er(t, e, n) { Mr.call(this, new Uint8ClampedArray(t), e, n) } function Ar(t, e, n) { Mr.call(this, new Int16Array(t), e, n) } function Pr(t, e, n) { Mr.call(this, new Uint16Array(t), e, n) } function Lr(t, e, n) { Mr.call(this, new Int32Array(t), e, n) } function Rr(t, e, n) { Mr.call(this, new Uint32Array(t), e, n) } function Or(t, e, n) { Mr.call(this, new Float32Array(t), e, n) } function Cr(t, e, n) { Mr.call(this, new Float64Array(t), e, n) } function Ir() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } function Dr(t) { if (0 === t.length) return -1 / 0; let e = t[0]; for (let n = 1, i = t.length; n < i; ++n)t[n] > e && (e = t[n]); return e } Object.defineProperty(Mr.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(Mr.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this }, copyAt: function (t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let i = 0, r = this.itemSize; i < r; i++)this.array[t + i] = e.array[n + i]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new fr), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b } return this }, copyVector2sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new zn), e[n++] = r.x, e[n++] = r.y } return this }, copyVector3sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Jn), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z } return this }, copyVector4sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Vn), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w } return this }, applyMatrix3: function (t) { if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)wr.fromBufferAttribute(this, e), wr.applyMatrix3(t), this.setXY(e, wr.x, wr.y); else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)br.fromBufferAttribute(this, e), br.applyMatrix3(t), this.setXYZ(e, br.x, br.y, br.z); return this }, applyMatrix4: function (t) { for (let e = 0, n = this.count; e < n; e++)br.x = this.getX(e), br.y = this.getY(e), br.z = this.getZ(e), br.applyMatrix4(t), this.setXYZ(e, br.x, br.y, br.z); return this }, applyNormalMatrix: function (t) { for (let e = 0, n = this.count; e < n; e++)br.x = this.getX(e), br.y = this.getY(e), br.z = this.getZ(e), br.applyNormalMatrix(t), this.setXYZ(e, br.x, br.y, br.z); return this }, transformDirection: function (t) { for (let e = 0, n = this.count; e < n; e++)br.x = this.getX(e), br.y = this.getY(e), br.z = this.getZ(e), br.transformDirection(t), this.setXYZ(e, br.x, br.y, br.z); return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this }, onUpload: function (t) { return this.onUploadCallback = t, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), Tr.prototype = Object.create(Mr.prototype), Tr.prototype.constructor = Tr, Sr.prototype = Object.create(Mr.prototype), Sr.prototype.constructor = Sr, Er.prototype = Object.create(Mr.prototype), Er.prototype.constructor = Er, Ar.prototype = Object.create(Mr.prototype), Ar.prototype.constructor = Ar, Pr.prototype = Object.create(Mr.prototype), Pr.prototype.constructor = Pr, Lr.prototype = Object.create(Mr.prototype), Lr.prototype.constructor = Lr, Rr.prototype = Object.create(Mr.prototype), Rr.prototype.constructor = Rr, Or.prototype = Object.create(Mr.prototype), Or.prototype.constructor = Or, Cr.prototype = Object.create(Mr.prototype), Cr.prototype.constructor = Cr, Object.assign(Ir.prototype, { computeGroups: function (t) { const e = []; let n, i, r = void 0; const o = t.faces; for (i = 0; i < o.length; i++) { const t = o[i]; t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = { start: 3 * i, materialIndex: r }) } void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e }, fromGeometry: function (t) { const e = t.faces, n = t.vertices, i = t.faceVertexUvs, r = i[0] && i[0].length > 0, o = i[1] && i[1].length > 0, s = t.morphTargets, a = s.length; let c; if (a > 0) { c = []; for (let t = 0; t < a; t++)c[t] = { name: s[t].name, data: [] }; this.morphTargets.position = c } const l = t.morphNormals, u = l.length; let h; if (u > 0) { h = []; for (let t = 0; t < u; t++)h[t] = { name: l[t].name, data: [] }; this.morphTargets.normal = h } const d = t.skinIndices, f = t.skinWeights, p = d.length === n.length, m = f.length === n.length; n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (let t = 0; t < e.length; t++) { const g = e[t]; this.vertices.push(n[g.a], n[g.b], n[g.c]); const v = g.vertexNormals; if (3 === v.length) this.normals.push(v[0], v[1], v[2]); else { const t = g.normal; this.normals.push(t, t, t) } const y = g.vertexColors; if (3 === y.length) this.colors.push(y[0], y[1], y[2]); else { const t = g.color; this.colors.push(t, t, t) } if (!0 === r) { const e = i[0][t]; void 0 !== e ? this.uvs.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", t), this.uvs.push(new zn, new zn, new zn)) } if (!0 === o) { const e = i[1][t]; void 0 !== e ? this.uvs2.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", t), this.uvs2.push(new zn, new zn, new zn)) } for (let t = 0; t < a; t++) { const e = s[t].vertices; c[t].data.push(e[g.a], e[g.b], e[g.c]) } for (let e = 0; e < u; e++) { const n = l[e].vertexNormals[t]; h[e].data.push(n.a, n.b, n.c) } p && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), m && this.skinWeights.push(f[g.a], f[g.b], f[g.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this } }); let Nr = 1; const kr = new ri, Br = new wi, zr = new Jn, Fr = new Bi, Ur = new Bi, Hr = new Jn; function Gr() { Object.defineProperty(this, "id", { value: Nr += 2 }), this.uuid = Bn.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } Gr.prototype = Object.assign(Object.create(Dn.prototype), { constructor: Gr, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { Array.isArray(t) ? this.index = new (Dr(t) > 65535 ? Rr : Pr)(t, 1) : this.index = t }, getAttribute: function (t) { return this.attributes[t] }, setAttribute: function (t, e) { return this.attributes[t] = e, this }, deleteAttribute: function (t) { return delete this.attributes[t], this }, addGroup: function (t, e, n) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== n ? n : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix4: function (t) { const e = this.attributes.position; void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const e = (new Fn).getNormalMatrix(t); n.applyNormalMatrix(e), n.needsUpdate = !0 } const i = this.attributes.tangent; return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function (t) { return kr.makeRotationX(t), this.applyMatrix4(kr), this }, rotateY: function (t) { return kr.makeRotationY(t), this.applyMatrix4(kr), this }, rotateZ: function (t) { return kr.makeRotationZ(t), this.applyMatrix4(kr), this }, translate: function (t, e, n) { return kr.makeTranslation(t, e, n), this.applyMatrix4(kr), this }, scale: function (t, e, n) { return kr.makeScale(t, e, n), this.applyMatrix4(kr), this }, lookAt: function (t) { return Br.lookAt(t), Br.updateMatrix(), this.applyMatrix4(Br.matrix), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(zr).negate(), this.translate(zr.x, zr.y, zr.z), this }, setFromObject: function (t) { const e = t.geometry; if (t.isPoints || t.isLine) { const t = new Or(3 * e.vertices.length, 3), n = new Or(3 * e.colors.length, 3); if (this.setAttribute("position", t.copyVector3sArray(e.vertices)), this.setAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) { const t = new Or(e.lineDistances.length, 1); this.setAttribute("lineDistance", t.copyArray(e.lineDistances)) } null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()) } else t.isMesh && e && e.isGeometry && this.fromGeometry(e); return this }, setFromPoints: function (t) { const e = []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new Or(e, 3)), this }, updateFromObject: function (t) { let e = t.geometry; if (t.isMesh) { let t = e.__directGeometry; if (!0 === e.elementsNeedUpdate && (t = void 0, e.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(e); t.verticesNeedUpdate = e.verticesNeedUpdate, t.normalsNeedUpdate = e.normalsNeedUpdate, t.colorsNeedUpdate = e.colorsNeedUpdate, t.uvsNeedUpdate = e.uvsNeedUpdate, t.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = t } if (!0 === e.verticesNeedUpdate) { const t = this.attributes.position; void 0 !== t && (t.copyVector3sArray(e.vertices), t.needsUpdate = !0), e.verticesNeedUpdate = !1 } if (!0 === e.normalsNeedUpdate) { const t = this.attributes.normal; void 0 !== t && (t.copyVector3sArray(e.normals), t.needsUpdate = !0), e.normalsNeedUpdate = !1 } if (!0 === e.colorsNeedUpdate) { const t = this.attributes.color; void 0 !== t && (t.copyColorsArray(e.colors), t.needsUpdate = !0), e.colorsNeedUpdate = !1 } if (e.uvsNeedUpdate) { const t = this.attributes.uv; void 0 !== t && (t.copyVector2sArray(e.uvs), t.needsUpdate = !0), e.uvsNeedUpdate = !1 } if (e.lineDistancesNeedUpdate) { const t = this.attributes.lineDistance; void 0 !== t && (t.copyArray(e.lineDistances), t.needsUpdate = !0), e.lineDistancesNeedUpdate = !1 } return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this }, fromGeometry: function (t) { return t.__directGeometry = (new Ir).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) }, fromDirectGeometry: function (t) { const e = new Float32Array(3 * t.vertices.length); if (this.setAttribute("position", new Mr(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) { const e = new Float32Array(3 * t.normals.length); this.setAttribute("normal", new Mr(e, 3).copyVector3sArray(t.normals)) } if (t.colors.length > 0) { const e = new Float32Array(3 * t.colors.length); this.setAttribute("color", new Mr(e, 3).copyColorsArray(t.colors)) } if (t.uvs.length > 0) { const e = new Float32Array(2 * t.uvs.length); this.setAttribute("uv", new Mr(e, 2).copyVector2sArray(t.uvs)) } if (t.uvs2.length > 0) { const e = new Float32Array(2 * t.uvs2.length); this.setAttribute("uv2", new Mr(e, 2).copyVector2sArray(t.uvs2)) } this.groups = t.groups; for (const e in t.morphTargets) { const n = [], i = t.morphTargets[e]; for (let t = 0, e = i.length; t < e; t++) { const e = i[t], r = new Or(3 * e.data.length, 3); r.name = e.name, n.push(r.copyVector3sArray(e.data)) } this.morphAttributes[e] = n } if (t.skinIndices.length > 0) { const e = new Or(4 * t.skinIndices.length, 4); this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices)) } if (t.skinWeights.length > 0) { const e = new Or(4 * t.skinWeights.length, 4); this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights)) } return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Bi); const t = this.attributes.position, e = this.morphAttributes.position; if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; Fr.setFromBufferAttribute(n), this.morphTargetsRelative ? (Hr.addVectors(this.boundingBox.min, Fr.min), this.boundingBox.expandByPoint(Hr), Hr.addVectors(this.boundingBox.max, Fr.max), this.boundingBox.expandByPoint(Hr)) : (this.boundingBox.expandByPoint(Fr.min), this.boundingBox.expandByPoint(Fr.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Ui); const t = this.attributes.position, e = this.morphAttributes.position; if (t) { const n = this.boundingSphere.center; if (Fr.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; Ur.setFromBufferAttribute(n), this.morphTargetsRelative ? (Hr.addVectors(Fr.min, Ur.min), Fr.expandByPoint(Hr), Hr.addVectors(Fr.max, Ur.max), Fr.expandByPoint(Hr)) : (Fr.expandByPoint(Ur.min), Fr.expandByPoint(Ur.max)) } Fr.getCenter(n); let i = 0; for (let e = 0, r = t.count; e < r; e++)Hr.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Hr)); if (e) for (let r = 0, o = e.length; r < o; r++) { const o = e[r], s = this.morphTargetsRelative; for (let e = 0, r = o.count; e < r; e++)Hr.fromBufferAttribute(o, e), s && (zr.fromBufferAttribute(t, e), Hr.add(zr)), i = Math.max(i, n.distanceToSquared(Hr)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }, computeFaceNormals: function () { }, computeVertexNormals: function () { const t = this.index, e = this.getAttribute("position"); if (void 0 !== e) { let n = this.getAttribute("normal"); if (void 0 === n) n = new Mr(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n); else for (let t = 0, e = n.count; t < e; t++)n.setXYZ(t, 0, 0, 0); const i = new Jn, r = new Jn, o = new Jn, s = new Jn, a = new Jn, c = new Jn, l = new Jn, u = new Jn; if (t) for (let h = 0, d = t.count; h < d; h += 3) { const d = t.getX(h + 0), f = t.getX(h + 1), p = t.getX(h + 2); i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, f), o.fromBufferAttribute(e, p), l.subVectors(o, r), u.subVectors(i, r), l.cross(u), s.fromBufferAttribute(n, d), a.fromBufferAttribute(n, f), c.fromBufferAttribute(n, p), s.add(l), a.add(l), c.add(l), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(f, a.x, a.y, a.z), n.setXYZ(p, c.x, c.y, c.z) } else for (let t = 0, s = e.count; t < s; t += 3)i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), l.subVectors(o, r), u.subVectors(i, r), l.cross(u), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z); this.normalizeNormals(), n.needsUpdate = !0 } }, merge: function (t, e) { if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t); void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const n = this.attributes; for (const i in n) { if (void 0 === t.attributes[i]) continue; const r = n[i].array, o = t.attributes[i], s = o.array, a = o.itemSize * e, c = Math.min(s.length, r.length - a); for (let t = 0, e = a; t < c; t++, e++)r[e] = s[t] } return this }, normalizeNormals: function () { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++)Hr.fromBufferAttribute(t, e), Hr.normalize(), t.setXYZ(e, Hr.x, Hr.y, Hr.z) }, toNonIndexed: function () { function t(t, e) { const n = t.array, i = t.itemSize, r = t.normalized, o = new n.constructor(e.length * i); let s = 0, a = 0; for (let t = 0, r = e.length; t < r; t++) { s = e[t] * i; for (let t = 0; t < i; t++)o[a++] = n[s++] } return new Mr(o, i, r) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; const e = new Gr, n = this.index.array, i = this.attributes; for (const r in i) { const o = t(i[r], n); e.setAttribute(r, o) } const r = this.morphAttributes; for (const i in r) { const o = [], s = r[i]; for (let e = 0, i = s.length; e < i; e++) { const i = t(s[e], n); o.push(i) } e.morphAttributes[i] = o } e.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let t = 0, n = o.length; t < n; t++) { const n = o[t]; e.addGroup(n.start, n.count, n.materialIndex) } return e }, toJSON: function () { const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t } t.data = { attributes: {} }; const e = this.index; null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); const n = this.attributes; for (const e in n) { const i = n[e], r = i.toJSON(t.data); "" !== i.name && (r.name = i.name), t.data.attributes[e] = r } const i = {}; let r = !1; for (const e in this.morphAttributes) { const n = this.morphAttributes[e], o = []; for (let e = 0, i = n.length; e < i; e++) { const i = n[e], r = i.toJSON(t.data); "" !== i.name && (r.name = i.name), o.push(r) } o.length > 0 && (i[e] = o, r = !0) } r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative); const o = this.groups; o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o))); const s = this.boundingSphere; return null !== s && (t.data.boundingSphere = { center: s.center.toArray(), radius: s.radius }), t }, clone: function () { return (new Gr).copy(this) }, copy: function (t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const e = {}; this.name = t.name; const n = t.index; null !== n && this.setIndex(n.clone(e)); const i = t.attributes; for (const t in i) { const n = i[t]; this.setAttribute(t, n.clone(e)) } const r = t.morphAttributes; for (const t in r) { const n = [], i = r[t]; for (let t = 0, r = i.length; t < r; t++)n.push(i[t].clone(e)); this.morphAttributes[t] = n } this.morphTargetsRelative = t.morphTargetsRelative; const o = t.groups; for (let t = 0, e = o.length; t < e; t++) { const e = o[t]; this.addGroup(e.start, e.count, e.materialIndex) } const s = t.boundingBox; null !== s && (this.boundingBox = s.clone()); const a = t.boundingSphere; return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); const jr = new ri, Vr = new Yi, Wr = new Ui, qr = new Jn, Xr = new Jn, Yr = new Jn, Zr = new Jn, Jr = new Jn, Qr = new Jn, $r = new Jn, Kr = new Jn, to = new Jn, eo = new zn, no = new zn, io = new zn, ro = new Jn, oo = new Jn; function so(t, e) { wi.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Gr, this.material = void 0 !== e ? e : new xr, this.updateMorphTargets() } function ao(t, e, n, i, r, o, s, a) { let c; if (null === (c = e.side === m ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, e.side !== g, a))) return null; oo.copy(a), oo.applyMatrix4(t.matrixWorld); const l = n.ray.origin.distanceTo(oo); return l < n.near || l > n.far ? null : { distance: l, point: oo.clone(), object: t } } function co(t, e, n, i, r, o, s, a, c, l, u, h) { qr.fromBufferAttribute(r, l), Xr.fromBufferAttribute(r, u), Yr.fromBufferAttribute(r, h); const d = t.morphTargetInfluences; if (e.morphTargets && o && d) { $r.set(0, 0, 0), Kr.set(0, 0, 0), to.set(0, 0, 0); for (let t = 0, e = o.length; t < e; t++) { const e = d[t], n = o[t]; 0 !== e && (Zr.fromBufferAttribute(n, l), Jr.fromBufferAttribute(n, u), Qr.fromBufferAttribute(n, h), s ? ($r.addScaledVector(Zr, e), Kr.addScaledVector(Jr, e), to.addScaledVector(Qr, e)) : ($r.addScaledVector(Zr.sub(qr), e), Kr.addScaledVector(Jr.sub(Xr), e), to.addScaledVector(Qr.sub(Yr), e))) } qr.add($r), Xr.add(Kr), Yr.add(to) } t.isSkinnedMesh && (t.boneTransform(l, qr), t.boneTransform(u, Xr), t.boneTransform(h, Yr)); const f = ao(t, e, n, i, qr, Xr, Yr, ro); if (f) { a && (eo.fromBufferAttribute(a, l), no.fromBufferAttribute(a, u), io.fromBufferAttribute(a, h), f.uv = lr.getUV(ro, qr, Xr, Yr, eo, no, io, new zn)), c && (eo.fromBufferAttribute(c, l), no.fromBufferAttribute(c, u), io.fromBufferAttribute(c, h), f.uv2 = lr.getUV(ro, qr, Xr, Yr, eo, no, io, new zn)); const t = new vr(l, u, h); lr.getNormal(qr, Xr, Yr, t.normal), f.face = t } return f } so.prototype = Object.assign(Object.create(wi.prototype), { constructor: so, isMesh: !0, copy: function (t) { return wi.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function (t, e) { const n = this.geometry, i = this.material, r = this.matrixWorld; if (void 0 === i) return; if (null === n.boundingSphere && n.computeBoundingSphere(), Wr.copy(n.boundingSphere), Wr.applyMatrix4(r), !1 === t.ray.intersectsSphere(Wr)) return; if (jr.getInverse(r), Vr.copy(t.ray).applyMatrix4(jr), null !== n.boundingBox && !1 === Vr.intersectsBox(n.boundingBox)) return; let o; if (n.isBufferGeometry) { const r = n.index, s = n.attributes.position, a = n.morphAttributes.position, c = n.morphTargetsRelative, l = n.attributes.uv, u = n.attributes.uv2, h = n.groups, d = n.drawRange; if (null !== r) if (Array.isArray(i)) for (let n = 0, f = h.length; n < f; n++) { const f = h[n], p = i[f.materialIndex]; for (let n = Math.max(f.start, d.start), i = Math.min(f.start + f.count, d.start + d.count); n < i; n += 3) { const i = r.getX(n), h = r.getX(n + 1), d = r.getX(n + 2); (o = co(this, p, t, Vr, s, a, c, l, u, i, h, d)) && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = f.materialIndex, e.push(o)) } } else { for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) { const h = r.getX(n), d = r.getX(n + 1), f = r.getX(n + 2); (o = co(this, i, t, Vr, s, a, c, l, u, h, d, f)) && (o.faceIndex = Math.floor(n / 3), e.push(o)) } } else if (void 0 !== s) if (Array.isArray(i)) for (let n = 0, r = h.length; n < r; n++) { const r = h[n], f = i[r.materialIndex]; for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) { (o = co(this, f, t, Vr, s, a, c, l, u, n, n + 1, n + 2)) && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = r.materialIndex, e.push(o)) } } else { for (let n = Math.max(0, d.start), r = Math.min(s.count, d.start + d.count); n < r; n += 3) { (o = co(this, i, t, Vr, s, a, c, l, u, n, n + 1, n + 2)) && (o.faceIndex = Math.floor(n / 3), e.push(o)) } } } else if (n.isGeometry) { const r = Array.isArray(i), s = n.vertices, a = n.faces; let c; const l = n.faceVertexUvs[0]; l.length > 0 && (c = l); for (let n = 0, l = a.length; n < l; n++) { const l = a[n], u = r ? i[l.materialIndex] : i; if (void 0 === u) continue; const h = s[l.a], d = s[l.b], f = s[l.c]; if (o = ao(this, u, t, Vr, h, d, f, ro)) { if (c && c[n]) { const t = c[n]; eo.copy(t[0]), no.copy(t[1]), io.copy(t[2]), o.uv = lr.getUV(ro, h, d, f, eo, no, io, new zn) } o.face = l, o.faceIndex = n, e.push(o) } } } } }); let lo = 0; const uo = new ri, ho = new wi, fo = new Jn; function po() { Object.defineProperty(this, "id", { value: lo += 2 }), this.uuid = Bn.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } po.prototype = Object.assign(Object.create(Dn.prototype), { constructor: po, isGeometry: !0, applyMatrix4: function (t) { const e = (new Fn).getNormalMatrix(t); for (let e = 0, n = this.vertices.length; e < n; e++) { this.vertices[e].applyMatrix4(t) } for (let t = 0, n = this.faces.length; t < n; t++) { const n = this.faces[t]; n.normal.applyMatrix3(e).normalize(); for (let t = 0, i = n.vertexNormals.length; t < i; t++)n.vertexNormals[t].applyMatrix3(e).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: function (t) { return uo.makeRotationX(t), this.applyMatrix4(uo), this }, rotateY: function (t) { return uo.makeRotationY(t), this.applyMatrix4(uo), this }, rotateZ: function (t) { return uo.makeRotationZ(t), this.applyMatrix4(uo), this }, translate: function (t, e, n) { return uo.makeTranslation(t, e, n), this.applyMatrix4(uo), this }, scale: function (t, e, n) { return uo.makeScale(t, e, n), this.applyMatrix4(uo), this }, lookAt: function (t) { return ho.lookAt(t), ho.updateMatrix(), this.applyMatrix4(ho.matrix), this }, fromBufferGeometry: function (t) { const e = this, n = null !== t.index ? t.index : void 0, i = t.attributes; if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this; const r = i.position, o = i.normal, s = i.color, a = i.uv, c = i.uv2; void 0 !== c && (this.faceVertexUvs[1] = []); for (let t = 0; t < r.count; t++)e.vertices.push((new Jn).fromBufferAttribute(r, t)), void 0 !== s && e.colors.push((new fr).fromBufferAttribute(s, t)); function l(t, n, i, r) { const l = void 0 === s ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()], u = new vr(t, n, i, void 0 === o ? [] : [(new Jn).fromBufferAttribute(o, t), (new Jn).fromBufferAttribute(o, n), (new Jn).fromBufferAttribute(o, i)], l, r); e.faces.push(u), void 0 !== a && e.faceVertexUvs[0].push([(new zn).fromBufferAttribute(a, t), (new zn).fromBufferAttribute(a, n), (new zn).fromBufferAttribute(a, i)]), void 0 !== c && e.faceVertexUvs[1].push([(new zn).fromBufferAttribute(c, t), (new zn).fromBufferAttribute(c, n), (new zn).fromBufferAttribute(c, i)]) } const u = t.groups; if (u.length > 0) for (let t = 0; t < u.length; t++) { const e = u[t], i = e.start; for (let t = i, r = i + e.count; t < r; t += 3)void 0 !== n ? l(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex) : l(t, t + 1, t + 2, e.materialIndex) } else if (void 0 !== n) for (let t = 0; t < n.count; t += 3)l(n.getX(t), n.getX(t + 1), n.getX(t + 2)); else for (let t = 0; t < r.count; t += 3)l(t, t + 1, t + 2); return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(fo).negate(), this.translate(fo.x, fo.y, fo.z), this }, normalize: function () { this.computeBoundingSphere(); const t = this.boundingSphere.center, e = this.boundingSphere.radius, n = 0 === e ? 1 : 1 / e, i = new ri; return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this }, computeFaceNormals: function () { const t = new Jn, e = new Jn; for (let n = 0, i = this.faces.length; n < i; n++) { const i = this.faces[n], r = this.vertices[i.a], o = this.vertices[i.b], s = this.vertices[i.c]; t.subVectors(s, o), e.subVectors(r, o), t.cross(e), t.normalize(), i.normal.copy(t) } }, computeVertexNormals: function (t) { void 0 === t && (t = !0); const e = new Array(this.vertices.length); for (let t = 0, n = this.vertices.length; t < n; t++)e[t] = new Jn; if (t) { const t = new Jn, n = new Jn; for (let i = 0, r = this.faces.length; i < r; i++) { const r = this.faces[i], o = this.vertices[r.a], s = this.vertices[r.b], a = this.vertices[r.c]; t.subVectors(a, s), n.subVectors(o, s), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t) } } else { this.computeFaceNormals(); for (let t = 0, n = this.faces.length; t < n; t++) { const n = this.faces[t]; e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal) } } for (let t = 0, n = this.vertices.length; t < n; t++)e[t].normalize(); for (let t = 0, n = this.faces.length; t < n; t++) { const n = this.faces[t], i = n.vertexNormals; 3 === i.length ? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c])) : (i[0] = e[n.a].clone(), i[1] = e[n.b].clone(), i[2] = e[n.c].clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { this.computeFaceNormals(); for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t], n = e.vertexNormals; 3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t]; e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []); for (let t = 0, n = e.vertexNormals.length; t < n; t++)e.__originalVertexNormals[t] ? e.__originalVertexNormals[t].copy(e.vertexNormals[t]) : e.__originalVertexNormals[t] = e.vertexNormals[t].clone() } const t = new po; t.faces = this.faces; for (let e = 0, n = this.morphTargets.length; e < n; e++) { if (!this.morphNormals[e]) { this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = []; const t = this.morphNormals[e].faceNormals, n = this.morphNormals[e].vertexNormals; for (let e = 0, i = this.faces.length; e < i; e++) { const e = new Jn, i = { a: new Jn, b: new Jn, c: new Jn }; t.push(e), n.push(i) } } const n = this.morphNormals[e]; t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals(); for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t], i = n.faceNormals[t], r = n.vertexNormals[t]; i.copy(e.normal), r.a.copy(e.vertexNormals[0]), r.b.copy(e.vertexNormals[1]), r.c.copy(e.vertexNormals[2]) } } for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t]; e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals } }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Bi), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Ui), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (t, e, n) { if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t); let i, r = this.vertices.length, o = this.vertices, s = t.vertices, a = this.faces, c = t.faces, l = this.colors, u = t.colors; void 0 === n && (n = 0), void 0 !== e && (i = (new Fn).getNormalMatrix(e)); for (let t = 0, n = s.length; t < n; t++) { const n = s[t].clone(); void 0 !== e && n.applyMatrix4(e), o.push(n) } for (let t = 0, e = u.length; t < e; t++)l.push(u[t].clone()); for (let t = 0, e = c.length; t < e; t++) { let e, o, s, l = c[t], u = l.vertexNormals, h = l.vertexColors; (e = new vr(l.a + r, l.b + r, l.c + r)).normal.copy(l.normal), void 0 !== i && e.normal.applyMatrix3(i).normalize(); for (let t = 0, n = u.length; t < n; t++)o = u[t].clone(), void 0 !== i && o.applyMatrix3(i).normalize(), e.vertexNormals.push(o); e.color.copy(l.color); for (let t = 0, n = h.length; t < n; t++)s = h[t], e.vertexColors.push(s.clone()); e.materialIndex = l.materialIndex + n, a.push(e) } for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) { const n = t.faceVertexUvs[e]; void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []); for (let t = 0, i = n.length; t < i; t++) { const i = n[t], r = []; for (let t = 0, e = i.length; t < e; t++)r.push(i[t].clone()); this.faceVertexUvs[e].push(r) } } }, mergeMesh: function (t) { t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }, mergeVertices: function () { const t = {}, e = [], n = [], i = Math.pow(10, 4); for (let r = 0, o = this.vertices.length; r < o; r++) { const o = this.vertices[r], s = Math.round(o.x * i) + "_" + Math.round(o.y * i) + "_" + Math.round(o.z * i); void 0 === t[s] ? (t[s] = r, e.push(this.vertices[r]), n[r] = e.length - 1) : n[r] = n[t[s]] } const r = []; for (let t = 0, e = this.faces.length; t < e; t++) { const e = this.faces[t]; e.a = n[e.a], e.b = n[e.b], e.c = n[e.c]; const i = [e.a, e.b, e.c]; for (let e = 0; e < 3; e++)if (i[e] === i[(e + 1) % 3]) { r.push(t); break } } for (let t = r.length - 1; t >= 0; t--) { const e = r[t]; this.faces.splice(e, 1); for (let t = 0, n = this.faceVertexUvs.length; t < n; t++)this.faceVertexUvs[t].splice(e, 1) } const o = this.vertices.length - e.length; return this.vertices = e, o }, setFromPoints: function (t) { this.vertices = []; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; this.vertices.push(new Jn(n.x, n.y, n.z || 0)) } return this }, sortFacesByMaterialIndex: function () { const t = this.faces, e = t.length; for (let n = 0; n < e; n++)t[n]._id = n; t.sort((function (t, e) { return t.materialIndex - e.materialIndex })); const n = this.faceVertexUvs[0], i = this.faceVertexUvs[1]; let r, o; n && n.length === e && (r = []), i && i.length === e && (o = []); for (let s = 0; s < e; s++) { const e = t[s]._id; r && r.push(n[e]), o && o.push(i[e]) } r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o) }, toJSON: function () { const t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t } const e = []; for (let t = 0; t < this.vertices.length; t++) { const n = this.vertices[t]; e.push(n.x, n.y, n.z) } const n = [], i = [], r = {}, o = [], s = {}, a = [], c = {}; for (let t = 0; t < this.faces.length; t++) { const e = this.faces[t], i = !0, r = !1, o = void 0 !== this.faceVertexUvs[0][t], s = e.normal.length() > 0, a = e.vertexNormals.length > 0, c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b, f = e.vertexColors.length > 0; let p = 0; if (p = l(p, 0, 0), p = l(p, 1, i), p = l(p, 2, r), p = l(p, 3, o), p = l(p, 4, s), p = l(p, 5, a), p = l(p, 6, c), p = l(p, 7, f), n.push(p), n.push(e.a, e.b, e.c), n.push(e.materialIndex), o) { const e = this.faceVertexUvs[0][t]; n.push(d(e[0]), d(e[1]), d(e[2])) } if (s && n.push(u(e.normal)), a) { const t = e.vertexNormals; n.push(u(t[0]), u(t[1]), u(t[2])) } if (c && n.push(h(e.color)), f) { const t = e.vertexColors; n.push(h(t[0]), h(t[1]), h(t[2])) } } function l(t, e, n) { return n ? t | 1 << e : t & ~(1 << e) } function u(t) { const e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== r[e] ? r[e] : (r[e] = i.length / 3, i.push(t.x, t.y, t.z), r[e]) } function h(t) { const e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== s[e] ? s[e] : (s[e] = o.length, o.push(t.getHex()), s[e]) } function d(t) { const e = t.x.toString() + t.y.toString(); return void 0 !== c[e] ? c[e] : (c[e] = a.length / 2, a.push(t.x, t.y), c[e]) } return t.data = {}, t.data.vertices = e, t.data.normals = i, o.length > 0 && (t.data.colors = o), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t }, clone: function () { return (new po).copy(this) }, copy: function (t) { this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name; const e = t.vertices; for (let t = 0, n = e.length; t < n; t++)this.vertices.push(e[t].clone()); const n = t.colors; for (let t = 0, e = n.length; t < e; t++)this.colors.push(n[t].clone()); const i = t.faces; for (let t = 0, e = i.length; t < e; t++)this.faces.push(i[t].clone()); for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) { const n = t.faceVertexUvs[e]; void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []); for (let t = 0, i = n.length; t < i; t++) { const i = n[t], r = []; for (let t = 0, e = i.length; t < e; t++) { const e = i[t]; r.push(e.clone()) } this.faceVertexUvs[e].push(r) } } const r = t.morphTargets; for (let t = 0, e = r.length; t < e; t++) { const e = {}; if (e.name = r[t].name, void 0 !== r[t].vertices) { e.vertices = []; for (let n = 0, i = r[t].vertices.length; n < i; n++)e.vertices.push(r[t].vertices[n].clone()) } if (void 0 !== r[t].normals) { e.normals = []; for (let n = 0, i = r[t].normals.length; n < i; n++)e.normals.push(r[t].normals[n].clone()) } this.morphTargets.push(e) } const o = t.morphNormals; for (let t = 0, e = o.length; t < e; t++) { const e = {}; if (void 0 !== o[t].vertexNormals) { e.vertexNormals = []; for (let n = 0, i = o[t].vertexNormals.length; n < i; n++) { const i = o[t].vertexNormals[n], r = {}; r.a = i.a.clone(), r.b = i.b.clone(), r.c = i.c.clone(), e.vertexNormals.push(r) } } if (void 0 !== o[t].faceNormals) { e.faceNormals = []; for (let n = 0, i = o[t].faceNormals.length; n < i; n++)e.faceNormals.push(o[t].faceNormals[n].clone()) } this.morphNormals.push(e) } const s = t.skinWeights; for (let t = 0, e = s.length; t < e; t++)this.skinWeights.push(s[t].clone()); const a = t.skinIndices; for (let t = 0, e = a.length; t < e; t++)this.skinIndices.push(a[t].clone()); const c = t.lineDistances; for (let t = 0, e = c.length; t < e; t++)this.lineDistances.push(c[t]); const l = t.boundingBox; null !== l && (this.boundingBox = l.clone()); const u = t.boundingSphere; return null !== u && (this.boundingSphere = u.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); class mo extends po { constructor(t, e, n, i, r, o) { super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: o }, this.fromBufferGeometry(new go(t, e, n, i, r, o)), this.mergeVertices() } } class go extends Gr { constructor(t = 1, e = 1, n = 1, i = 1, r = 1, o = 1) { super(), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: o }; const s = this; i = Math.floor(i), r = Math.floor(r), o = Math.floor(o); const a = [], c = [], l = [], u = []; let h = 0, d = 0; function f(t, e, n, i, r, o, f, p, m, g, v) { const y = o / m, _ = f / g, x = o / 2, b = f / 2, w = p / 2, M = m + 1, T = g + 1; let S = 0, E = 0; const A = new Jn; for (let o = 0; o < T; o++) { const s = o * _ - b; for (let a = 0; a < M; a++) { const h = a * y - x; A[t] = h * i, A[e] = s * r, A[n] = w, c.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = p > 0 ? 1 : -1, l.push(A.x, A.y, A.z), u.push(a / m), u.push(1 - o / g), S += 1 } } for (let t = 0; t < g; t++)for (let e = 0; e < m; e++) { const n = h + e + M * t, i = h + e + M * (t + 1), r = h + (e + 1) + M * (t + 1), o = h + (e + 1) + M * t; a.push(n, i, o), a.push(i, r, o), E += 6 } s.addGroup(d, E, v), d += E, h += S } f("z", "y", "x", -1, -1, n, e, t, o, r, 0), f("z", "y", "x", 1, -1, n, e, -t, o, r, 1), f("x", "z", "y", 1, 1, t, n, e, i, o, 2), f("x", "z", "y", 1, -1, t, n, -e, i, o, 3), f("x", "y", "z", 1, -1, t, e, n, i, r, 4), f("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Or(c, 3)), this.setAttribute("normal", new Or(l, 3)), this.setAttribute("uv", new Or(u, 2)) } } function vo(t) { const e = {}; for (const n in t) { e[n] = {}; for (const i in t[n]) { const r = t[n][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r } } return e } function yo(t) { const e = {}; for (let n = 0; n < t.length; n++) { const i = vo(t[n]); for (const t in i) e[t] = i[t] } return e } const _o = { clone: vo, merge: yo }; var xo = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", bo = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; function wo(t) { _r.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = xo, this.fragmentShader = bo, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } function Mo() { wi.call(this), this.type = "Camera", this.matrixWorldInverse = new ri, this.projectionMatrix = new ri, this.projectionMatrixInverse = new ri } function To(t, e, n, i) { Mo.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } wo.prototype = Object.create(_r.prototype), wo.prototype.constructor = wo, wo.prototype.isShaderMaterial = !0, wo.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = vo(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this }, wo.prototype.toJSON = function (t) { const e = _r.prototype.toJSON.call(this, t); e.uniforms = {}; for (const n in this.uniforms) { const i = this.uniforms[n].value; i && i.isTexture ? e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid } : i && i.isColor ? e.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? e.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? e.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? e.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? e.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? e.uniforms[n] = { type: "m4", value: i.toArray() } : e.uniforms[n] = { value: i } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; const n = {}; for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0); return Object.keys(n).length > 0 && (e.extensions = n), e }, Mo.prototype = Object.assign(Object.create(wi.prototype), { constructor: Mo, isCamera: !0, copy: function (t, e) { return wi.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Jn), this.updateMatrixWorld(!0); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }, updateMatrixWorld: function (t) { wi.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, updateWorldMatrix: function (t, e) { wi.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }), To.prototype = Object.assign(Object.create(Mo.prototype), { constructor: To, isPerspectiveCamera: !0, copy: function (t, e) { return Mo.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (t) { const e = .5 * this.getFilmHeight() / t; this.fov = 2 * Bn.RAD2DEG * Math.atan(e), this.updateProjectionMatrix() }, getFocalLength: function () { const t = Math.tan(.5 * Bn.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / t }, getEffectiveFOV: function () { return 2 * Bn.RAD2DEG * Math.atan(Math.tan(.5 * Bn.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, n, i, r, o) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { let t = this.near, e = t * Math.tan(.5 * Bn.DEG2RAD * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, r = -.5 * i, o = this.view; if (null !== this.view && this.view.enabled) { const t = o.fullWidth, s = o.fullHeight; r += o.offsetX * i / t, e -= o.offsetY * n / s, i *= o.width / t, n *= o.height / s } const s = this.filmOffset; 0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { const e = wi.prototype.toJSON.call(this, t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } }); const So = 90, Eo = 1; function Ao(t, e, n) { if (wi.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = n; const i = new To(So, Eo, t, e); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Jn(1, 0, 0)), this.add(i); const r = new To(So, Eo, t, e); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Jn(-1, 0, 0)), this.add(r); const o = new To(So, Eo, t, e); o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new Jn(0, 1, 0)), this.add(o); const s = new To(So, Eo, t, e); s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new Jn(0, -1, 0)), this.add(s); const a = new To(So, Eo, t, e); a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new Jn(0, 0, 1)), this.add(a); const c = new To(So, Eo, t, e); c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new Jn(0, 0, -1)), this.add(c), this.update = function (t, e) { null === this.parent && this.updateMatrixWorld(); const l = t.xr.enabled, u = t.getRenderTarget(); t.xr.enabled = !1; const h = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.xr.enabled = l }, this.clear = function (t, e, i, r) { const o = t.getRenderTarget(); for (let o = 0; o < 6; o++)t.setRenderTarget(n, o), t.clear(e, i, r); t.setRenderTarget(o) } } function Po(t, e, n) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), Wn.call(this, t, t, e) } function Lo(t, e, n, i, r, o, s, a, c, l, u, h) { jn.call(this, null, o, s, a, c, l, i, r, u, h), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = void 0 !== c ? c : pt, this.minFilter = void 0 !== l ? l : pt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } Ao.prototype = Object.create(wi.prototype), Ao.prototype.constructor = Ao, Po.prototype = Object.create(Wn.prototype), Po.prototype.constructor = Po, Po.prototype.isWebGLCubeRenderTarget = !0, Po.prototype.fromEquirectangularTexture = function (t, e) { this.texture.type = e.type, this.texture.format = zt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter; const n = new Mi, i = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t", fragmentShader: "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t" }, r = new wo({ name: "CubemapFromEquirect", uniforms: vo(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: m, blending: _ }); r.uniforms.tEquirect.value = e; const o = new so(new go(5, 5, 5), r); return n.add(o), new Ao(1, 10, this).update(t, n), o.geometry.dispose(), o.material.dispose(), this }, Lo.prototype = Object.create(jn.prototype), Lo.prototype.constructor = Lo, Lo.prototype.isDataTexture = !0; const Ro = new Ui, Oo = new Jn; function Co(t, e, n, i, r, o) { this.planes = [void 0 !== t ? t : new $i, void 0 !== e ? e : new $i, void 0 !== n ? n : new $i, void 0 !== i ? i : new $i, void 0 !== r ? r : new $i, void 0 !== o ? o : new $i] } Object.assign(Co.prototype, { set: function (t, e, n, i, r, o) { const s = this.planes; return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(o), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { const e = this.planes; for (let n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this }, setFromProjectionMatrix: function (t) { const e = this.planes, n = t.elements, i = n[0], r = n[1], o = n[2], s = n[3], a = n[4], c = n[5], l = n[6], u = n[7], h = n[8], d = n[9], f = n[10], p = n[11], m = n[12], g = n[13], v = n[14], y = n[15]; return e[0].setComponents(s - i, u - a, p - h, y - m).normalize(), e[1].setComponents(s + i, u + a, p + h, y + m).normalize(), e[2].setComponents(s + r, u + c, p + d, y + g).normalize(), e[3].setComponents(s - r, u - c, p - d, y - g).normalize(), e[4].setComponents(s - o, u - l, p - f, y - v).normalize(), e[5].setComponents(s + o, u + l, p + f, y + v).normalize(), this }, intersectsObject: function (t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), Ro.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ro) }, intersectsSprite: function (t) { return Ro.center.set(0, 0, 0), Ro.radius = .7071067811865476, Ro.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ro) }, intersectsSphere: function (t) { const e = this.planes, n = t.center, i = -t.radius; for (let t = 0; t < 6; t++) { if (e[t].distanceToPoint(n) < i) return !1 } return !0 }, intersectsBox: function (t) { const e = this.planes; for (let n = 0; n < 6; n++) { const i = e[n]; if (Oo.x = i.normal.x > 0 ? t.max.x : t.min.x, Oo.y = i.normal.y > 0 ? t.max.y : t.min.y, Oo.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Oo) < 0) return !1 } return !0 }, containsPoint: function (t) { const e = this.planes; for (let n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1; return !0 } }); const Io = { common: { diffuse: { value: new fr(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Fn }, uv2Transform: { value: new Fn }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new zn(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new fr(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new fr(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Fn } }, sprite: { diffuse: { value: new fr(15658734) }, opacity: { value: 1 }, center: { value: new zn(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Fn } } }; function Do() { let t = null, e = !1, n = null, i = null; function r(e, o) { n(e, o), i = t.requestAnimationFrame(r) } return { start: function () { !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0) }, stop: function () { t.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function (t) { n = t }, setContext: function (e) { t = e } } } function No(t, e) { const n = e.isWebGL2, i = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), i.get(t) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); const n = i.get(e); n && (t.deleteBuffer(n.buffer), i.delete(e)) }, update: function (e, r) { e.isInterleavedBufferAttribute && (e = e.data); const o = i.get(e); void 0 === o ? i.set(e, function (e, n) { const i = e.array, r = e.usage, o = t.createBuffer(); t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback(); let s = 5126; return i instanceof Float32Array ? s = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? s = 5123 : i instanceof Int16Array ? s = 5122 : i instanceof Uint32Array ? s = 5125 : i instanceof Int32Array ? s = 5124 : i instanceof Int8Array ? s = 5120 : i instanceof Uint8Array && (s = 5121), { buffer: o, type: s, bytesPerElement: i.BYTES_PER_ELEMENT, version: e.version } }(e, r)) : o.version < e.version && (!function (e, i, r) { const o = i.array, s = i.updateRange; t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1) }(o.buffer, e, r), o.version = e.version) } } } function ko(t, e, n, i) { po.call(this), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }, this.fromBufferGeometry(new Bo(t, e, n, i)), this.mergeVertices() } function Bo(t, e, n, i) { Gr.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }; const r = (t = t || 1) / 2, o = (e = e || 1) / 2, s = Math.floor(n) || 1, a = Math.floor(i) || 1, c = s + 1, l = a + 1, u = t / s, h = e / a, d = [], f = [], p = [], m = []; for (let t = 0; t < l; t++) { const e = t * h - o; for (let n = 0; n < c; n++) { const i = n * u - r; f.push(i, -e, 0), p.push(0, 0, 1), m.push(n / s), m.push(1 - t / a) } } for (let t = 0; t < a; t++)for (let e = 0; e < s; e++) { const n = e + c * t, i = e + c * (t + 1), r = e + 1 + c * (t + 1), o = e + 1 + c * t; d.push(n, i, o), d.push(i, r, o) } this.setIndex(d), this.setAttribute("position", new Or(f, 3)), this.setAttribute("normal", new Or(p, 3)), this.setAttribute("uv", new Or(m, 2)) } ko.prototype = Object.create(po.prototype), ko.prototype.constructor = ko, Bo.prototype = Object.create(Gr.prototype), Bo.prototype.constructor = Bo; const zo = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, Fo = { basic: { uniforms: yo([Io.common, Io.specularmap, Io.envmap, Io.aomap, Io.lightmap, Io.fog]), vertexShader: zo.meshbasic_vert, fragmentShader: zo.meshbasic_frag }, lambert: { uniforms: yo([Io.common, Io.specularmap, Io.envmap, Io.aomap, Io.lightmap, Io.emissivemap, Io.fog, Io.lights, { emissive: { value: new fr(0) } }]), vertexShader: zo.meshlambert_vert, fragmentShader: zo.meshlambert_frag }, phong: { uniforms: yo([Io.common, Io.specularmap, Io.envmap, Io.aomap, Io.lightmap, Io.emissivemap, Io.bumpmap, Io.normalmap, Io.displacementmap, Io.fog, Io.lights, { emissive: { value: new fr(0) }, specular: { value: new fr(1118481) }, shininess: { value: 30 } }]), vertexShader: zo.meshphong_vert, fragmentShader: zo.meshphong_frag }, standard: { uniforms: yo([Io.common, Io.envmap, Io.aomap, Io.lightmap, Io.emissivemap, Io.bumpmap, Io.normalmap, Io.displacementmap, Io.roughnessmap, Io.metalnessmap, Io.fog, Io.lights, { emissive: { value: new fr(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: zo.meshphysical_vert, fragmentShader: zo.meshphysical_frag }, toon: { uniforms: yo([Io.common, Io.aomap, Io.lightmap, Io.emissivemap, Io.bumpmap, Io.normalmap, Io.displacementmap, Io.gradientmap, Io.fog, Io.lights, { emissive: { value: new fr(0) } }]), vertexShader: zo.meshtoon_vert, fragmentShader: zo.meshtoon_frag }, matcap: { uniforms: yo([Io.common, Io.bumpmap, Io.normalmap, Io.displacementmap, Io.fog, { matcap: { value: null } }]), vertexShader: zo.meshmatcap_vert, fragmentShader: zo.meshmatcap_frag }, points: { uniforms: yo([Io.points, Io.fog]), vertexShader: zo.points_vert, fragmentShader: zo.points_frag }, dashed: { uniforms: yo([Io.common, Io.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: zo.linedashed_vert, fragmentShader: zo.linedashed_frag }, depth: { uniforms: yo([Io.common, Io.displacementmap]), vertexShader: zo.depth_vert, fragmentShader: zo.depth_frag }, normal: { uniforms: yo([Io.common, Io.bumpmap, Io.normalmap, Io.displacementmap, { opacity: { value: 1 } }]), vertexShader: zo.normal_vert, fragmentShader: zo.normal_frag }, sprite: { uniforms: yo([Io.sprite, Io.fog]), vertexShader: zo.sprite_vert, fragmentShader: zo.sprite_frag }, background: { uniforms: { uvTransform: { value: new Fn }, t2D: { value: null } }, vertexShader: zo.background_vert, fragmentShader: zo.background_frag }, cube: { uniforms: yo([Io.envmap, { opacity: { value: 1 } }]), vertexShader: zo.cube_vert, fragmentShader: zo.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: zo.equirect_vert, fragmentShader: zo.equirect_frag }, distanceRGBA: { uniforms: yo([Io.common, Io.displacementmap, { referencePosition: { value: new Jn }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: zo.distanceRGBA_vert, fragmentShader: zo.distanceRGBA_frag }, shadow: { uniforms: yo([Io.lights, Io.fog, { color: { value: new fr(0) }, opacity: { value: 1 } }]), vertexShader: zo.shadow_vert, fragmentShader: zo.shadow_frag } }; function Uo(t, e, n, i) { const r = new fr(0); let o, s, a = 0, c = null, l = 0, u = null; function h(t, n) { e.buffers.color.setClear(t.r, t.g, t.b, n, i) } return { getClearColor: function () { return r }, setClearColor: function (t, e) { r.set(t), h(r, a = void 0 !== e ? e : 1) }, getClearAlpha: function () { return a }, setClearAlpha: function (t) { h(r, a = t) }, render: function (e, i, d, f) { let g = !0 === i.isScene ? i.background : null; const v = t.xr, y = v.getSession && v.getSession(); if (y && "additive" === y.environmentBlendMode && (g = null), null === g ? h(r, a) : g && g.isColor && (h(g, 1), f = !0), (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), g && (g.isCubeTexture || g.isWebGLCubeRenderTarget || g.mapping === lt)) { void 0 === s && ((s = new so(new go(1, 1, 1), new wo({ name: "BackgroundCubeMaterial", uniforms: vo(Fo.cube.uniforms), vertexShader: Fo.cube.vertexShader, fragmentShader: Fo.cube.fragmentShader, side: m, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), s.geometry.deleteAttribute("uv"), s.onBeforeRender = function (t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(s.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), n.update(s)); const i = g.isWebGLCubeRenderTarget ? g.texture : g; s.material.uniforms.envMap.value = i, s.material.uniforms.flipEnvMap.value = i.isCubeTexture ? -1 : 1, c === g && l === i.version && u === t.toneMapping || (s.material.needsUpdate = !0, c = g, l = i.version, u = t.toneMapping), e.unshift(s, s.geometry, s.material, 0, 0, null) } else g && g.isTexture && (void 0 === o && ((o = new so(new Bo(2, 2), new wo({ name: "BackgroundMaterial", uniforms: vo(Fo.background.uniforms), vertexShader: Fo.background.vertexShader, fragmentShader: Fo.background.fragmentShader, side: p, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.t2D.value } }), n.update(o)), o.material.uniforms.t2D.value = g, !0 === g.matrixAutoUpdate && g.updateMatrix(), o.material.uniforms.uvTransform.value.copy(g.matrix), c === g && l === g.version && u === t.toneMapping || (o.material.needsUpdate = !0, c = g, l = g.version, u = t.toneMapping), e.unshift(o, o.geometry, o.material, 0, 0, null)) } } } function Ho(t, e, n, i) { const r = t.getParameter(34921), o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), s = i.isWebGL2 || null !== o, a = {}, c = d(null); let l = c; function u(e) { return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e) } function h(e) { return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e) } function d(t) { const e = [], n = [], i = []; for (let t = 0; t < r; t++)e[t] = 0, n[t] = 0, i[t] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: i, object: t, attributes: {} } } function f() { const t = l.newAttributes; for (let e = 0, n = t.length; e < n; e++)t[e] = 0 } function p(t) { m(t, 0) } function m(n, r) { const o = l.newAttributes, s = l.enabledAttributes, a = l.attributeDivisors; if (o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== r) { (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r } } function g() { const e = l.newAttributes, n = l.enabledAttributes; for (let i = 0, r = n.length; i < r; i++)n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0) } function v(e, n, r, o, s, a) { !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, s, a) } function y() { _(), l !== c && u((l = c).object) } function _() { c.geometry = null, c.program = null, c.wireframe = !1 } return { setup: function (r, c, h, y, _) { let x = !1; if (s) { const e = function (e, n, r) { const s = !0 === r.wireframe; let c = a[e.id]; void 0 === c && (c = {}, a[e.id] = c); let l = c[n.id]; void 0 === l && (l = {}, c[n.id] = l); let u = l[s]; void 0 === u && (u = d(i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), l[s] = u); return u }(y, h, c); l !== e && u((l = e).object), (x = function (t) { const e = l.attributes, n = t.attributes; if (Object.keys(e).length !== Object.keys(n).length) return !0; for (const t in n) { const i = e[t], r = n[t]; if (i.attribute !== r) return !0; if (i.data !== r.data) return !0 } return !1 }(y)) && function (t) { const e = {}, n = t.attributes; for (const t in n) { const i = n[t], r = {}; r.attribute = i, i.data && (r.data = i.data), e[t] = r } l.attributes = e }(y) } else { const t = !0 === c.wireframe; l.geometry === y.id && l.program === h.id && l.wireframe === t || (l.geometry = y.id, l.program = h.id, l.wireframe = t, x = !0) } !0 === r.isInstancedMesh && (x = !0), null !== _ && n.update(_, 34963), x && (!function (r, o, s, a) { if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return; f(); const c = a.attributes, l = s.getAttributes(), u = o.defaultAttributeValues; for (const e in l) { const i = l[e]; if (i >= 0) { const o = c[e]; if (void 0 !== o) { const e = o.normalized, r = o.itemSize, s = n.get(o); if (void 0 === s) continue; const c = s.buffer, l = s.type, u = s.bytesPerElement; if (o.isInterleavedBufferAttribute) { const n = o.data, s = n.stride, h = o.offset; n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : p(i), t.bindBuffer(34962, c), v(i, r, l, e, s * u, h * u) } else o.isInstancedBufferAttribute ? (m(i, o.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : p(i), t.bindBuffer(34962, c), v(i, r, l, e, 0, 0) } else if ("instanceMatrix" === e) { const e = n.get(r.instanceMatrix); if (void 0 === e) continue; const o = e.buffer, s = e.type; m(i + 0, 1), m(i + 1, 1), m(i + 2, 1), m(i + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48) } else if (void 0 !== u) { const n = u[e]; if (void 0 !== n) switch (n.length) { case 2: t.vertexAttrib2fv(i, n); break; case 3: t.vertexAttrib3fv(i, n); break; case 4: t.vertexAttrib4fv(i, n); break; default: t.vertexAttrib1fv(i, n) } } } } g() }(r, c, h, y), null !== _ && t.bindBuffer(34963, n.get(_).buffer)) }, reset: y, resetDefaultState: _, dispose: function () { y(); for (const t in a) { const e = a[t]; for (const t in e) { const n = e[t]; for (const t in n) h(n[t].object), delete n[t]; delete e[t] } delete a[t] } }, releaseStatesOfGeometry: function (t) { if (void 0 === a[t.id]) return; const e = a[t.id]; for (const t in e) { const n = e[t]; for (const t in n) h(n[t].object), delete n[t]; delete e[t] } delete a[t.id] }, releaseStatesOfProgram: function (t) { for (const e in a) { const n = a[e]; if (void 0 === n[t.id]) continue; const i = n[t.id]; for (const t in i) h(i[t].object), delete i[t]; delete n[t.id] } }, initAttributes: f, enableAttribute: p, disableUnusedAttributes: g } } function Go(t, e, n, i) { const r = i.isWebGL2; let o; this.setMode = function (t) { o = t }, this.render = function (e, i) { t.drawArrays(o, e, i), n.update(i, o, 1) }, this.renderInstances = function (i, s, a) { if (0 === a) return; let c, l; if (r) c = t, l = "drawArraysInstanced"; else if (l = "drawArraysInstancedANGLE", null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); c[l](o, i, s, a), n.update(s, o, a) } } function jo(t, e, n) { let i; function r(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let s = void 0 !== n.precision ? n.precision : "highp"; const a = r(s); a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a); const c = !0 === n.logarithmicDepthBuffer, l = t.getParameter(34930), u = t.getParameter(35660), h = t.getParameter(3379), d = t.getParameter(34076), f = t.getParameter(34921), p = t.getParameter(36347), m = t.getParameter(36348), g = t.getParameter(36349), v = u > 0, y = o || !!e.get("OES_texture_float"); return { isWebGL2: o, getMaxAnisotropy: function () { if (void 0 !== i) return i; const n = e.get("EXT_texture_filter_anisotropic"); return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: r, precision: s, logarithmicDepthBuffer: c, maxTextures: l, maxVertexTextures: u, maxTextureSize: h, maxCubemapSize: d, maxAttributes: f, maxVertexUniforms: p, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: v, floatFragmentTextures: y, floatVertexTextures: v && y, maxSamples: o ? t.getParameter(36183) : 0 } } function Vo() { const t = this; let e = null, n = 0, i = !1, r = !1; const o = new $i, s = new Fn, a = { value: null, needsUpdate: !1 }; function c() { a.value !== e && (a.value = e, a.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0 } function l(e, n, i, r) { let c = null !== e ? e.length : 0, l = null; if (0 !== c) { if (l = a.value, !0 !== r || null === l) { const t = i + 4 * c, r = n.matrixWorldInverse; s.getNormalMatrix(r), (null === l || l.length < t) && (l = new Float32Array(t)); for (let t = 0, n = i; t !== c; ++t, n += 4)o.copy(e[t]).applyMatrix4(r, s), o.normal.toArray(l, n), l[n + 3] = o.constant } a.value = l, a.needsUpdate = !0 } return t.numPlanes = c, t.numIntersection = 0, l } this.uniform = a, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, r, o) { const s = 0 !== t.length || r || 0 !== n || i; return i = r, e = l(t, o, 0), n = t.length, s }, this.beginShadows = function () { r = !0, l(null) }, this.endShadows = function () { r = !1, c() }, this.setState = function (t, o, s, u, h, d) { if (!i || null === t || 0 === t.length || r && !s) r ? l(null) : c(); else { const i = r ? 0 : n, s = 4 * i; let c = h.clippingState || null; a.value = c, c = l(t, u, s, d); for (let t = 0; t !== s; ++t)c[t] = e[t]; h.clippingState = c, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += i } } } function Wo(t) { const e = {}; return { has: function (n) { if (void 0 !== e[n]) return e[n]; let i; switch (n) { case "WEBGL_depth_texture": i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = t.getExtension(n) }return e[n] = i, !!i }, get: function (t) { return this.has(t) || console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e[t] } } } function qo(t, e, n, i) { const r = new WeakMap, o = new WeakMap; function s(t) { const a = t.target, c = r.get(a); null !== c.index && e.remove(c.index); for (const t in c.attributes) e.remove(c.attributes[t]); a.removeEventListener("dispose", s), r.delete(a); const l = o.get(c); l && (e.remove(l), o.delete(c)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries-- } function a(t) { const n = [], i = t.index, r = t.attributes.position; let s = 0; if (null !== i) { const t = i.array; s = i.version; for (let e = 0, i = t.length; e < i; e += 3) { const i = t[e + 0], r = t[e + 1], o = t[e + 2]; n.push(i, r, r, o, o, i) } } else { const t = r.array; s = r.version; for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) { const t = e + 0, i = e + 1, r = e + 2; n.push(t, i, i, r, r, t) } } const a = new (Dr(n) > 65535 ? Rr : Pr)(n, 1); a.version = s; const c = o.get(t); c && e.remove(c), o.set(t, a) } return { get: function (t, e) { let i = r.get(e); return i || (e.addEventListener("dispose", s), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Gr).setFromObject(t)), i = e._bufferGeometry), r.set(e, i), n.memory.geometries++, i) }, update: function (t) { const n = t.attributes; for (const t in n) e.update(n[t], 34962); const i = t.morphAttributes; for (const t in i) { const n = i[t]; for (let t = 0, i = n.length; t < i; t++)e.update(n[t], 34962) } }, getWireframeAttribute: function (t) { const e = o.get(t); if (e) { const n = t.index; null !== n && e.version < n.version && a(t) } else a(t); return o.get(t) } } } function Xo(t, e, n, i) { const r = i.isWebGL2; let o, s, a; this.setMode = function (t) { o = t }, this.setIndex = function (t) { s = t.type, a = t.bytesPerElement }, this.render = function (e, i) { t.drawElements(o, i, s, e * a), n.update(i, o, 1) }, this.renderInstances = function (i, c, l) { if (0 === l) return; let u, h; if (r) u = t, h = "drawElementsInstanced"; else if (h = "drawElementsInstancedANGLE", null === (u = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); u[h](o, c, s, i * a, l), n.update(c, o, l) } } function Yo(t) { const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, n, i) { switch (e.calls++, n) { case 4: e.triangles += i * (t / 3); break; case 1: e.lines += i * (t / 2); break; case 3: e.lines += i * (t - 1); break; case 2: e.lines += i * t; break; case 0: e.points += i * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function Zo(t, e) { return t[0] - e[0] } function Jo(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function Qo(t) { const e = {}, n = new Float32Array(8), i = []; for (let t = 0; t < 8; t++)i[t] = [t, 0]; return { update: function (r, o, s, a) { const c = r.morphTargetInfluences, l = void 0 === c ? 0 : c.length; let u = e[o.id]; if (void 0 === u) { u = []; for (let t = 0; t < l; t++)u[t] = [t, 0]; e[o.id] = u } for (let t = 0; t < l; t++) { const e = u[t]; e[0] = t, e[1] = c[t] } u.sort(Jo); for (let t = 0; t < 8; t++)t < l && u[t][1] ? (i[t][0] = u[t][0], i[t][1] = u[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0); i.sort(Zo); const h = s.morphTargets && o.morphAttributes.position, d = s.morphNormals && o.morphAttributes.normal; let f = 0; for (let t = 0; t < 8; t++) { const e = i[t], r = e[0], s = e[1]; r !== Number.MAX_SAFE_INTEGER && s ? (h && o.getAttribute("morphTarget" + t) !== h[r] && o.setAttribute("morphTarget" + t, h[r]), d && o.getAttribute("morphNormal" + t) !== d[r] && o.setAttribute("morphNormal" + t, d[r]), n[t] = s, f += s) : (h && void 0 !== o.getAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), d && void 0 !== o.getAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), n[t] = 0) } const p = o.morphTargetsRelative ? 1 : 1 - f; a.getUniforms().setValue(t, "morphTargetBaseInfluence", p), a.getUniforms().setValue(t, "morphTargetInfluences", n) } } } function $o(t, e, n, i) { let r = new WeakMap; return { update: function (t) { const o = i.render.frame, s = t.geometry, a = e.get(t, s); return r.get(a) !== o && (s.isGeometry && a.updateFromObject(t), e.update(a), r.set(a, o)), t.isInstancedMesh && n.update(t.instanceMatrix, 34962), a }, dispose: function () { r = new WeakMap } } } function Ko(t, e, n, i, r, o, s, a, c, l) { t = void 0 !== t ? t : [], e = void 0 !== e ? e : ot, s = void 0 !== s ? s : Bt, jn.call(this, t, e, n, i, r, o, s, a, c, l), this.flipY = !1 } function ts(t, e, n, i) { jn.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: i || 1 }, this.magFilter = pt, this.minFilter = pt, this.wrapR = dt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } function es(t, e, n, i) { jn.call(this, null), this.image = { data: t || null, width: e || 1, height: n || 1, depth: i || 1 }, this.magFilter = pt, this.minFilter = pt, this.wrapR = dt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } Fo.physical = { uniforms: yo([Fo.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new zn(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new fr(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: zo.meshphysical_vert, fragmentShader: zo.meshphysical_frag }, Ko.prototype = Object.create(jn.prototype), Ko.prototype.constructor = Ko, Ko.prototype.isCubeTexture = !0, Object.defineProperty(Ko.prototype, "images", { get: function () { return this.image }, set: function (t) { this.image = t } }), ts.prototype = Object.create(jn.prototype), ts.prototype.constructor = ts, ts.prototype.isDataTexture2DArray = !0, es.prototype = Object.create(jn.prototype), es.prototype.constructor = es, es.prototype.isDataTexture3D = !0; const ns = new jn, is = new ts, rs = new es, os = new Ko, ss = [], as = [], cs = new Float32Array(16), ls = new Float32Array(9), us = new Float32Array(4); function hs(t, e, n) { const i = t[0]; if (i <= 0 || i > 0) return t; let r = e * n, o = ss[r]; if (void 0 === o && (o = new Float32Array(r), ss[r] = o), 0 !== e) { i.toArray(o, 0); for (let i = 1, r = 0; i !== e; ++i)r += n, t[i].toArray(o, r) } return o } function ds(t, e) { if (t.length !== e.length) return !1; for (let n = 0, i = t.length; n < i; n++)if (t[n] !== e[n]) return !1; return !0 } function fs(t, e) { for (let n = 0, i = e.length; n < i; n++)t[n] = e[n] } function ps(t, e) { let n = as[e]; void 0 === n && (n = new Int32Array(e), as[e] = n); for (let i = 0; i !== e; ++i)n[i] = t.allocateTextureUnit(); return n } function ms(t, e) { const n = this.cache; n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e) } function gs(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (ds(n, e)) return; t.uniform2fv(this.addr, e), fs(n, e) } } function vs(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else { if (ds(n, e)) return; t.uniform3fv(this.addr, e), fs(n, e) } } function ys(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (ds(n, e)) return; t.uniform4fv(this.addr, e), fs(n, e) } } function _s(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (ds(n, e)) return; t.uniformMatrix2fv(this.addr, !1, e), fs(n, e) } else { if (ds(n, i)) return; us.set(i), t.uniformMatrix2fv(this.addr, !1, us), fs(n, i) } } function xs(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (ds(n, e)) return; t.uniformMatrix3fv(this.addr, !1, e), fs(n, e) } else { if (ds(n, i)) return; ls.set(i), t.uniformMatrix3fv(this.addr, !1, ls), fs(n, i) } } function bs(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (ds(n, e)) return; t.uniformMatrix4fv(this.addr, !1, e), fs(n, e) } else { if (ds(n, i)) return; cs.set(i), t.uniformMatrix4fv(this.addr, !1, cs), fs(n, i) } } function ws(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || ns, r) } function Ms(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || is, r) } function Ts(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || rs, r) } function Ss(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || os, r) } function Es(t, e) { const n = this.cache; n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e) } function As(t, e) { const n = this.cache; ds(n, e) || (t.uniform2iv(this.addr, e), fs(n, e)) } function Ps(t, e) { const n = this.cache; ds(n, e) || (t.uniform3iv(this.addr, e), fs(n, e)) } function Ls(t, e) { const n = this.cache; ds(n, e) || (t.uniform4iv(this.addr, e), fs(n, e)) } function Rs(t, e) { const n = this.cache; n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e) } function Os(t, e) { t.uniform1fv(this.addr, e) } function Cs(t, e) { t.uniform1iv(this.addr, e) } function Is(t, e) { t.uniform2iv(this.addr, e) } function Ds(t, e) { t.uniform3iv(this.addr, e) } function Ns(t, e) { t.uniform4iv(this.addr, e) } function ks(t, e) { const n = hs(e, this.size, 2); t.uniform2fv(this.addr, n) } function Bs(t, e) { const n = hs(e, this.size, 3); t.uniform3fv(this.addr, n) } function zs(t, e) { const n = hs(e, this.size, 4); t.uniform4fv(this.addr, n) } function Fs(t, e) { const n = hs(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, n) } function Us(t, e) { const n = hs(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, n) } function Hs(t, e) { const n = hs(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, n) } function Gs(t, e, n) { const i = e.length, r = ps(n, i); t.uniform1iv(this.addr, r); for (let t = 0; t !== i; ++t)n.safeSetTexture2D(e[t] || ns, r[t]) } function js(t, e, n) { const i = e.length, r = ps(n, i); t.uniform1iv(this.addr, r); for (let t = 0; t !== i; ++t)n.safeSetTextureCube(e[t] || os, r[t]) } function Vs(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return ms; case 35664: return gs; case 35665: return vs; case 35666: return ys; case 35674: return _s; case 35675: return xs; case 35676: return bs; case 5124: case 35670: return Es; case 35667: case 35671: return As; case 35668: case 35672: return Ps; case 35669: case 35673: return Ls; case 5125: return Rs; case 35678: case 36198: case 36298: case 36306: case 35682: return ws; case 35679: case 36299: case 36307: return Ts; case 35680: case 36300: case 36308: case 36293: return Ss; case 36289: case 36303: case 36311: case 36292: return Ms } }(e.type) } function Ws(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return Os; case 35664: return ks; case 35665: return Bs; case 35666: return zs; case 35674: return Fs; case 35675: return Us; case 35676: return Hs; case 5124: case 35670: return Cs; case 35667: case 35671: return Is; case 35668: case 35672: return Ds; case 35669: case 35673: return Ns; case 35678: case 36198: case 36298: case 36306: case 35682: return Gs; case 35680: case 36300: case 36308: case 36293: return js } }(e.type) } function qs(t) { this.id = t, this.seq = [], this.map = {} } Ws.prototype.updateCache = function (t) { let e = this.cache; t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), fs(e, t) }, qs.prototype.setValue = function (t, e, n) { const i = this.seq; for (let r = 0, o = i.length; r !== o; ++r) { const o = i[r]; o.setValue(t, e[o.id], n) } }; const Xs = /([\w\d_]+)(\])?(\[|\.)?/g; function Ys(t, e) { t.seq.push(e), t.map[e.id] = e } function Zs(t, e, n) { const i = t.name, r = i.length; for (Xs.lastIndex = 0; ;) { const o = Xs.exec(i), s = Xs.lastIndex; let a = o[1], c = "]" === o[2], l = o[3]; if (c && (a |= 0), void 0 === l || "[" === l && s + 2 === r) { Ys(n, void 0 === l ? new Vs(a, t, e) : new Ws(a, t, e)); break } { let t = n.map[a]; void 0 === t && Ys(n, t = new qs(a)), n = t } } } function Js(t, e) { this.seq = [], this.map = {}; const n = t.getProgramParameter(e, 35718); for (let i = 0; i < n; ++i) { const n = t.getActiveUniform(e, i); Zs(n, t.getUniformLocation(e, n.name), this) } } function Qs(t, e, n) { const i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), i } Js.prototype.setValue = function (t, e, n, i) { const r = this.map[e]; void 0 !== r && r.setValue(t, n, i) }, Js.prototype.setOptional = function (t, e, n) { const i = e[n]; void 0 !== i && this.setValue(t, n, i) }, Js.upload = function (t, e, n, i) { for (let r = 0, o = e.length; r !== o; ++r) { const o = e[r], s = n[o.id]; !1 !== s.needsUpdate && o.setValue(t, s.value, i) } }, Js.seqWithValue = function (t, e) { const n = []; for (let i = 0, r = t.length; i !== r; ++i) { const r = t[i]; r.id in e && n.push(r) } return n }; let $s = 0; function Ks(t) { switch (t) { case Je: return ["Linear", "( value )"]; case Qe: return ["sRGB", "( value )"]; case Ke: return ["RGBE", "( value )"]; case en: return ["RGBM", "( value, 7.0 )"]; case nn: return ["RGBM", "( value, 16.0 )"]; case rn: return ["RGBD", "( value, 256.0 )"]; case $e: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case tn: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"] } } function ta(t, e, n) { const i = t.getShaderParameter(e, 35713), r = t.getShaderInfoLog(e).trim(); return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (t) { const e = t.split("\n"); for (let t = 0; t < e.length; t++)e[t] = t + 1 + ": " + e[t]; return e.join("\n") }(t.getShaderSource(e)) } function ea(t, e) { const n = Ks(e); return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" } function na(t, e) { const n = Ks(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function ia(t, e) { let n; switch (e) { case K: n = "Linear"; break; case tt: n = "Reinhard"; break; case et: n = "OptimizedCineon"; break; case nt: n = "ACESFilmic"; break; case it: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear" }return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function ra(t) { return "" !== t } function oa(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function sa(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const aa = /^[ \t]*#include +<([\w\d./]+)>/gm; function ca(t) { return t.replace(aa, la) } function la(t, e) { const n = zo[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return ca(n) } const ua = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, ha = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g; function da(t) { return t.replace(ha, pa).replace(ua, fa) } function fa(t, e, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), pa(t, e, n, i) } function pa(t, e, n, i) { let r = ""; for (let t = parseInt(e); t < parseInt(n); t++)r += i.replace(/\[ i \]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return r } function ma(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e } function ga(t, e, n, i) { const r = t.getContext(), o = n.defines; let s = n.vertexShader, a = n.fragmentShader; const c = function (t) { let e = "SHADOWMAP_TYPE_BASIC"; return t.shadowMapType === h ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === d ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === f && (e = "SHADOWMAP_TYPE_VSM"), e }(n), l = function (t) { let e = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case ot: case st: e = "ENVMAP_TYPE_CUBE"; break; case lt: case ut: e = "ENVMAP_TYPE_CUBE_UV"; break; case at: case ct: e = "ENVMAP_TYPE_EQUIREC" }return e }(n), u = function (t) { let e = "ENVMAP_MODE_REFLECTION"; if (t.envMap) switch (t.envMapMode) { case st: case ct: case ut: e = "ENVMAP_MODE_REFRACTION" }return e }(n), p = function (t) { let e = "ENVMAP_BLENDING_NONE"; if (t.envMap) switch (t.combine) { case Z: e = "ENVMAP_BLENDING_MULTIPLY"; break; case J: e = "ENVMAP_BLENDING_MIX"; break; case Q: e = "ENVMAP_BLENDING_ADD" }return e }(n), m = t.gammaFactor > 0 ? t.gammaFactor : 1, g = n.isWebGL2 ? "" : function (t) { return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ra).join("\n") }(n), v = function (t) { const e = []; for (const n in t) { const i = t[n]; !1 !== i && e.push("#define " + n + " " + i) } return e.join("\n") }(o), y = r.createProgram(); let _, x; n.isRawShaderMaterial ? ((_ = [v].filter(ra).join("\n")).length > 0 && (_ += "\n"), (x = [g, v].filter(ra).join("\n")).length > 0 && (x += "\n")) : (_ = [ma(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ra).join("\n"), x = [g, ma(n), "#define SHADER_NAME " + n.shaderName, v, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== $ ? "#define TONE_MAPPING" : "", n.toneMapping !== $ ? zo.tonemapping_pars_fragment : "", n.toneMapping !== $ ? ia("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", zo.encodings_pars_fragment, n.map ? ea("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? ea("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? ea("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? ea("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? ea("lightMapTexelToLinear", n.lightMapEncoding) : "", na("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ra).join("\n")), s = sa(s = oa(s = ca(s), n), n), a = sa(a = oa(a = ca(a), n), n), s = da(s), a = da(a), n.isWebGL2 && !n.isRawShaderMaterial && (_ = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + _, x = ["#version 300 es\n", "#define varying in", "out highp vec4 pc_fragColor;", "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x); const b = x + a, w = Qs(r, 35633, _ + s), M = Qs(r, 35632, b); if (r.attachShader(y, w), r.attachShader(y, M), void 0 !== n.index0AttributeName ? r.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), t.debug.checkShaderErrors) { const t = r.getProgramInfoLog(y).trim(), e = r.getShaderInfoLog(w).trim(), n = r.getShaderInfoLog(M).trim(); let i = !0, o = !0; if (!1 === r.getProgramParameter(y, 35714)) { i = !1; const e = ta(r, w, "vertex"), n = ta(r, M, "fragment"); console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(y, 35715), "gl.getProgramInfoLog", t, e, n) } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1); o && (this.diagnostics = { runnable: i, programLog: t, vertexShader: { log: e, prefix: _ }, fragmentShader: { log: n, prefix: x } }) } let T, S; return r.deleteShader(w), r.deleteShader(M), this.getUniforms = function () { return void 0 === T && (T = new Js(r, y)), T }, this.getAttributes = function () { return void 0 === S && (S = function (t, e) { const n = {}, i = t.getProgramParameter(e, 35721); for (let r = 0; r < i; r++) { const i = t.getActiveAttrib(e, r).name; n[i] = t.getAttribLocation(e, i) } return n }(r, y)), S }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0 }, this.name = n.shaderName, this.id = $s++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = w, this.fragmentShader = M, this } function va(t, e, n, i) { const r = [], o = n.isWebGL2, s = n.logarithmicDepthBuffer, a = n.floatVertexTextures, c = n.maxVertexUniforms, l = n.vertexTextures; let u = n.precision; const h = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, d = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"]; function f(t) { let e; return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = Je, e } return { getParameters: function (i, r, d, p, v, y, _) { const x = p.fog, b = i.isMeshStandardMaterial ? p.environment : null, w = i.envMap || b, M = h[i.type], T = _.isSkinnedMesh ? function (t) { const e = t.skeleton.bones; if (a) return 1024; { const t = c, n = Math.floor((t - 20) / 4), i = Math.min(n, e.length); return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i } }(_) : 0; let S, E; if (null !== i.precision && (u = n.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", u, "instead."), M) { const t = Fo[M]; S = t.vertexShader, E = t.fragmentShader } else S = i.vertexShader, E = i.fragmentShader; const A = t.getRenderTarget(); return { isWebGL2: o, shaderID: M, shaderName: i.type, vertexShader: S, fragmentShader: E, defines: i.defines, isRawShaderMaterial: i.isRawShaderMaterial, isShaderMaterial: i.isShaderMaterial, precision: u, instancing: !0 === _.isInstancedMesh, supportsVertexTextures: l, outputEncoding: null !== A ? f(A.texture) : t.outputEncoding, map: !!i.map, mapEncoding: f(i.map), matcap: !!i.matcap, matcapEncoding: f(i.matcap), envMap: !!w, envMapMode: w && w.mapping, envMapEncoding: f(w), envMapCubeUV: !!w && (w.mapping === lt || w.mapping === ut), lightMap: !!i.lightMap, lightMapEncoding: f(i.lightMap), aoMap: !!i.aoMap, emissiveMap: !!i.emissiveMap, emissiveMapEncoding: f(i.emissiveMap), bumpMap: !!i.bumpMap, normalMap: !!i.normalMap, objectSpaceNormalMap: i.normalMapType === cn, tangentSpaceNormalMap: i.normalMapType === an, clearcoatMap: !!i.clearcoatMap, clearcoatRoughnessMap: !!i.clearcoatRoughnessMap, clearcoatNormalMap: !!i.clearcoatNormalMap, displacementMap: !!i.displacementMap, roughnessMap: !!i.roughnessMap, metalnessMap: !!i.metalnessMap, specularMap: !!i.specularMap, alphaMap: !!i.alphaMap, gradientMap: !!i.gradientMap, sheen: !!i.sheen, transmissionMap: !!i.transmissionMap, combine: i.combine, vertexTangents: i.normalMap && i.vertexTangents, vertexColors: i.vertexColors, vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap), uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap), fog: !!x, useFog: i.fog, fogExp2: x && x.isFogExp2, flatShading: i.flatShading, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: s, skinning: i.skinning && T > 0, maxBones: T, useVertexTexture: a, morphTargets: i.morphTargets, morphNormals: i.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: r.directional.length, numPointLights: r.point.length, numSpotLights: r.spot.length, numRectAreaLights: r.rectArea.length, numHemiLights: r.hemi.length, numDirLightShadows: r.directionalShadowMap.length, numPointLightShadows: r.pointShadowMap.length, numSpotLightShadows: r.spotShadowMap.length, numClippingPlanes: v, numClipIntersection: y, dithering: i.dithering, shadowMapEnabled: t.shadowMap.enabled && d.length > 0, shadowMapType: t.shadowMap.type, toneMapping: i.toneMapped ? t.toneMapping : $, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: i.side === g, flipSided: i.side === m, depthPacking: void 0 !== i.depthPacking && i.depthPacking, index0AttributeName: i.index0AttributeName, extensionDerivatives: i.extensions && i.extensions.derivatives, extensionFragDepth: i.extensions && i.extensions.fragDepth, extensionDrawBuffers: i.extensions && i.extensions.drawBuffers, extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD, rendererExtensionFragDepth: o || null !== e.get("EXT_frag_depth"), rendererExtensionDrawBuffers: o || null !== e.get("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: o || null !== e.get("EXT_shader_texture_lod"), customProgramCacheKey: i.customProgramCacheKey() } }, getProgramCacheKey: function (e) { const n = []; if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]); if (void 0 === e.isRawShaderMaterial) { for (let t = 0; t < d.length; t++)n.push(e[d[t]]); n.push(t.outputEncoding), n.push(t.gammaFactor) } return n.push(e.customProgramCacheKey), n.join() }, getUniforms: function (t) { const e = h[t.type]; let n; if (e) { const t = Fo[e]; n = _o.clone(t.uniforms) } else n = t.uniforms; return n }, acquireProgram: function (e, n) { let o; for (let t = 0, e = r.length; t < e; t++) { const e = r[t]; if (e.cacheKey === n) { ++(o = e).usedTimes; break } } return void 0 === o && (o = new ga(t, n, e, i), r.push(o)), o }, releaseProgram: function (t) { if (0 == --t.usedTimes) { const e = r.indexOf(t); r[e] = r[r.length - 1], r.pop(), t.destroy() } }, programs: r } } function ya() { let t = new WeakMap; return { get: function (e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function (e) { t.delete(e) }, update: function (e, n, i) { t.get(e)[n] = i }, dispose: function () { t = new WeakMap } } } function _a(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function xa(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function ba(t) { const e = []; let n = 0; const i = [], r = [], o = { id: -1 }; function s(i, r, s, a, c, l) { let u = e[n]; const h = t.get(s); return void 0 === u ? (u = { id: i.id, object: i, geometry: r, material: s, program: h.program || o, groupOrder: a, renderOrder: i.renderOrder, z: c, group: l }, e[n] = u) : (u.id = i.id, u.object = i, u.geometry = r, u.material = s, u.program = h.program || o, u.groupOrder = a, u.renderOrder = i.renderOrder, u.z = c, u.group = l), n++, u } return { opaque: i, transparent: r, init: function () { n = 0, i.length = 0, r.length = 0 }, push: function (t, e, n, o, a, c) { const l = s(t, e, n, o, a, c); (!0 === n.transparent ? r : i).push(l) }, unshift: function (t, e, n, o, a, c) { const l = s(t, e, n, o, a, c); (!0 === n.transparent ? r : i).unshift(l) }, finish: function () { for (let t = n, i = e.length; t < i; t++) { const n = e[t]; if (null === n.id) break; n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null } }, sort: function (t, e) { i.length > 1 && i.sort(t || _a), r.length > 1 && r.sort(e || xa) } } } function wa(t) { let e = new WeakMap; function n(t) { const i = t.target; i.removeEventListener("dispose", n), e.delete(i) } return { get: function (i, r) { const o = e.get(i); let s; return void 0 === o ? (s = new ba(t), e.set(i, new WeakMap), e.get(i).set(r, s), i.addEventListener("dispose", n)) : void 0 === (s = o.get(r)) && (s = new ba(t), o.set(r, s)), s }, dispose: function () { e = new WeakMap } } } function Ma() { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": n = { direction: new Jn, color: new fr }; break; case "SpotLight": n = { position: new Jn, direction: new Jn, color: new fr, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new Jn, color: new fr, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new Jn, skyColor: new fr, groundColor: new fr }; break; case "RectAreaLight": n = { color: new fr, position: new Jn, halfWidth: new Jn, halfHeight: new Jn } }return t[e.id] = n, n } } } let Ta = 0; function Sa(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) } function Ea() { const t = new Ma, e = function () { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new zn }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new zn, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return t[e.id] = n, n } } }(), n = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let t = 0; t < 9; t++)n.probe.push(new Jn); const i = new Jn, r = new ri, o = new ri; return { setup: function (s, a, c) { let l = 0, u = 0, h = 0; for (let t = 0; t < 9; t++)n.probe[t].set(0, 0, 0); let d = 0, f = 0, p = 0, m = 0, g = 0, v = 0, y = 0, _ = 0; const x = c.matrixWorldInverse; s.sort(Sa); for (let a = 0, c = s.length; a < c; a++) { const c = s[a], b = c.color, w = c.intensity, M = c.distance, T = c.shadow && c.shadow.map ? c.shadow.map.texture : null; if (c.isAmbientLight) l += b.r * w, u += b.g * w, h += b.b * w; else if (c.isLightProbe) for (let t = 0; t < 9; t++)n.probe[t].addScaledVector(c.sh.coefficients[t], w); else if (c.isDirectionalLight) { const r = t.get(c); if (r.color.copy(c.color).multiplyScalar(c.intensity), r.direction.setFromMatrixPosition(c.matrixWorld), i.setFromMatrixPosition(c.target.matrixWorld), r.direction.sub(i), r.direction.transformDirection(x), c.castShadow) { const t = c.shadow, i = e.get(c); i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.directionalShadow[d] = i, n.directionalShadowMap[d] = T, n.directionalShadowMatrix[d] = c.shadow.matrix, v++ } n.directional[d] = r, d++ } else if (c.isSpotLight) { const r = t.get(c); if (r.position.setFromMatrixPosition(c.matrixWorld), r.position.applyMatrix4(x), r.color.copy(b).multiplyScalar(w), r.distance = M, r.direction.setFromMatrixPosition(c.matrixWorld), i.setFromMatrixPosition(c.target.matrixWorld), r.direction.sub(i), r.direction.transformDirection(x), r.coneCos = Math.cos(c.angle), r.penumbraCos = Math.cos(c.angle * (1 - c.penumbra)), r.decay = c.decay, c.castShadow) { const t = c.shadow, i = e.get(c); i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.spotShadow[p] = i, n.spotShadowMap[p] = T, n.spotShadowMatrix[p] = c.shadow.matrix, _++ } n.spot[p] = r, p++ } else if (c.isRectAreaLight) { const e = t.get(c); e.color.copy(b).multiplyScalar(w), e.position.setFromMatrixPosition(c.matrixWorld), e.position.applyMatrix4(x), o.identity(), r.copy(c.matrixWorld), r.premultiply(x), o.extractRotation(r), e.halfWidth.set(.5 * c.width, 0, 0), e.halfHeight.set(0, .5 * c.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), n.rectArea[m] = e, m++ } else if (c.isPointLight) { const i = t.get(c); if (i.position.setFromMatrixPosition(c.matrixWorld), i.position.applyMatrix4(x), i.color.copy(c.color).multiplyScalar(c.intensity), i.distance = c.distance, i.decay = c.decay, c.castShadow) { const t = c.shadow, i = e.get(c); i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, n.pointShadow[f] = i, n.pointShadowMap[f] = T, n.pointShadowMatrix[f] = c.shadow.matrix, y++ } n.point[f] = i, f++ } else if (c.isHemisphereLight) { const e = t.get(c); e.direction.setFromMatrixPosition(c.matrixWorld), e.direction.transformDirection(x), e.direction.normalize(), e.skyColor.copy(c.color).multiplyScalar(w), e.groundColor.copy(c.groundColor).multiplyScalar(w), n.hemi[g] = e, g++ } } n.ambient[0] = l, n.ambient[1] = u, n.ambient[2] = h; const b = n.hash; b.directionalLength === d && b.pointLength === f && b.spotLength === p && b.rectAreaLength === m && b.hemiLength === g && b.numDirectionalShadows === v && b.numPointShadows === y && b.numSpotShadows === _ || (n.directional.length = d, n.spot.length = p, n.rectArea.length = m, n.point.length = f, n.hemi.length = g, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = y, n.pointShadowMap.length = y, n.spotShadow.length = _, n.spotShadowMap.length = _, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = y, n.spotShadowMatrix.length = _, b.directionalLength = d, b.pointLength = f, b.spotLength = p, b.rectAreaLength = m, b.hemiLength = g, b.numDirectionalShadows = v, b.numPointShadows = y, b.numSpotShadows = _, n.version = Ta++) }, state: n } } function Aa() { const t = new Ea, e = [], n = []; return { init: function () { e.length = 0, n.length = 0 }, state: { lightsArray: e, shadowsArray: n, lights: t }, setupLights: function (i) { t.setup(e, n, i) }, pushLight: function (t) { e.push(t) }, pushShadow: function (t) { n.push(t) } } } function Pa() { let t = new WeakMap; function e(n) { const i = n.target; i.removeEventListener("dispose", e), t.delete(i) } return { get: function (n, i) { let r; return !1 === t.has(n) ? (r = new Aa, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : !1 === t.get(n).has(i) ? (r = new Aa, t.get(n).set(i, r)) : r = t.get(n).get(i), r }, dispose: function () { t = new WeakMap } } } function La(t) { _r.call(this), this.type = "MeshDepthMaterial", this.depthPacking = on, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) } function Ra(t) { _r.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Jn, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) } La.prototype = Object.create(_r.prototype), La.prototype.constructor = La, La.prototype.isMeshDepthMaterial = !0, La.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, Ra.prototype = Object.create(_r.prototype), Ra.prototype.constructor = Ra, Ra.prototype.isMeshDistanceMaterial = !0, Ra.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }; var Oa = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}", Ca = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"; function Ia(t, e, n) { let i = new Co; const r = new zn, o = new zn, s = new Vn, a = [], c = [], l = {}, u = { 0: m, 1: p, 2: g }, d = new wo({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new zn }, radius: { value: 4 } }, vertexShader: Ca, fragmentShader: Oa }), v = d.clone(); v.defines.HORIZONAL_PASS = 1; const y = new Gr; y.setAttribute("position", new Mr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const x = new so(y, d), b = this; function w(n, i) { const r = e.update(x); d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, d, x, null), v.uniforms.shadow_pass.value = n.mapPass.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, v, x, null) } function M(t, e, n) { const i = t << 0 | e << 1 | n << 2; let r = a[i]; return void 0 === r && (r = new La({ depthPacking: sn, morphTargets: t, skinning: e }), a[i] = r), r } function T(t, e, n) { const i = t << 0 | e << 1 | n << 2; let r = c[i]; return void 0 === r && (r = new Ra({ morphTargets: t, skinning: e }), c[i] = r), r } function S(e, n, i, r, o, s, a) { let c = null, h = M, d = e.customDepthMaterial; if (!0 === r.isPointLight && (h = T, d = e.customDistanceMaterial), void 0 === d) { let t = !1; !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0); let r = !1; !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), c = h(t, r, !0 === e.isInstancedMesh) } else c = d; if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) { const t = c.uuid, e = i.uuid; let n = l[t]; void 0 === n && (n = {}, l[t] = n); let r = n[e]; void 0 === r && (r = c.clone(), n[e] = r), c = r } return c.visible = i.visible, c.wireframe = i.wireframe, c.side = a === f ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = o, c.farDistance = s), c } function E(n, r, o, s, a) { if (!1 === n.visible) return; if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === f) && (!n.frustumCulled || i.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld); const i = e.update(n), r = n.material; if (Array.isArray(r)) { const e = i.groups; for (let c = 0, l = e.length; c < l; c++) { const l = e[c], u = r[l.materialIndex]; if (u && u.visible) { const e = S(n, i, u, s, o.near, o.far, a); t.renderBufferDirect(o, null, i, e, n, l) } } } else if (r.visible) { const e = S(n, i, r, s, o.near, o.far, a); t.renderBufferDirect(o, null, i, e, n, null) } } const c = n.children; for (let t = 0, e = c.length; t < e; t++)E(c[t], r, o, s, a) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = h, this.render = function (e, a, c) { if (!1 === b.enabled) return; if (!1 === b.autoUpdate && !1 === b.needsUpdate) return; if (0 === e.length) return; const l = t.getRenderTarget(), u = t.getActiveCubeFace(), h = t.getActiveMipmapLevel(), d = t.state; d.setBlending(_), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); for (let l = 0, u = e.length; l < u; l++) { const u = e[l], h = u.shadow; if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue; if (void 0 === h) { console.warn("THREE.WebGLShadowMap:", u, "has no shadow."); continue } r.copy(h.mapSize); const p = h.getFrameExtents(); if (r.multiply(p), o.copy(h.mapSize), (r.x > n || r.y > n) && (r.x > n && (o.x = Math.floor(n / p.x), r.x = o.x * p.x, h.mapSize.x = o.x), r.y > n && (o.y = Math.floor(n / p.y), r.y = o.y * p.y, h.mapSize.y = o.y)), null === h.map && !h.isPointLightShadow && this.type === f) { const t = { minFilter: _t, magFilter: _t, format: zt, stencilBuffer: !1 }; h.map = new Wn(r.x, r.y, t), h.map.texture.name = u.name + ".shadowMap", h.mapPass = new Wn(r.x, r.y, t), h.camera.updateProjectionMatrix() } if (null === h.map) { const t = { minFilter: pt, magFilter: pt, format: zt, stencilBuffer: !1 }; h.map = new Wn(r.x, r.y, t), h.map.texture.name = u.name + ".shadowMap", h.camera.updateProjectionMatrix() } t.setRenderTarget(h.map), t.clear(); const m = h.getViewportCount(); for (let t = 0; t < m; t++) { const e = h.getViewport(t); s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), d.viewport(s), h.updateMatrices(u, t), i = h.getFrustum(), E(a, c, h.camera, u, this.type) } h.isPointLightShadow || this.type !== f || w(h, c), h.needsUpdate = !1 } b.needsUpdate = !1, t.setRenderTarget(l, u, h) } } function Da(t, e, n) { const i = n.isWebGL2; const r = new function () { let e = !1; const n = new Vn; let i = null; const r = new Vn(0, 0, 0, 0); return { setMask: function (n) { i === n || e || (t.colorMask(n, n, n, n), i = n) }, setLocked: function (t) { e = t }, setClear: function (e, i, o, s, a) { !0 === a && (e *= s, i *= s, o *= s), n.set(e, i, o, s), !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n)) }, reset: function () { e = !1, i = null, r.set(-1, 0, 0, 0) } } }, o = new function () { let e = !1, n = null, i = null, r = null; return { setTest: function (t) { t ? pt(2929) : mt(2929) }, setMask: function (i) { n === i || e || (t.depthMask(i), n = i) }, setFunc: function (e) { if (i !== e) { if (e) switch (e) { case H: t.depthFunc(512); break; case G: t.depthFunc(519); break; case j: t.depthFunc(513); break; case V: t.depthFunc(515); break; case W: t.depthFunc(514); break; case q: t.depthFunc(518); break; case X: t.depthFunc(516); break; case Y: t.depthFunc(517); break; default: t.depthFunc(515) } else t.depthFunc(515); i = e } }, setLocked: function (t) { e = t }, setClear: function (e) { r !== e && (t.clearDepth(e), r = e) }, reset: function () { e = !1, n = null, i = null, r = null } } }, l = new function () { let e = !1, n = null, i = null, r = null, o = null, s = null, a = null, c = null, l = null; return { setTest: function (t) { e || (t ? pt(2960) : mt(2960)) }, setMask: function (i) { n === i || e || (t.stencilMask(i), n = i) }, setFunc: function (e, n, s) { i === e && r === n && o === s || (t.stencilFunc(e, n, s), i = e, r = n, o = s) }, setOp: function (e, n, i) { s === e && a === n && c === i || (t.stencilOp(e, n, i), s = e, a = n, c = i) }, setLocked: function (t) { e = t }, setClear: function (e) { l !== e && (t.clearStencil(e), l = e) }, reset: function () { e = !1, n = null, i = null, r = null, o = null, s = null, a = null, c = null, l = null } } }; let u = {}, h = null, d = null, f = null, p = null, v = null, y = null, Z = null, J = null, Q = null, $ = !1, K = null, tt = null, et = null, nt = null, it = null; const rt = t.getParameter(35661); let ot = !1, st = 0; const at = t.getParameter(7938); -1 !== at.indexOf("WebGL") ? (st = parseFloat(/^WebGL\ ([0-9])/.exec(at)[1]), ot = st >= 1) : -1 !== at.indexOf("OpenGL ES") && (st = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(at)[1]), ot = st >= 2); let ct = null, lt = {}; const ut = new Vn, ht = new Vn; function dt(e, n, i) { const r = new Uint8Array(4), o = t.createTexture(); t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728); for (let e = 0; e < i; e++)t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r); return o } const ft = {}; function pt(e) { !0 !== u[e] && (t.enable(e), u[e] = !0) } function mt(e) { !1 !== u[e] && (t.disable(e), u[e] = !1) } ft[3553] = dt(3553, 3553, 1), ft[34067] = dt(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), l.setClear(0), pt(2929), o.setFunc(V), _t(!1), xt(a), pt(2884), yt(_); const gt = { [S]: 32774, [E]: 32778, [A]: 32779 }; if (i) gt[P] = 32775, gt[L] = 32776; else { const t = e.get("EXT_blend_minmax"); null !== t && (gt[P] = t.MIN_EXT, gt[L] = t.MAX_EXT) } const vt = { [R]: 0, [O]: 1, [C]: 768, [D]: 770, [U]: 776, [z]: 774, [k]: 772, [I]: 769, [N]: 771, [F]: 775, [B]: 773 }; function yt(e, n, i, r, o, s, a, c) { if (e !== _) { if (d || (pt(3042), d = !0), e === T) o = o || n, s = s || i, a = a || r, n === p && o === Z || (t.blendEquationSeparate(gt[n], gt[o]), p = n, Z = o), i === v && r === y && s === J && a === Q || (t.blendFuncSeparate(vt[i], vt[r], vt[s], vt[a]), v = i, y = r, J = s, Q = a), f = e, $ = null; else if (e !== f || c !== $) { if (p === S && Z === S || (t.blendEquation(32774), p = S, Z = S), c) switch (e) { case x: t.blendFuncSeparate(1, 771, 1, 771); break; case b: t.blendFunc(1, 1); break; case w: t.blendFuncSeparate(0, 0, 769, 771); break; case M: t.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case x: t.blendFuncSeparate(770, 771, 1, 771); break; case b: t.blendFunc(770, 1); break; case w: t.blendFunc(0, 769); break; case M: t.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }v = null, y = null, J = null, Q = null, f = e, $ = c } } else d && (mt(3042), d = !1) } function _t(e) { K !== e && (e ? t.frontFace(2304) : t.frontFace(2305), K = e) } function xt(e) { e !== s ? (pt(2884), e !== tt && (e === a ? t.cullFace(1029) : e === c ? t.cullFace(1028) : t.cullFace(1032))) : mt(2884), tt = e } function bt(e, n, i) { e ? (pt(32823), nt === n && it === i || (t.polygonOffset(n, i), nt = n, it = i)) : mt(32823) } function wt(e) { void 0 === e && (e = 33984 + rt - 1), ct !== e && (t.activeTexture(e), ct = e) } return { buffers: { color: r, depth: o, stencil: l }, enable: pt, disable: mt, useProgram: function (e) { return h !== e && (t.useProgram(e), h = e, !0) }, setBlending: yt, setMaterial: function (t, e) { t.side === g ? mt(2884) : pt(2884); let n = t.side === m; e && (n = !n), _t(n), t.blending === x && !1 === t.transparent ? yt(_) : yt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), r.setMask(t.colorWrite); const i = t.stencilWrite; l.setTest(i), i && (l.setMask(t.stencilWriteMask), l.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), l.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), bt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) }, setFlipSided: _t, setCullFace: xt, setLineWidth: function (e) { e !== et && (ot && t.lineWidth(e), et = e) }, setPolygonOffset: bt, setScissorTest: function (t) { t ? pt(3089) : mt(3089) }, activeTexture: wt, bindTexture: function (e, n) { null === ct && wt(); let i = lt[ct]; void 0 === i && (i = { type: void 0, texture: void 0 }, lt[ct] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || ft[e]), i.type = e, i.texture = n) }, unbindTexture: function () { const e = lt[ct]; void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage3D: function () { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, scissor: function (e) { !1 === ut.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ut.copy(e)) }, viewport: function (e) { !1 === ht.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), ht.copy(e)) }, reset: function () { u = {}, ct = null, lt = {}, h = null, f = null, K = null, tt = null, r.reset(), o.reset(), l.reset() } } } function Na(t, e, n, i, r, o, s) { const a = r.isWebGL2, c = r.maxTextures, l = r.maxCubemapSize, u = r.maxTextureSize, h = r.maxSamples, d = new WeakMap; let f, p = !1; try { p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) { } function m(t, e) { return p ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function g(t, e, n, i) { let r = 1; if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const i = e ? Bn.floorPowerOfTwo : Math.floor, o = i(r * t.width), s = i(r * t.height); void 0 === f && (f = m(o, s)); const a = n ? m(o, s) : f; return a.width = o, a.height = s, a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function v(t) { return Bn.isPowerOfTwo(t.width) && Bn.isPowerOfTwo(t.height) } function y(t, e) { return t.generateMipmaps && e && t.minFilter !== pt && t.minFilter !== _t } function _(e, n, r, o) { t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E } function x(n, i, r) { if (!1 === a) return i; if (null !== n) { if (void 0 !== t[n]) return t[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let o = i; return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o } function b(t) { return t === pt || t === mt || t === vt ? 9728 : 9729 } function w(e) { const n = e.target; n.removeEventListener("dispose", w), function (e) { const n = i.get(e); if (void 0 === n.__webglInit) return; t.deleteTexture(n.__webglTexture), i.remove(e) }(n), n.isVideoTexture && d.delete(n), s.memory.textures-- } function M(e) { const n = e.target; n.removeEventListener("dispose", M), function (e) { const n = i.get(e), r = i.get(e.texture); if (!e) return; void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture); e.depthTexture && e.depthTexture.dispose(); if (e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++)t.deleteFramebuffer(n.__webglFramebuffer[e]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e]); else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer); i.remove(e.texture), i.remove(e) }(n), s.memory.textures-- } let T = 0; function S(t, e) { const r = i.get(t); if (t.isVideoTexture && function (t) { const e = s.render.frame; d.get(t) !== e && (d.set(t, e), t.update()) }(t), t.version > 0 && r.__version !== t.version) { const n = t.image; if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== n.complete) return void C(r, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture) } function E(e, r) { if (6 !== e.image.length) return; const s = i.get(e); if (e.version > 0 && s.__version !== e.version) { O(s, e), n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture), t.pixelStorei(37440, e.flipY); const i = e && (e.isCompressedTexture || e.image[0].isCompressedTexture), c = e.image[0] && e.image[0].isDataTexture, u = []; for (let t = 0; t < 6; t++)u[t] = i || c ? c ? e.image[t].image : e.image[t] : g(e.image[t], !1, !0, l); const h = u[0], d = v(h) || a, f = o.convert(e.format), p = o.convert(e.type), m = x(e.internalFormat, f, p); let b; if (R(34067, e, d), i) { for (let t = 0; t < 6; t++) { b = u[t].mipmaps; for (let i = 0; i < b.length; i++) { const r = b[i]; e.format !== zt && e.format !== Bt ? null !== f ? n.compressedTexImage2D(34069 + t, i, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, i, m, r.width, r.height, 0, f, p, r.data) } } s.__maxMipLevel = b.length - 1 } else { b = e.mipmaps; for (let t = 0; t < 6; t++)if (c) { n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, f, p, u[t].data); for (let e = 0; e < b.length; e++) { const i = b[e].image[t].image; n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, f, p, i.data) } } else { n.texImage2D(34069 + t, 0, m, f, p, u[t]); for (let e = 0; e < b.length; e++) { const i = b[e]; n.texImage2D(34069 + t, e + 1, m, f, p, i.image[t]) } } s.__maxMipLevel = b.length } y(e, d) && _(34067, e, h.width, h.height), s.__version = e.version, e.onUpdate && e.onUpdate(e) } else n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture) } function A(t, e) { n.activeTexture(33984 + e), n.bindTexture(34067, i.get(t).__webglTexture) } const P = { [ht]: 10497, [dt]: 33071, [ft]: 33648 }, L = { [pt]: 9728, [mt]: 9984, [vt]: 9986, [_t]: 9729, [xt]: 9985, [wt]: 9987 }; function R(n, o, s) { s ? (t.texParameteri(n, 10242, P[o.wrapS]), t.texParameteri(n, 10243, P[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, P[o.wrapR]), t.texParameteri(n, 10240, L[o.magFilter]), t.texParameteri(n, 10241, L[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), o.wrapS === dt && o.wrapT === dt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, b(o.magFilter)), t.texParameteri(n, 10241, b(o.minFilter)), o.minFilter !== pt && o.minFilter !== _t && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")); const c = e.get("EXT_texture_filter_anisotropic"); if (c) { if (o.type === Rt && null === e.get("OES_texture_float_linear")) return; if (o.type === Ot && null === (a || e.get("OES_texture_half_float_linear"))) return; (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy) } } function O(e, n) { void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), s.memory.textures++) } function C(e, i, r) { let s = 3553; i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), O(e, i), n.activeTexture(33984 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment); const c = function (t) { return !a && (t.wrapS !== dt || t.wrapT !== dt || t.minFilter !== pt && t.minFilter !== _t) }(i) && !1 === v(i.image), l = g(i.image, c, !1, u), h = v(l) || a, d = o.convert(i.format); let f, p = o.convert(i.type), m = x(i.internalFormat, d, p); R(s, i, h); const b = i.mipmaps; if (i.isDepthTexture) m = 6402, a ? m = i.type === Rt ? 36012 : i.type === Lt ? 33190 : i.type === Nt ? 35056 : 33189 : i.type === Rt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Gt && 6402 === m && i.type !== At && i.type !== Lt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = At, p = o.convert(i.type)), i.format === jt && 6402 === m && (m = 34041, i.type !== Nt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Nt, p = o.convert(i.type))), n.texImage2D(3553, 0, m, l.width, l.height, 0, d, p, null); else if (i.isDataTexture) if (b.length > 0 && h) { for (let t = 0, e = b.length; t < e; t++)f = b[t], n.texImage2D(3553, t, m, f.width, f.height, 0, d, p, f.data); i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1 } else n.texImage2D(3553, 0, m, l.width, l.height, 0, d, p, l.data), e.__maxMipLevel = 0; else if (i.isCompressedTexture) { for (let t = 0, e = b.length; t < e; t++)f = b[t], i.format !== zt && i.format !== Bt ? null !== d ? n.compressedTexImage2D(3553, t, m, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, f.width, f.height, 0, d, p, f.data); e.__maxMipLevel = b.length - 1 } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, p, l.data), e.__maxMipLevel = 0; else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, p, l.data), e.__maxMipLevel = 0; else if (b.length > 0 && h) { for (let t = 0, e = b.length; t < e; t++)f = b[t], n.texImage2D(3553, t, m, d, p, f); i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1 } else n.texImage2D(3553, 0, m, d, p, l), e.__maxMipLevel = 0; y(i, h) && _(s, i, l.width, l.height), e.__version = i.version, i.onUpdate && i.onUpdate(i) } function I(e, r, s, a) { const c = o.convert(r.texture.format), l = o.convert(r.texture.type), u = x(r.texture.internalFormat, c, l); n.texImage2D(a, 0, u, r.width, r.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, s, a, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null) } function D(e, n, i) { if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) { let r = 33189; if (i) { const e = n.depthTexture; e && e.isDepthTexture && (e.type === Rt ? r = 36012 : e.type === Lt && (r = 33190)); const i = k(n); t.renderbufferStorageMultisample(36161, i, r, n.width, n.height) } else t.renderbufferStorage(36161, r, n.width, n.height); t.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (n.depthBuffer && n.stencilBuffer) { if (i) { const e = k(n); t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height) } else t.renderbufferStorage(36161, 34041, n.width, n.height); t.framebufferRenderbuffer(36160, 33306, 36161, e) } else { const e = o.convert(n.texture.format), r = o.convert(n.texture.type), s = x(n.texture.internalFormat, e, r); if (i) { const e = k(n); t.renderbufferStorageMultisample(36161, e, s, n.width, n.height) } else t.renderbufferStorage(36161, s, n.width, n.height) } t.bindRenderbuffer(36161, null) } function N(e) { const n = i.get(e), r = !0 === e.isWebGLCubeRenderTarget; if (e.depthTexture) { if (r) throw new Error("target.depthTexture not supported in Cube render targets"); !function (e, n) { if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), S(n.depthTexture, 0); const r = i.get(n.depthTexture).__webglTexture; if (n.depthTexture.format === Gt) t.framebufferTexture2D(36160, 36096, 3553, r, 0); else { if (n.depthTexture.format !== jt) throw new Error("Unknown depthTexture format"); t.framebufferTexture2D(36160, 33306, 3553, r, 0) } }(n.__webglFramebuffer, e) } else if (r) { n.__webglDepthbuffer = []; for (let i = 0; i < 6; i++)t.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = t.createRenderbuffer(), D(n.__webglDepthbuffer[i], e, !1) } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), D(n.__webglDepthbuffer, e, !1); t.bindFramebuffer(36160, null) } function k(t) { return a && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0 } let B = !1, z = !1; this.allocateTextureUnit = function () { const t = T; return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), T += 1, t }, this.resetTextureUnits = function () { T = 0 }, this.setTexture2D = S, this.setTexture2DArray = function (t, e) { const r = i.get(t); t.version > 0 && r.__version !== t.version ? C(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture)) }, this.setTexture3D = function (t, e) { const r = i.get(t); t.version > 0 && r.__version !== t.version ? C(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture)) }, this.setTextureCube = E, this.setTextureCubeDynamic = A, this.setupRenderTarget = function (e) { const r = i.get(e), c = i.get(e.texture); e.addEventListener("dispose", M), c.__webglTexture = t.createTexture(), s.memory.textures++; const l = !0 === e.isWebGLCubeRenderTarget, u = !0 === e.isWebGLMultisampleRenderTarget, h = v(e) || a; if (!a || e.texture.format !== Bt || e.texture.type !== Rt && e.texture.type !== Ot || (e.texture.format = zt, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), l) { r.__webglFramebuffer = []; for (let e = 0; e < 6; e++)r.__webglFramebuffer[e] = t.createFramebuffer() } else if (r.__webglFramebuffer = t.createFramebuffer(), u) if (a) { r.__webglMultisampledFramebuffer = t.createFramebuffer(), r.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, r.__webglColorRenderbuffer); const n = o.convert(e.texture.format), i = o.convert(e.texture.type), s = x(e.texture.internalFormat, n, i), a = k(e); t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(), D(r.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (l) { n.bindTexture(34067, c.__webglTexture), R(34067, e.texture, h); for (let t = 0; t < 6; t++)I(r.__webglFramebuffer[t], e, 36064, 34069 + t); y(e.texture, h) && _(34067, e.texture, e.width, e.height), n.bindTexture(34067, null) } else n.bindTexture(3553, c.__webglTexture), R(3553, e.texture, h), I(r.__webglFramebuffer, e, 36064, 3553), y(e.texture, h) && _(3553, e.texture, e.width, e.height), n.bindTexture(3553, null); e.depthBuffer && N(e) }, this.updateRenderTargetMipmap = function (t) { const e = t.texture; if (y(e, v(t) || a)) { const r = t.isWebGLCubeRenderTarget ? 34067 : 3553, o = i.get(e).__webglTexture; n.bindTexture(r, o), _(r, e, t.width, t.height), n.bindTexture(r, null) } }, this.updateMultisampleRenderTarget = function (e) { if (e.isWebGLMultisampleRenderTarget) if (a) { const n = i.get(e); t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer); const r = e.width, o = e.height; let s = 16384; e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (t, e) { t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), S(t, e) }, this.safeSetTextureCube = function (t, e) { t && t.isWebGLCubeRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), z = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? E(t, e) : A(t, e) } } function ka(t, e, n) { const i = n.isWebGL2; return { convert: function (t) { let n; if (t === Tt) return 5121; if (t === Ct) return 32819; if (t === It) return 32820; if (t === Dt) return 33635; if (t === St) return 5120; if (t === Et) return 5122; if (t === At) return 5123; if (t === Pt) return 5124; if (t === Lt) return 5125; if (t === Rt) return 5126; if (t === Ot) return i ? 5131 : null !== (n = e.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null; if (t === kt) return 6406; if (t === Bt) return 6407; if (t === zt) return 6408; if (t === Ft) return 6409; if (t === Ut) return 6410; if (t === Gt) return 6402; if (t === jt) return 34041; if (t === Vt) return 6403; if (t === Wt) return 36244; if (t === qt) return 33319; if (t === Xt) return 33320; if (t === Yt) return 36248; if (t === Zt) return 36249; if (t === Jt || t === Qt || t === $t || t === Kt) { if (null === (n = e.get("WEBGL_compressed_texture_s3tc"))) return null; if (t === Jt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === Qt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === $t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === Kt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (t === te || t === ee || t === ne || t === ie) { if (null === (n = e.get("WEBGL_compressed_texture_pvrtc"))) return null; if (t === te) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === ee) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === ne) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === ie) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (t === re) return null !== (n = e.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((t === oe || t === se) && null !== (n = e.get("WEBGL_compressed_texture_etc"))) { if (t === oe) return n.COMPRESSED_RGB8_ETC2; if (t === se) return n.COMPRESSED_RGBA8_ETC2_EAC } return t === ae || t === ce || t === le || t === ue || t === he || t === de || t === fe || t === pe || t === me || t === ge || t === ve || t === ye || t === _e || t === xe || t === we || t === Me || t === Te || t === Se || t === Ee || t === Ae || t === Pe || t === Le || t === Re || t === Oe || t === Ce || t === Ie || t === De || t === Ne ? null !== (n = e.get("WEBGL_compressed_texture_astc")) ? t : null : t === be ? null !== (n = e.get("EXT_texture_compression_bptc")) ? t : null : t === Nt ? i ? 34042 : null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } function Ba(t) { To.call(this), this.cameras = t || [] } function za() { wi.call(this), this.type = "Group" } function Fa() { this._targetRay = null, this._grip = null, this._hand = null } function Ua(t, e) { const n = this; let i = null, r = 1, o = null, s = "local-floor", a = null; const c = [], l = new Map, u = new To; u.layers.enable(1), u.viewport = new Vn; const h = new To; h.layers.enable(2), h.viewport = new Vn; const d = [u, h], f = new Ba; f.layers.enable(1), f.layers.enable(2); let p = null, m = null; function g(t) { const e = l.get(t.inputSource); e && e.dispatchEvent({ type: t.type }) } function v() { l.forEach((function (t, e) { t.disconnect(e) })), l.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), T.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function y(t) { o = t, T.setContext(i), T.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } function _(t) { const e = i.inputSources; for (let t = 0; t < c.length; t++)l.set(e[t], c[t]); for (let e = 0; e < t.removed.length; e++) { const n = t.removed[e], i = l.get(n); i && (i.dispatchEvent({ type: "disconnected", data: n }), l.delete(n)) } for (let e = 0; e < t.added.length; e++) { const n = t.added[e], i = l.get(n); i && i.dispatchEvent({ type: "connected", data: n }) } } this.enabled = !1, this.isPresenting = !1, this.getController = function (t) { let e = c[t]; return void 0 === e && (e = new Fa, c[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function (t) { let e = c[t]; return void 0 === e && (e = new Fa, c[t] = e), e.getGripSpace() }, this.getHand = function (t) { let e = c[t]; return void 0 === e && (e = new Fa, c[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function (t) { r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (t) { s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return o }, this.getSession = function () { return i }, this.setSession = function (t) { if (null !== (i = t)) { i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", v); const t = e.getContextAttributes(); !0 !== t.xrCompatible && e.makeXRCompatible(); const n = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: r }, o = new XRWebGLLayer(i, e, n); i.updateRenderState({ baseLayer: o }), i.requestReferenceSpace(s).then(y), i.addEventListener("inputsourceschange", _) } }; const x = new Jn, b = new Jn; function w(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld) } this.getCamera = function (t) { f.near = h.near = u.near = t.near, f.far = h.far = u.far = t.far, p === f.near && m === f.far || (i.updateRenderState({ depthNear: f.near, depthFar: f.far }), p = f.near, m = f.far); const e = t.parent, n = f.cameras; w(f, e); for (let t = 0; t < n.length; t++)w(n[t], e); t.matrixWorld.copy(f.matrixWorld); const r = t.children; for (let t = 0, e = r.length; t < e; t++)r[t].updateMatrixWorld(!0); return 2 === n.length ? function (t, e, n) { x.setFromMatrixPosition(e.matrixWorld), b.setFromMatrixPosition(n.matrixWorld); const i = x.distanceTo(b), r = e.projectionMatrix.elements, o = n.projectionMatrix.elements, s = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), c = (r[9] + 1) / r[5], l = (r[9] - 1) / r[5], u = (r[8] - 1) / r[0], h = (o[8] + 1) / o[0], d = s * u, f = s * h, p = i / (-u + h), m = p * -u; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(p), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld); const g = s + p, v = a + p, y = d - m, _ = f + (i - m), w = c * a / v * g, M = l * a / v * g; t.projectionMatrix.makePerspective(y, _, w, M, g, v) }(f, u, h) : f.projectionMatrix.copy(u.projectionMatrix), f }; let M = null; const T = new Do; T.setAnimationLoop((function (e, n) { if (null !== (a = n.getViewerPose(o))) { const e = a.views, n = i.renderState.baseLayer; t.setFramebuffer(n.framebuffer); let r = !1; e.length !== f.cameras.length && (f.cameras.length = 0, r = !0); for (let t = 0; t < e.length; t++) { const i = e[t], o = n.getViewport(i), s = d[t]; s.matrix.fromArray(i.transform.matrix), s.projectionMatrix.fromArray(i.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === t && f.matrix.copy(s.matrix), !0 === r && f.cameras.push(s) } } const r = i.inputSources; for (let t = 0; t < c.length; t++) { const e = c[t], i = r[t]; e.update(i, n, o) } M && M(e, n) })), this.setAnimationLoop = function (t) { M = t }, this.dispose = function () { } } function Ha(t) { function e(e, n, i) { e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap); const r = n.envMap || i; if (r) { e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio; var o = t.get(r).__maxMipLevel; void 0 !== o && (e.maxMipLevel.value = o) } let s, a; n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? s = n.map : n.specularMap ? s = n.specularMap : n.displacementMap ? s = n.displacementMap : n.normalMap ? s = n.normalMap : n.bumpMap ? s = n.bumpMap : n.roughnessMap ? s = n.roughnessMap : n.metalnessMap ? s = n.metalnessMap : n.alphaMap ? s = n.alphaMap : n.emissiveMap && (s = n.emissiveMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uvTransform.value.copy(s.matrix)), n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), e.uv2Transform.value.copy(a.matrix)) } function n(t, e, n) { t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity) } return { refreshFogUniforms: function (t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) }, refreshMaterialUniforms: function (t, i, r, o, s) { i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function (t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function (t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap); e.emissiveMap && (t.emissiveMap.value = e.emissiveMap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function (t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshStandardMaterial ? (e(t, i, r), i.isMeshPhysicalMaterial ? function (t, e, i) { n(t, e, i), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen); e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap); e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap); e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === m && t.clearcoatNormalScale.value.negate()); t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap) }(t, i, r) : n(t, i, r)) : i.isMeshMatcapMaterial ? (e(t, i), function (t, e) { e.matcap && (t.matcap.value = e.matcap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias); t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function (t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === m && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === m && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isLineBasicMaterial ? (function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, i), i.isLineDashedMaterial && function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); let r; e.map ? r = e.map : e.alphaMap && (r = e.alphaMap); void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)) }(t, i, o, s) : i.isSpriteMaterial ? function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); let n; e.map ? n = e.map : e.alphaMap && (n = e.alphaMap); void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)) }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } } function Ga(t) { const e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n = void 0 !== t.context ? t.context : null, i = void 0 !== t.alpha && t.alpha, r = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil, s = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, l = void 0 !== t.powerPreference ? t.powerPreference : "default", u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat; let h = null, d = null; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Je, this.physicallyCorrectLights = !1, this.toneMapping = $, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; const f = this; let p = !1, m = null, g = 0, v = 0, y = null, _ = null, x = -1, b = null, w = null; const M = new Vn, T = new Vn; let S = null, E = e.width, A = e.height, P = 1, L = null, R = null; const O = new Vn(0, 0, E, A), C = new Vn(0, 0, E, A); let I = !1; const D = new Co, N = new Vo; let k = !1, B = !1; const z = new ri, F = new Jn, U = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function H() { return null === y ? P : 1 } let G, j, V, W, q, X, Y, Z, J, Q, K, tt, et, nt, it, rt, ot, st, at, ct = n; function lt(t, n) { for (let i = 0; i < t.length; i++) { const r = t[i], o = e.getContext(r, n); if (null !== o) return o } return null } try { const t = { alpha: i, depth: r, stencil: o, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: c, powerPreference: l, failIfMajorPerformanceCaveat: u }; if (e.addEventListener("webglcontextlost", ft, !1), e.addEventListener("webglcontextrestored", pt, !1), null === ct) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === f.isWebGL1Renderer && e.shift(), null === (ct = lt(e, t))) throw lt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === ct.getShaderPrecisionFormat && (ct.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t } function ut() { G = new Wo(ct), !1 === (j = new jo(ct, G, t)).isWebGL2 && (G.get("WEBGL_depth_texture"), G.get("OES_texture_float"), G.get("OES_texture_half_float"), G.get("OES_texture_half_float_linear"), G.get("OES_standard_derivatives"), G.get("OES_element_index_uint"), G.get("OES_vertex_array_object"), G.get("ANGLE_instanced_arrays")), G.get("OES_texture_float_linear"), st = new ka(ct, G, j), (V = new Da(ct, G, j)).scissor(T.copy(C).multiplyScalar(P).floor()), V.viewport(M.copy(O).multiplyScalar(P).floor()), W = new Yo(ct), q = new ya, X = new Na(ct, G, V, q, j, st, W), Y = new No(ct, j), at = new Ho(ct, G, Y, j), Z = new qo(ct, Y, W, at), J = new $o(ct, Z, Y, W), it = new Qo(ct), Q = new va(f, G, j, at), K = new Ha(q), tt = new wa(q), et = new Pa, nt = new Uo(f, V, J, a), rt = new Go(ct, G, W, j), ot = new Xo(ct, G, W, j), W.programs = Q.programs, f.capabilities = j, f.extensions = G, f.properties = q, f.renderLists = tt, f.state = V, f.info = W } ut(); const ht = new Ua(f, ct); this.xr = ht; const dt = new Ia(f, J, j.maxTextureSize); function ft(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), p = !0 } function pt() { console.log("THREE.WebGLRenderer: Context Restored."), p = !1, ut() } function mt(t) { const e = t.target; e.removeEventListener("dispose", mt), function (t) { gt(t), q.remove(t) }(e) } function gt(t) { const e = q.get(t).program; void 0 !== e && Q.releaseProgram(e) } this.shadowMap = dt, this.getContext = function () { return ct }, this.getContextAttributes = function () { return ct.getContextAttributes() }, this.forceContextLoss = function () { const t = G.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { const t = G.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return P }, this.setPixelRatio = function (t) { void 0 !== t && (P = t, this.setSize(E, A, !1)) }, this.getSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new zn), t.set(E, A) }, this.setSize = function (t, n, i) { ht.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t, A = n, e.width = Math.floor(t * P), e.height = Math.floor(n * P), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new zn), t.set(E * P, A * P).floor() }, this.setDrawingBufferSize = function (t, n, i) { E = t, A = n, P = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Vn), t.copy(M) }, this.getViewport = function (t) { return t.copy(O) }, this.setViewport = function (t, e, n, i) { t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), V.viewport(M.copy(O).multiplyScalar(P).floor()) }, this.getScissor = function (t) { return t.copy(C) }, this.setScissor = function (t, e, n, i) { t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i), V.scissor(T.copy(C).multiplyScalar(P).floor()) }, this.getScissorTest = function () { return I }, this.setScissorTest = function (t) { V.setScissorTest(I = t) }, this.setOpaqueSort = function (t) { L = t }, this.setTransparentSort = function (t) { R = t }, this.getClearColor = function () { return nt.getClearColor() }, this.setClearColor = function () { nt.setClearColor.apply(nt, arguments) }, this.getClearAlpha = function () { return nt.getClearAlpha() }, this.setClearAlpha = function () { nt.setClearAlpha.apply(nt, arguments) }, this.clear = function (t, e, n) { let i = 0; (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), ct.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", ft, !1), e.removeEventListener("webglcontextrestored", pt, !1), tt.dispose(), et.dispose(), q.dispose(), J.dispose(), at.dispose(), ht.dispose(), yt.stop() }, this.renderBufferImmediate = function (t, e) { at.initAttributes(); const n = q.get(t); t.hasPositions && !n.position && (n.position = ct.createBuffer()), t.hasNormals && !n.normal && (n.normal = ct.createBuffer()), t.hasUvs && !n.uv && (n.uv = ct.createBuffer()), t.hasColors && !n.color && (n.color = ct.createBuffer()); const i = e.getAttributes(); t.hasPositions && (ct.bindBuffer(34962, n.position), ct.bufferData(34962, t.positionArray, 35048), at.enableAttribute(i.position), ct.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ct.bindBuffer(34962, n.normal), ct.bufferData(34962, t.normalArray, 35048), at.enableAttribute(i.normal), ct.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ct.bindBuffer(34962, n.uv), ct.bufferData(34962, t.uvArray, 35048), at.enableAttribute(i.uv), ct.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ct.bindBuffer(34962, n.color), ct.bufferData(34962, t.colorArray, 35048), at.enableAttribute(i.color), ct.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), at.disableUnusedAttributes(), ct.drawArrays(4, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, n, i, r, o) { null === e && (e = U); const s = r.isMesh && r.matrixWorld.determinant() < 0, a = Mt(t, e, i, r); V.setMaterial(i, s); let c = n.index; const l = n.attributes.position; if (null === c) { if (void 0 === l || 0 === l.count) return } else if (0 === c.count) return; let u, h = 1; !0 === i.wireframe && (c = Z.getWireframeAttribute(n), h = 2), (i.morphTargets || i.morphNormals) && it.update(r, n, i, a), at.setup(r, i, a, n, c); let d = rt; null !== c && (u = Y.get(c), (d = ot).setIndex(u)); const f = null !== c ? c.count : l.count, p = n.drawRange.start * h, m = n.drawRange.count * h, g = null !== o ? o.start * h : 0, v = null !== o ? o.count * h : 1 / 0, y = Math.max(p, g), _ = Math.min(f, p + m, g + v) - 1, x = Math.max(0, _ - y + 1); if (0 !== x) { if (r.isMesh) !0 === i.wireframe ? (V.setLineWidth(i.wireframeLinewidth * H()), d.setMode(1)) : d.setMode(4); else if (r.isLine) { let t = i.linewidth; void 0 === t && (t = 1), V.setLineWidth(t * H()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3) } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4); if (r.isInstancedMesh) d.renderInstances(y, x, r.count); else if (n.isInstancedBufferGeometry) { const t = Math.min(n.instanceCount, n._maxInstanceCount); d.renderInstances(y, x, t) } else d.render(y, x) } }, this.compile = function (t, e) { (d = et.get(t, e)).init(), t.traverse((function (t) { t.isLight && (d.pushLight(t), t.castShadow && d.pushShadow(t)) })), d.setupLights(e); const n = new WeakMap; t.traverse((function (e) { let i = e.material; if (i) if (Array.isArray(i)) for (let r = 0; r < i.length; r++) { let o = i[r]; !1 === n.has(o) && (wt(o, t, e), n.set(o)) } else !1 === n.has(i) && (wt(i, t, e), n.set(i)) })) }; let vt = null; const yt = new Do; function _t(t, e, n, i) { if (!1 === t.visible) return; if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || D.intersectsSprite(t)) { i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z); const e = J.update(t), r = t.material; r.visible && h.push(t, e, r, n, F.z, null) } } else if (t.isImmediateRenderObject) i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z), h.push(t, null, t.material, n, F.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== W.render.frame && (t.skeleton.update(), t.skeleton.frame = W.render.frame), !t.frustumCulled || D.intersectsObject(t))) { i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z); const e = J.update(t), r = t.material; if (Array.isArray(r)) { const i = e.groups; for (let o = 0, s = i.length; o < s; o++) { const s = i[o], a = r[s.materialIndex]; a && a.visible && h.push(t, e, a, n, F.z, s) } } else r.visible && h.push(t, e, r, n, F.z, null) } const r = t.children; for (let t = 0, o = r.length; t < o; t++)_t(r[t], e, n, i) } function xt(t, e, n) { const i = !0 === e.isScene ? e.overrideMaterial : null; for (let r = 0, o = t.length; r < o; r++) { const o = t[r], s = o.object, a = o.geometry, c = null === i ? o.material : i, l = o.group; if (n.isArrayCamera) { w = n; const t = n.cameras; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; s.layers.test(i.layers) && (V.viewport(M.copy(i.viewport)), d.setupLights(i), bt(s, e, i, a, c, l)) } } else w = null, bt(s, e, n, a, c, l) } } function bt(t, e, n, i, r, o) { if (t.onBeforeRender(f, e, n, i, r, o), d = et.get(e, w || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) { const i = Mt(n, e, r, t); V.setMaterial(r), at.reset(), function (t, e) { t.render((function (t) { f.renderBufferImmediate(t, e) })) }(t, i) } else f.renderBufferDirect(n, e, i, r, t, o); t.onAfterRender(f, e, n, i, r, o), d = et.get(e, w || n) } function wt(t, e, n) { !0 !== e.isScene && (e = U); const i = q.get(t), r = d.state.lights, o = d.state.shadowsArray, s = r.state.version, a = Q.getParameters(t, r.state, o, e, N.numPlanes, N.numIntersection, n), c = Q.getProgramCacheKey(a); let l = i.program, u = !0; if (void 0 === l) t.addEventListener("dispose", mt); else if (l.cacheKey !== c) gt(t); else if (i.lightsStateVersion !== s) i.lightsStateVersion = s, u = !1; else { if (void 0 !== a.shaderID) return; u = !1 } u && (a.uniforms = Q.getUniforms(t, a), t.onBeforeCompile(a, f), l = Q.acquireProgram(a, c), i.program = l, i.uniforms = a.uniforms, i.outputEncoding = a.outputEncoding); const h = l.getAttributes(); if (t.morphTargets) { t.numSupportedMorphTargets = 0; for (let e = 0; e < f.maxMorphTargets; e++)h["morphTarget" + e] >= 0 && t.numSupportedMorphTargets++ } if (t.morphNormals) { t.numSupportedMorphNormals = 0; for (let e = 0; e < f.maxMorphNormals; e++)h["morphNormal" + e] >= 0 && t.numSupportedMorphNormals++ } const p = i.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = N.numPlanes, i.numIntersection = N.numIntersection, p.clippingPlanes = N.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.needsLights = function (t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), i.lightsStateVersion = s, i.needsLights && (p.ambientLightColor.value = r.state.ambient, p.lightProbe.value = r.state.probe, p.directionalLights.value = r.state.directional, p.directionalLightShadows.value = r.state.directionalShadow, p.spotLights.value = r.state.spot, p.spotLightShadows.value = r.state.spotShadow, p.rectAreaLights.value = r.state.rectArea, p.pointLights.value = r.state.point, p.pointLightShadows.value = r.state.pointShadow, p.hemisphereLights.value = r.state.hemi, p.directionalShadowMap.value = r.state.directionalShadowMap, p.directionalShadowMatrix.value = r.state.directionalShadowMatrix, p.spotShadowMap.value = r.state.spotShadowMap, p.spotShadowMatrix.value = r.state.spotShadowMatrix, p.pointShadowMap.value = r.state.pointShadowMap, p.pointShadowMatrix.value = r.state.pointShadowMatrix); const m = i.program.getUniforms(), g = Js.seqWithValue(m.seq, p); i.uniformsList = g } function Mt(t, e, n, i) { !0 !== e.isScene && (e = U), X.resetTextureUnits(); const r = e.fog, o = n.isMeshStandardMaterial ? e.environment : null, s = null === y ? f.outputEncoding : y.texture.encoding, a = q.get(n), c = d.state.lights; if (!0 === k && (!0 === B || t !== b)) { const e = t === b && n.id === x; N.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, a, e) } n.version === a.__version ? void 0 === a.program ? wt(n, e, i) : n.fog && a.fog !== r ? wt(n, e, i) : a.environment !== o ? wt(n, e, i) : a.needsLights && a.lightsStateVersion !== c.state.version ? wt(n, e, i) : void 0 === a.numClippingPlanes || a.numClippingPlanes === N.numPlanes && a.numIntersection === N.numIntersection ? a.outputEncoding !== s && wt(n, e, i) : wt(n, e, i) : (wt(n, e, i), a.__version = n.version); let l = !1, u = !1, h = !1; const p = a.program, m = p.getUniforms(), g = a.uniforms; if (V.useProgram(p.program) && (l = !0, u = !0, h = !0), n.id !== x && (x = n.id, u = !0), l || b !== t) { if (m.setValue(ct, "projectionMatrix", t.projectionMatrix), j.logarithmicDepthBuffer && m.setValue(ct, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), b !== t && (b = t, u = !0, h = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) { const e = m.map.cameraPosition; void 0 !== e && e.setValue(ct, F.setFromMatrixPosition(t.matrixWorld)) } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && m.setValue(ct, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && m.setValue(ct, "viewMatrix", t.matrixWorldInverse) } if (n.skinning) { m.setOptional(ct, i, "bindMatrix"), m.setOptional(ct, i, "bindMatrixInverse"); const t = i.skeleton; if (t) { const e = t.bones; if (j.floatVertexTextures) { if (void 0 === t.boneTexture) { let n = Math.sqrt(4 * e.length); n = Bn.ceilPowerOfTwo(n), n = Math.max(n, 4); const i = new Float32Array(n * n * 4); i.set(t.boneMatrices); const r = new Lo(i, n, n, zt, Rt); t.boneMatrices = i, t.boneTexture = r, t.boneTextureSize = n } m.setValue(ct, "boneTexture", t.boneTexture, X), m.setValue(ct, "boneTextureSize", t.boneTextureSize) } else m.setOptional(ct, t, "boneMatrices") } } var v, _; return (u || a.receiveShadow !== i.receiveShadow) && (a.receiveShadow = i.receiveShadow, m.setValue(ct, "receiveShadow", i.receiveShadow)), u && (m.setValue(ct, "toneMappingExposure", f.toneMappingExposure), a.needsLights && (_ = h, (v = g).ambientLightColor.needsUpdate = _, v.lightProbe.needsUpdate = _, v.directionalLights.needsUpdate = _, v.directionalLightShadows.needsUpdate = _, v.pointLights.needsUpdate = _, v.pointLightShadows.needsUpdate = _, v.spotLights.needsUpdate = _, v.spotLightShadows.needsUpdate = _, v.rectAreaLights.needsUpdate = _, v.hemisphereLights.needsUpdate = _), r && n.fog && K.refreshFogUniforms(g, r), K.refreshMaterialUniforms(g, n, o, P, A), void 0 !== g.ltc_1 && (g.ltc_1.value = Io.LTC_1), void 0 !== g.ltc_2 && (g.ltc_2.value = Io.LTC_2), Js.upload(ct, a.uniformsList, g, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Js.upload(ct, a.uniformsList, g, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && m.setValue(ct, "center", i.center), m.setValue(ct, "modelViewMatrix", i.modelViewMatrix), m.setValue(ct, "normalMatrix", i.normalMatrix), m.setValue(ct, "modelMatrix", i.matrixWorld), p } yt.setAnimationLoop((function (t) { ht.isPresenting || vt && vt(t) })), "undefined" != typeof window && yt.setContext(window), this.setAnimationLoop = function (t) { vt = t, ht.setAnimationLoop(t), null === t ? yt.stop() : yt.start() }, this.render = function (t, e) { let n, i; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === p) return; at.resetDefaultState(), x = -1, b = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === ht.enabled && !0 === ht.isPresenting && (e = ht.getCamera(e)), !0 === t.isScene && t.onBeforeRender(f, t, e, n || y), (d = et.get(t, e)).init(), z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), D.setFromProjectionMatrix(z), B = this.localClippingEnabled, k = N.init(this.clippingPlanes, B, e), (h = tt.get(t, e)).init(), _t(t, e, 0, f.sortObjects), h.finish(), !0 === f.sortObjects && h.sort(L, R), !0 === k && N.beginShadows(); const r = d.state.shadowsArray; dt.render(r, t, e), d.setupLights(e), !0 === k && N.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), nt.render(h, t, e, i); const o = h.opaque, s = h.transparent; o.length > 0 && xt(o, t, e), s.length > 0 && xt(s, t, e), !0 === t.isScene && t.onAfterRender(f, t, e), null !== y && (X.updateRenderTargetMipmap(y), X.updateMultisampleRenderTarget(y)), V.buffers.depth.setTest(!0), V.buffers.depth.setMask(!0), V.buffers.color.setMask(!0), V.setPolygonOffset(!1), h = null, d = null }, this.setFramebuffer = function (t) { m !== t && null === y && ct.bindFramebuffer(36160, t), m = t }, this.getActiveCubeFace = function () { return g }, this.getActiveMipmapLevel = function () { return v }, this.getRenderTarget = function () { return y }, this.setRenderTarget = function (t, e, n) { y = t, g = e, v = n, t && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t); let i = m, r = !1; if (t) { const n = q.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (i = n[e || 0], r = !0) : i = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : n, M.copy(t.viewport), T.copy(t.scissor), S = t.scissorTest } else M.copy(O).multiplyScalar(P).floor(), T.copy(C).multiplyScalar(P).floor(), S = I; if (_ !== i && (ct.bindFramebuffer(36160, i), _ = i), V.viewport(M), V.scissor(T), V.setScissorTest(S), r) { const i = q.get(t.texture); ct.framebufferTexture2D(36160, 36064, 34069 + (e || 0), i.__webglTexture, n || 0) } }, this.readRenderTargetPixels = function (t, e, n, i, r, o, s) { if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let a = q.get(t).__webglFramebuffer; if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) { let s = !1; a !== _ && (ct.bindFramebuffer(36160, a), s = !0); try { const a = t.texture, c = a.format, l = a.type; if (c !== zt && st.convert(c) !== ct.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(l === Tt || st.convert(l) === ct.getParameter(35738) || l === Rt && (j.isWebGL2 || G.get("OES_texture_float") || G.get("WEBGL_color_buffer_float")) || l === Ot && (j.isWebGL2 ? G.get("EXT_color_buffer_float") : G.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === ct.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && ct.readPixels(e, n, i, r, st.convert(c), st.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { s && ct.bindFramebuffer(36160, _) } } }, this.copyFramebufferToTexture = function (t, e, n) { void 0 === n && (n = 0); const i = Math.pow(2, -n), r = Math.floor(e.image.width * i), o = Math.floor(e.image.height * i), s = st.convert(e.format); X.setTexture2D(e, 0), ct.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0), V.unbindTexture() }, this.copyTextureToTexture = function (t, e, n, i) { void 0 === i && (i = 0); const r = e.image.width, o = e.image.height, s = st.convert(n.format), a = st.convert(n.type); X.setTexture2D(n, 0), ct.pixelStorei(37440, n.flipY), ct.pixelStorei(37441, n.premultiplyAlpha), ct.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ct.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? ct.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : ct.texSubImage2D(3553, i, t.x, t.y, s, a, e.image), 0 === i && n.generateMipmaps && ct.generateMipmap(3553), V.unbindTexture() }, this.initTexture = function (t) { X.setTexture2D(t, 0), V.unbindTexture() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } function ja(t) { Ga.call(this, t) } function Va(t, e) { this.name = "", this.color = new fr(t), this.density = void 0 !== e ? e : 25e-5 } function Wa(t, e, n) { this.name = "", this.color = new fr(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3 } function qa(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Sn, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Bn.generateUUID() } Ba.prototype = Object.assign(Object.create(To.prototype), { constructor: Ba, isArrayCamera: !0 }), za.prototype = Object.assign(Object.create(wi.prototype), { constructor: za, isGroup: !0 }), Object.assign(Fa.prototype, { constructor: Fa, getHandSpace: function () { if (null === this._hand && (this._hand = new za, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand)) for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) { let t = new za; t.matrixAutoUpdate = !1, t.visible = !1, this._hand.joints.push(t), this._hand.add(t) } return this._hand }, getTargetRaySpace: function () { return null === this._targetRay && (this._targetRay = new za, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay }, getGripSpace: function () { return null === this._grip && (this._grip = new za, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip }, dispatchEvent: function (t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this }, disconnect: function (t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }, update: function (t, e, n) { let i = null, r = null, o = null; const s = this._targetRay, a = this._grip, c = this._hand; if (t) if (t.hand) { o = !0; for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++)if (t.hand[i]) { let r = e.getJointPose(t.hand[i], n); const o = c.joints[i]; null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.jointRadius = r.radius), o.visible = null !== r; const s = c.joints[window.XRHand.INDEX_PHALANX_TIP], a = c.joints[window.XRHand.THUMB_PHALANX_TIP], l = s.position.distanceTo(a.position), u = .02, h = .005; c.inputState.pinching && l > u + h ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && l <= u - h && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this })) } } else null !== s && null !== (i = e.getPose(t.targetRaySpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)), null !== a && t.gripSpace && null !== (r = e.getPose(t.gripSpace, n)) && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)); return null !== s && (s.visible = null !== i), null !== a && (a.visible = null !== r), null !== c && (c.visible = null !== o), this } }), Object.assign(Ua.prototype, Dn.prototype), ja.prototype = Object.assign(Object.create(Ga.prototype), { constructor: ja, isWebGL1Renderer: !0 }), Object.assign(Va.prototype, { isFogExp2: !0, clone: function () { return new Va(this.color, this.density) }, toJSON: function () { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } }), Object.assign(Wa.prototype, { isFog: !0, clone: function () { return new Wa(this.color, this.near, this.far) }, toJSON: function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }), Object.defineProperty(qa.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(qa.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this }, copyAt: function (t, e, n) { t *= this.stride, n *= e.stride; for (let i = 0, r = this.stride; i < r; i++)this.array[t + i] = e.array[n + i]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, clone: function (t) { void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Bn.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const e = new qa(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride); return e.setUsage(this.usage), e }, onUpload: function (t) { return this.onUploadCallback = t, this }, toJSON: function (t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Bn.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } }); const Xa = new Jn; function Ya(t, e, n, i) { this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i } function Za(t) { _r.call(this), this.type = "SpriteMaterial", this.color = new fr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) } let Ja; Object.defineProperties(Ya.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } }, needsUpdate: { set: function (t) { this.data.needsUpdate = t } } }), Object.assign(Ya.prototype, { isInterleavedBufferAttribute: !0, applyMatrix4: function (t) { for (let e = 0, n = this.data.count; e < n; e++)Xa.x = this.getX(e), Xa.y = this.getY(e), Xa.z = this.getZ(e), Xa.applyMatrix4(t), this.setXYZ(e, Xa.x, Xa.y, Xa.z); return this }, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this }, clone: function (t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return new Mr(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Ya(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }, toJSON: function (t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } }), Za.prototype = Object.create(_r.prototype), Za.prototype.constructor = Za, Za.prototype.isSpriteMaterial = !0, Za.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }; const Qa = new Jn, $a = new Jn, Ka = new Jn, tc = new zn, ec = new zn, nc = new ri, ic = new Jn, rc = new Jn, oc = new Jn, sc = new zn, ac = new zn, cc = new zn; function lc(t) { if (wi.call(this), this.type = "Sprite", void 0 === Ja) { Ja = new Gr; const t = new qa(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5); Ja.setIndex([0, 1, 2, 0, 2, 3]), Ja.setAttribute("position", new Ya(t, 3, 0, !1)), Ja.setAttribute("uv", new Ya(t, 2, 3, !1)) } this.geometry = Ja, this.material = void 0 !== t ? t : new Za, this.center = new zn(.5, .5) } function uc(t, e, n, i, r, o) { tc.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (ec.x = o * tc.x - r * tc.y, ec.y = r * tc.x + o * tc.y) : ec.copy(tc), t.copy(e), t.x += ec.x, t.y += ec.y, t.applyMatrix4(nc) } lc.prototype = Object.assign(Object.create(wi.prototype), { constructor: lc, isSprite: !0, raycast: function (t, e) { null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), $a.setFromMatrixScale(this.matrixWorld), nc.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Ka.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && $a.multiplyScalar(-Ka.z); const n = this.material.rotation; let i, r; 0 !== n && (r = Math.cos(n), i = Math.sin(n)); const o = this.center; uc(ic.set(-.5, -.5, 0), Ka, o, $a, i, r), uc(rc.set(.5, -.5, 0), Ka, o, $a, i, r), uc(oc.set(.5, .5, 0), Ka, o, $a, i, r), sc.set(0, 0), ac.set(1, 0), cc.set(1, 1); let s = t.ray.intersectTriangle(ic, rc, oc, !1, Qa); if (null === s && (uc(rc.set(-.5, .5, 0), Ka, o, $a, i, r), ac.set(0, 1), null === (s = t.ray.intersectTriangle(ic, oc, rc, !1, Qa)))) return; const a = t.ray.origin.distanceTo(Qa); a < t.near || a > t.far || e.push({ distance: a, point: Qa.clone(), uv: lr.getUV(Qa, ic, rc, oc, sc, ac, cc, new zn), face: null, object: this }) }, copy: function (t) { return wi.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this } }); const hc = new Jn, dc = new Jn; function fc() { wi.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 } function pc(t, e) { t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), so.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ri, this.bindMatrixInverse = new ri } fc.prototype = Object.assign(Object.create(wi.prototype), { constructor: fc, isLOD: !0, copy: function (t) { wi.prototype.copy.call(this, t, !1); const e = t.levels; for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; this.addLevel(n.object.clone(), n.distance) } return this.autoUpdate = t.autoUpdate, this }, addLevel: function (t, e) { void 0 === e && (e = 0), e = Math.abs(e); const n = this.levels; let i; for (i = 0; i < n.length && !(e < n[i].distance); i++); return n.splice(i, 0, { distance: e, object: t }), this.add(t), this }, getCurrentLevel: function () { return this._currentLevel }, getObjectForDistance: function (t) { const e = this.levels; if (e.length > 0) { let n, i; for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++); return e[n - 1].object } return null }, raycast: function (t, e) { if (this.levels.length > 0) { hc.setFromMatrixPosition(this.matrixWorld); const n = t.ray.origin.distanceTo(hc); this.getObjectForDistance(n).raycast(t, e) } }, update: function (t) { const e = this.levels; if (e.length > 1) { hc.setFromMatrixPosition(t.matrixWorld), dc.setFromMatrixPosition(this.matrixWorld); const n = hc.distanceTo(dc) / t.zoom; let i, r; for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++)e[i - 1].object.visible = !1, e[i].object.visible = !0; for (this._currentLevel = i - 1; i < r; i++)e[i].object.visible = !1 } }, toJSON: function (t) { const e = wi.prototype.toJSON.call(this, t); !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = []; const n = this.levels; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; e.object.levels.push({ object: i.object.uuid, distance: i.distance }) } return e } }), pc.prototype = Object.assign(Object.create(so.prototype), { constructor: pc, isSkinnedMesh: !0, copy: function (t) { return so.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this }, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { const t = new Vn, e = this.geometry.attributes.skinWeight; for (let n = 0, i = e.count; n < i; n++) { t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n); const i = 1 / t.manhattanLength(); i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w) } }, updateMatrixWorld: function (t) { so.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, boneTransform: function () { const t = new Jn, e = new Vn, n = new Vn, i = new Jn, r = new ri; return function (o, s) { const a = this.skeleton, c = this.geometry; e.fromBufferAttribute(c.attributes.skinIndex, o), n.fromBufferAttribute(c.attributes.skinWeight, o), t.fromBufferAttribute(c.attributes.position, o).applyMatrix4(this.bindMatrix), s.set(0, 0, 0); for (let o = 0; o < 4; o++) { const c = n.getComponent(o); if (0 !== c) { const n = e.getComponent(o); r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]), s.addScaledVector(i.copy(t).applyMatrix4(r), c) } } return s.applyMatrix4(this.bindMatrixInverse) } }() }); const mc = new ri, gc = new ri; function vc(t, e) { if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++)this.boneInverses.push(new ri) } } function yc() { wi.call(this), this.type = "Bone" } Object.assign(vc.prototype, { calculateInverses: function () { this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++) { const e = new ri; this.bones[t] && e.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(e) } }, pose: function () { for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && e.matrixWorld.getInverse(this.boneInverses[t]) } for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) } }, update: function () { const t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture; for (let i = 0, r = t.length; i < r; i++) { const r = t[i] ? t[i].matrixWorld : gc; mc.multiplyMatrices(r, e[i]), mc.toArray(n, 16 * i) } void 0 !== i && (i.needsUpdate = !0) }, clone: function () { return new vc(this.bones, this.boneInverses) }, getBoneByName: function (t) { for (let e = 0, n = this.bones.length; e < n; e++) { const n = this.bones[e]; if (n.name === t) return n } }, dispose: function () { this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0) } }), yc.prototype = Object.assign(Object.create(wi.prototype), { constructor: yc, isBone: !0 }); const _c = new ri, xc = new ri, bc = [], wc = new so; function Mc(t, e, n) { so.call(this, t, e), this.instanceMatrix = new Mr(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1 } function Tc(t) { _r.call(this), this.type = "LineBasicMaterial", this.color = new fr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t) } Mc.prototype = Object.assign(Object.create(so.prototype), { constructor: Mc, isInstancedMesh: !0, copy: function (t) { return so.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this }, getMatrixAt: function (t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) }, raycast: function (t, e) { const n = this.matrixWorld, i = this.count; if (wc.geometry = this.geometry, wc.material = this.material, void 0 !== wc.material) for (let r = 0; r < i; r++) { this.getMatrixAt(r, _c), xc.multiplyMatrices(n, _c), wc.matrixWorld = xc, wc.raycast(t, bc); for (let t = 0, n = bc.length; t < n; t++) { const n = bc[t]; n.instanceId = r, n.object = this, e.push(n) } bc.length = 0 } }, setMatrixAt: function (t, e) { e.toArray(this.instanceMatrix.array, 16 * t) }, updateMorphTargets: function () { } }), Tc.prototype = Object.create(_r.prototype), Tc.prototype.constructor = Tc, Tc.prototype.isLineBasicMaterial = !0, Tc.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this }; const Sc = new Jn, Ec = new Jn, Ac = new ri, Pc = new Yi, Lc = new Ui; function Rc(t, e, n) { 1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), wi.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Gr, this.material = void 0 !== e ? e : new Tc, this.updateMorphTargets() } Rc.prototype = Object.assign(Object.create(wi.prototype), { constructor: Rc, isLine: !0, copy: function (t) { return wi.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this }, computeLineDistances: function () { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, n = [0]; for (let t = 1, i = e.count; t < i; t++)Sc.fromBufferAttribute(e, t - 1), Ec.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Sc.distanceTo(Ec); t.setAttribute("lineDistance", new Or(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { const e = t.vertices, n = t.lineDistances; n[0] = 0; for (let t = 1, i = e.length; t < i; t++)n[t] = n[t - 1], n[t] += e[t - 1].distanceTo(e[t]) } return this }, raycast: function (t, e) { const n = this.geometry, i = this.matrixWorld, r = t.params.Line.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), Lc.copy(n.boundingSphere), Lc.applyMatrix4(i), Lc.radius += r, !1 === t.ray.intersectsSphere(Lc)) return; Ac.getInverse(i), Pc.copy(t.ray).applyMatrix4(Ac); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o, a = new Jn, c = new Jn, l = new Jn, u = new Jn, h = this && this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { const i = n.index, r = n.attributes.position.array; if (null !== i) { const n = i.array; for (let i = 0, o = n.length - 1; i < o; i += h) { const o = n[i], h = n[i + 1]; if (a.fromArray(r, 3 * o), c.fromArray(r, 3 * h), Pc.distanceSqToSegment(a, c, u, l) > s) continue; u.applyMatrix4(this.matrixWorld); const d = t.ray.origin.distanceTo(u); d < t.near || d > t.far || e.push({ distance: d, point: l.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this }) } } else for (let n = 0, i = r.length / 3 - 1; n < i; n += h) { if (a.fromArray(r, 3 * n), c.fromArray(r, 3 * n + 3), Pc.distanceSqToSegment(a, c, u, l) > s) continue; u.applyMatrix4(this.matrixWorld); const i = t.ray.origin.distanceTo(u); i < t.near || i > t.far || e.push({ distance: i, point: l.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else if (n.isGeometry) { const i = n.vertices, r = i.length; for (let n = 0; n < r - 1; n += h) { if (Pc.distanceSqToSegment(i[n], i[n + 1], u, l) > s) continue; u.applyMatrix4(this.matrixWorld); const r = t.ray.origin.distanceTo(u); r < t.near || r > t.far || e.push({ distance: r, point: l.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }); const Oc = new Jn, Cc = new Jn; function Ic(t, e) { Rc.call(this, t, e), this.type = "LineSegments" } function Dc(t, e) { Rc.call(this, t, e), this.type = "LineLoop" } function Nc(t) { _r.call(this), this.type = "PointsMaterial", this.color = new fr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) } Ic.prototype = Object.assign(Object.create(Rc.prototype), { constructor: Ic, isLineSegments: !0, computeLineDistances: function () { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, n = []; for (let t = 0, i = e.count; t < i; t += 2)Oc.fromBufferAttribute(e, t), Cc.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Oc.distanceTo(Cc); t.setAttribute("lineDistance", new Or(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) { const e = t.vertices, n = t.lineDistances; for (let t = 0, i = e.length; t < i; t += 2)Oc.copy(e[t]), Cc.copy(e[t + 1]), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Oc.distanceTo(Cc) } return this } }), Dc.prototype = Object.assign(Object.create(Rc.prototype), { constructor: Dc, isLineLoop: !0 }), Nc.prototype = Object.create(_r.prototype), Nc.prototype.constructor = Nc, Nc.prototype.isPointsMaterial = !0, Nc.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }; const kc = new ri, Bc = new Yi, zc = new Ui, Fc = new Jn; function Uc(t, e) { wi.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Gr, this.material = void 0 !== e ? e : new Nc, this.updateMorphTargets() } function Hc(t, e, n, i, r, o, s) { const a = Bc.distanceSqToPoint(t); if (a < n) { const n = new Jn; Bc.closestPointToPoint(t, n), n.applyMatrix4(i); const c = r.ray.origin.distanceTo(n); if (c < r.near || c > r.far) return; o.push({ distance: c, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: s }) } } function Gc(t, e, n, i, r, o, s, a, c) { jn.call(this, t, e, n, i, r, o, s, a, c), this.format = void 0 !== s ? s : Bt, this.minFilter = void 0 !== o ? o : _t, this.magFilter = void 0 !== r ? r : _t, this.generateMipmaps = !1; const l = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() { l.needsUpdate = !0, t.requestVideoFrameCallback(e) })) } function jc(t, e, n, i, r, o, s, a, c, l, u, h) { jn.call(this, null, o, s, a, c, l, i, r, u, h), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } function Vc(t, e, n, i, r, o, s, a, c) { jn.call(this, t, e, n, i, r, o, s, a, c), this.needsUpdate = !0 } function Wc(t, e, n, i, r, o, s, a, c, l) { if ((l = void 0 !== l ? l : Gt) !== Gt && l !== jt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && l === Gt && (n = At), void 0 === n && l === jt && (n = Nt), jn.call(this, null, i, r, o, s, a, l, n, c), this.image = { width: t, height: e }, this.magFilter = void 0 !== s ? s : pt, this.minFilter = void 0 !== a ? a : pt, this.flipY = !1, this.generateMipmaps = !1 } function qc(t) { Gr.call(this), this.type = "WireframeGeometry"; const e = [], n = [0, 0], i = {}, r = ["a", "b", "c"]; if (t && t.isGeometry) { const o = t.faces; for (let t = 0, e = o.length; t < e; t++) { const e = o[t]; for (let t = 0; t < 3; t++) { const o = e[r[t]], s = e[r[(t + 1) % 3]]; n[0] = Math.min(o, s), n[1] = Math.max(o, s); const a = n[0] + "," + n[1]; void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] }) } } for (const n in i) { const r = i[n]; let o = t.vertices[r.index1]; e.push(o.x, o.y, o.z), o = t.vertices[r.index2], e.push(o.x, o.y, o.z) } } else if (t && t.isBufferGeometry) { let r = new Jn; if (null !== t.index) { const o = t.attributes.position, s = t.index; let a = t.groups; 0 === a.length && (a = [{ start: 0, count: s.count, materialIndex: 0 }]); for (let t = 0, e = a.length; t < e; ++t) { const e = a[t], r = e.start; for (let t = r, o = r + e.count; t < o; t += 3)for (let e = 0; e < 3; e++) { const r = s.getX(t + e), o = s.getX(t + (e + 1) % 3); n[0] = Math.min(r, o), n[1] = Math.max(r, o); const a = n[0] + "," + n[1]; void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] }) } } for (const t in i) { const n = i[t]; r.fromBufferAttribute(o, n.index1), e.push(r.x, r.y, r.z), r.fromBufferAttribute(o, n.index2), e.push(r.x, r.y, r.z) } } else { const n = t.attributes.position; for (let t = 0, i = n.count / 3; t < i; t++)for (let i = 0; i < 3; i++) { const o = 3 * t + i; r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z); const s = 3 * t + (i + 1) % 3; r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z) } } } this.setAttribute("position", new Or(e, 3)) } function Xc(t, e, n) { po.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: n }, this.fromBufferGeometry(new Yc(t, e, n)), this.mergeVertices() } function Yc(t, e, n) { Gr.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: n }; const i = [], r = [], o = [], s = [], a = new Jn, c = new Jn, l = new Jn, u = new Jn, h = new Jn; t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); const d = e + 1; for (let i = 0; i <= n; i++) { const d = i / n; for (let n = 0; n <= e; n++) { const i = n / e; t(i, d, c), r.push(c.x, c.y, c.z), i - 1e-5 >= 0 ? (t(i - 1e-5, d, l), u.subVectors(c, l)) : (t(i + 1e-5, d, l), u.subVectors(l, c)), d - 1e-5 >= 0 ? (t(i, d - 1e-5, l), h.subVectors(c, l)) : (t(i, d + 1e-5, l), h.subVectors(l, c)), a.crossVectors(u, h).normalize(), o.push(a.x, a.y, a.z), s.push(i, d) } } for (let t = 0; t < n; t++)for (let n = 0; n < e; n++) { const e = t * d + n, r = t * d + n + 1, o = (t + 1) * d + n + 1, s = (t + 1) * d + n; i.push(e, r, s), i.push(r, o, s) } this.setIndex(i), this.setAttribute("position", new Or(r, 3)), this.setAttribute("normal", new Or(o, 3)), this.setAttribute("uv", new Or(s, 2)) } function Zc(t, e, n, i) { po.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: i }, this.fromBufferGeometry(new Jc(t, e, n, i)), this.mergeVertices() } function Jc(t, e, n, i) { Gr.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: i }, n = n || 1; const r = [], o = []; function s(t, e, n, i) { const r = Math.pow(2, i), o = []; for (let i = 0; i <= r; i++) { o[i] = []; const s = t.clone().lerp(n, i / r), a = e.clone().lerp(n, i / r), c = r - i; for (let t = 0; t <= c; t++)o[i][t] = 0 === t && i === r ? s : s.clone().lerp(a, t / c) } for (let t = 0; t < r; t++)for (let e = 0; e < 2 * (r - t) - 1; e++) { const n = Math.floor(e / 2); e % 2 == 0 ? (a(o[t][n + 1]), a(o[t + 1][n]), a(o[t][n])) : (a(o[t][n + 1]), a(o[t + 1][n + 1]), a(o[t + 1][n])) } } function a(t) { r.push(t.x, t.y, t.z) } function c(e, n) { const i = 3 * e; n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2] } function l(t, e, n, i) { i < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5) } function u(t) { return Math.atan2(t.z, -t.x) } !function (t) { const n = new Jn, i = new Jn, r = new Jn; for (let o = 0; o < e.length; o += 3)c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), s(n, i, r, t) }(i = i || 0), function (t) { const e = new Jn; for (let n = 0; n < r.length; n += 3)e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z }(n), function () { const t = new Jn; for (let n = 0; n < r.length; n += 3) { t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2]; const i = u(t) / 2 / Math.PI + .5, s = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5); o.push(i, 1 - s) } var e; (function () { const t = new Jn, e = new Jn, n = new Jn, i = new Jn, s = new zn, a = new zn, c = new zn; for (let h = 0, d = 0; h < r.length; h += 9, d += 6) { t.set(r[h + 0], r[h + 1], r[h + 2]), e.set(r[h + 3], r[h + 4], r[h + 5]), n.set(r[h + 6], r[h + 7], r[h + 8]), s.set(o[d + 0], o[d + 1]), a.set(o[d + 2], o[d + 3]), c.set(o[d + 4], o[d + 5]), i.copy(t).add(e).add(n).divideScalar(3); const f = u(i); l(s, d + 0, t, f), l(a, d + 2, e, f), l(c, d + 4, n, f) } })(), function () { for (let t = 0; t < o.length; t += 6) { const e = o[t + 0], n = o[t + 2], i = o[t + 4], r = Math.max(e, n, i), s = Math.min(e, n, i); r > .9 && s < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), i < .2 && (o[t + 4] += 1)) } }() }(), this.setAttribute("position", new Or(r, 3)), this.setAttribute("normal", new Or(r.slice(), 3)), this.setAttribute("uv", new Or(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals() } function Qc(t, e) { po.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new $c(t, e)), this.mergeVertices() } function $c(t, e) { Jc.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function Kc(t, e) { po.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new tl(t, e)), this.mergeVertices() } function tl(t, e) { Jc.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function el(t, e) { po.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new nl(t, e)), this.mergeVertices() } function nl(t, e) { const n = (1 + Math.sqrt(5)) / 2, i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1]; Jc.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function il(t, e) { po.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new rl(t, e)), this.mergeVertices() } function rl(t, e) { const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i]; Jc.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function ol(t, e, n, i, r, o) { po.call(this), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."); const s = new sl(t, e, n, i, r); this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices() } function sl(t, e, n, i, r) { Gr.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r }, e = e || 64, n = n || 1, i = i || 8, r = r || !1; const o = t.computeFrenetFrames(e, r); this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals; const s = new Jn, a = new Jn, c = new zn; let l = new Jn; const u = [], h = [], d = [], f = []; function p(r) { l = t.getPointAt(r / e, l); const c = o.normals[r], d = o.binormals[r]; for (let t = 0; t <= i; t++) { const e = t / i * Math.PI * 2, r = Math.sin(e), o = -Math.cos(e); a.x = o * c.x + r * d.x, a.y = o * c.y + r * d.y, a.z = o * c.z + r * d.z, a.normalize(), h.push(a.x, a.y, a.z), s.x = l.x + n * a.x, s.y = l.y + n * a.y, s.z = l.z + n * a.z, u.push(s.x, s.y, s.z) } } !function () { for (let t = 0; t < e; t++)p(t); p(!1 === r ? e : 0), function () { for (let t = 0; t <= e; t++)for (let n = 0; n <= i; n++)c.x = t / e, c.y = n / i, d.push(c.x, c.y) }(), function () { for (let t = 1; t <= e; t++)for (let e = 1; e <= i; e++) { const n = (i + 1) * (t - 1) + (e - 1), r = (i + 1) * t + (e - 1), o = (i + 1) * t + e, s = (i + 1) * (t - 1) + e; f.push(n, r, s), f.push(r, o, s) } }() }(), this.setIndex(f), this.setAttribute("position", new Or(u, 3)), this.setAttribute("normal", new Or(h, 3)), this.setAttribute("uv", new Or(d, 2)) } function al(t, e, n, i, r, o, s) { po.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: o }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new cl(t, e, n, i, r, o)), this.mergeVertices() } function cl(t, e, n, i, r, o) { Gr.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: o }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3; const s = [], a = [], c = [], l = [], u = new Jn, h = new Jn, d = new Jn, f = new Jn, p = new Jn, m = new Jn, g = new Jn; for (let s = 0; s <= n; ++s) { const y = s / n * r * Math.PI * 2; v(y, r, o, t, d), v(y + .01, r, o, t, f), m.subVectors(f, d), g.addVectors(f, d), p.crossVectors(m, g), g.crossVectors(p, m), p.normalize(), g.normalize(); for (let t = 0; t <= i; ++t) { const r = t / i * Math.PI * 2, o = -e * Math.cos(r), f = e * Math.sin(r); u.x = d.x + (o * g.x + f * p.x), u.y = d.y + (o * g.y + f * p.y), u.z = d.z + (o * g.z + f * p.z), a.push(u.x, u.y, u.z), h.subVectors(u, d).normalize(), c.push(h.x, h.y, h.z), l.push(s / n), l.push(t / i) } } for (let t = 1; t <= n; t++)for (let e = 1; e <= i; e++) { const n = (i + 1) * (t - 1) + (e - 1), r = (i + 1) * t + (e - 1), o = (i + 1) * t + e, a = (i + 1) * (t - 1) + e; s.push(n, r, a), s.push(r, o, a) } function v(t, e, n, i, r) { const o = Math.cos(t), s = Math.sin(t), a = n / e * t, c = Math.cos(a); r.x = i * (2 + c) * .5 * o, r.y = i * (2 + c) * s * .5, r.z = i * Math.sin(a) * .5 } this.setIndex(s), this.setAttribute("position", new Or(a, 3)), this.setAttribute("normal", new Or(c, 3)), this.setAttribute("uv", new Or(l, 2)) } function ll(t, e, n, i, r) { po.call(this), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, this.fromBufferGeometry(new ul(t, e, n, i, r)), this.mergeVertices() } function ul(t, e, n, i, r) { Gr.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI; const o = [], s = [], a = [], c = [], l = new Jn, u = new Jn, h = new Jn; for (let o = 0; o <= n; o++)for (let d = 0; d <= i; d++) { const f = d / i * r, p = o / n * Math.PI * 2; u.x = (t + e * Math.cos(p)) * Math.cos(f), u.y = (t + e * Math.cos(p)) * Math.sin(f), u.z = e * Math.sin(p), s.push(u.x, u.y, u.z), l.x = t * Math.cos(f), l.y = t * Math.sin(f), h.subVectors(u, l).normalize(), a.push(h.x, h.y, h.z), c.push(d / i), c.push(o / n) } for (let t = 1; t <= n; t++)for (let e = 1; e <= i; e++) { const n = (i + 1) * t + e - 1, r = (i + 1) * (t - 1) + e - 1, s = (i + 1) * (t - 1) + e, a = (i + 1) * t + e; o.push(n, r, a), o.push(r, s, a) } this.setIndex(o), this.setAttribute("position", new Or(s, 3)), this.setAttribute("normal", new Or(a, 3)), this.setAttribute("uv", new Or(c, 2)) } Uc.prototype = Object.assign(Object.create(wi.prototype), { constructor: Uc, isPoints: !0, copy: function (t) { return wi.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this }, raycast: function (t, e) { const n = this.geometry, i = this.matrixWorld, r = t.params.Points.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), zc.copy(n.boundingSphere), zc.applyMatrix4(i), zc.radius += r, !1 === t.ray.intersectsSphere(zc)) return; kc.getInverse(i), Bc.copy(t.ray).applyMatrix4(kc); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o; if (n.isBufferGeometry) { const r = n.index, o = n.attributes.position.array; if (null !== r) { const n = r.array; for (let r = 0, a = n.length; r < a; r++) { const a = n[r]; Fc.fromArray(o, 3 * a), Hc(Fc, a, s, i, t, e, this) } } else for (let n = 0, r = o.length / 3; n < r; n++)Fc.fromArray(o, 3 * n), Hc(Fc, n, s, i, t, e, this) } else { const r = n.vertices; for (let n = 0, o = r.length; n < o; n++)Hc(r[n], n, s, i, t, e, this) } }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }), Gc.prototype = Object.assign(Object.create(jn.prototype), { constructor: Gc, isVideoTexture: !0, update: function () { const t = this.image; !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), jc.prototype = Object.create(jn.prototype), jc.prototype.constructor = jc, jc.prototype.isCompressedTexture = !0, Vc.prototype = Object.create(jn.prototype), Vc.prototype.constructor = Vc, Vc.prototype.isCanvasTexture = !0, Wc.prototype = Object.create(jn.prototype), Wc.prototype.constructor = Wc, Wc.prototype.isDepthTexture = !0, qc.prototype = Object.create(Gr.prototype), qc.prototype.constructor = qc, Xc.prototype = Object.create(po.prototype), Xc.prototype.constructor = Xc, Yc.prototype = Object.create(Gr.prototype), Yc.prototype.constructor = Yc, Zc.prototype = Object.create(po.prototype), Zc.prototype.constructor = Zc, Jc.prototype = Object.create(Gr.prototype), Jc.prototype.constructor = Jc, Qc.prototype = Object.create(po.prototype), Qc.prototype.constructor = Qc, $c.prototype = Object.create(Jc.prototype), $c.prototype.constructor = $c, Kc.prototype = Object.create(po.prototype), Kc.prototype.constructor = Kc, tl.prototype = Object.create(Jc.prototype), tl.prototype.constructor = tl, el.prototype = Object.create(po.prototype), el.prototype.constructor = el, nl.prototype = Object.create(Jc.prototype), nl.prototype.constructor = nl, il.prototype = Object.create(po.prototype), il.prototype.constructor = il, rl.prototype = Object.create(Jc.prototype), rl.prototype.constructor = rl, ol.prototype = Object.create(po.prototype), ol.prototype.constructor = ol, sl.prototype = Object.create(Gr.prototype), sl.prototype.constructor = sl, sl.prototype.toJSON = function () { const t = Gr.prototype.toJSON.call(this); return t.path = this.parameters.path.toJSON(), t }, al.prototype = Object.create(po.prototype), al.prototype.constructor = al, cl.prototype = Object.create(Gr.prototype), cl.prototype.constructor = cl, ll.prototype = Object.create(po.prototype), ll.prototype.constructor = ll, ul.prototype = Object.create(Gr.prototype), ul.prototype.constructor = ul; const hl = function (t, e, n) { n = n || 2; let i, r, o, s, a, c, l, u = e && e.length, h = u ? e[0] * n : t.length, d = dl(t, 0, h, n, !0), f = []; if (!d || d.next === d.prev) return f; if (u && (d = function (t, e, n, i) { let r, o, s, a, c, l = []; for (r = 0, o = e.length; r < o; r++)s = e[r] * i, a = r < o - 1 ? e[r + 1] * i : t.length, (c = dl(t, s, a, i, !1)) === c.next && (c.steiner = !0), l.push(Ml(c)); for (l.sort(_l), r = 0; r < l.length; r++)xl(l[r], n), n = fl(n, n.next); return n }(t, e, d, n)), t.length > 80 * n) { i = o = t[0], r = s = t[1]; for (let e = n; e < h; e += n)(a = t[e]) < i && (i = a), (c = t[e + 1]) < r && (r = c), a > o && (o = a), c > s && (s = c); l = 0 !== (l = Math.max(o - i, s - r)) ? 1 / l : 0 } return pl(d, f, n, i, r, l), f }; function dl(t, e, n, i, r) { let o, s; if (r === function (t, e, n, i) { let r = 0; for (let o = e, s = n - i; o < n; o += i)r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o; return r }(t, e, n, i) > 0) for (o = e; o < n; o += i)s = Il(o, t[o], t[o + 1], s); else for (o = n - i; o >= e; o -= i)s = Il(o, t[o], t[o + 1], s); return s && Al(s, s.next) && (Dl(s), s = s.next), s } function fl(t, e) { if (!t) return t; e || (e = t); let n, i = t; do { if (n = !1, i.steiner || !Al(i, i.next) && 0 !== El(i.prev, i, i.next)) i = i.next; else { if (Dl(i), (i = e = i.prev) === i.next) break; n = !0 } } while (n || i !== e); return e } function pl(t, e, n, i, r, o, s) { if (!t) return; !s && o && function (t, e, n, i) { let r = t; do { null === r.z && (r.z = wl(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== t); r.prevZ.nextZ = null, r.prevZ = null, function (t) { let e, n, i, r, o, s, a, c, l = 1; do { for (n = t, t = null, o = null, s = 0; n;) { for (s++, i = n, a = 0, e = 0; e < l && (a++, i = i.nextZ); e++); for (c = l; a > 0 || c > 0 && i;)0 !== a && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r; n = i } o.nextZ = null, l *= 2 } while (s > 1) }(r) }(t, i, r, o); let a, c, l = t; for (; t.prev !== t.next;)if (a = t.prev, c = t.next, o ? gl(t, i, r, o) : ml(t)) e.push(a.i / n), e.push(t.i / n), e.push(c.i / n), Dl(t), t = c.next, l = c.next; else if ((t = c) === l) { s ? 1 === s ? pl(t = vl(fl(t), e, n), e, n, i, r, o, 2) : 2 === s && yl(t, e, n, i, r, o) : pl(fl(t), e, n, i, r, o, 1); break } } function ml(t) { let e = t.prev, n = t, i = t.next; if (El(e, n, i) >= 0) return !1; let r = t.next.next; for (; r !== t.prev;) { if (Tl(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && El(r.prev, r, r.next) >= 0) return !1; r = r.next } return !0 } function gl(t, e, n, i) { let r = t.prev, o = t, s = t.next; if (El(r, o, s) >= 0) return !1; let a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x, c = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y, l = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x, u = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y, h = wl(a, c, e, n, i), d = wl(l, u, e, n, i), f = t.prevZ, p = t.nextZ; for (; f && f.z >= h && p && p.z <= d;) { if (f !== t.prev && f !== t.next && Tl(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && El(f.prev, f, f.next) >= 0) return !1; if (f = f.prevZ, p !== t.prev && p !== t.next && Tl(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && El(p.prev, p, p.next) >= 0) return !1; p = p.nextZ } for (; f && f.z >= h;) { if (f !== t.prev && f !== t.next && Tl(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && El(f.prev, f, f.next) >= 0) return !1; f = f.prevZ } for (; p && p.z <= d;) { if (p !== t.prev && p !== t.next && Tl(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && El(p.prev, p, p.next) >= 0) return !1; p = p.nextZ } return !0 } function vl(t, e, n) { let i = t; do { let r = i.prev, o = i.next.next; !Al(r, o) && Pl(r, i, i.next, o) && Ol(r, o) && Ol(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), Dl(i), Dl(i.next), i = t = o), i = i.next } while (i !== t); return fl(i) } function yl(t, e, n, i, r, o) { let s = t; do { let t = s.next.next; for (; t !== s.prev;) { if (s.i !== t.i && Sl(s, t)) { let a = Cl(s, t); return s = fl(s, s.next), a = fl(a, a.next), pl(s, e, n, i, r, o), void pl(a, e, n, i, r, o) } t = t.next } s = s.next } while (s !== t) } function _l(t, e) { return t.x - e.x } function xl(t, e) { if (e = function (t, e) { let n, i = e, r = t.x, o = t.y, s = -1 / 0; do { if (o <= i.y && o >= i.next.y && i.next.y !== i.y) { let t = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (t <= r && t > s) { if (s = t, t === r) { if (o === i.y) return i; if (o === i.next.y) return i.next } n = i.x < i.next.x ? i : i.next } } i = i.next } while (i !== e); if (!n) return null; if (r === s) return n; let a, c = n, l = n.x, u = n.y, h = 1 / 0; i = n; do { r >= i.x && i.x >= l && r !== i.x && Tl(o < u ? r : s, o, l, u, o < u ? s : r, o, i.x, i.y) && (a = Math.abs(o - i.y) / (r - i.x), Ol(i, t) && (a < h || a === h && (i.x > n.x || i.x === n.x && bl(n, i))) && (n = i, h = a)), i = i.next } while (i !== c); return n }(t, e)) { const n = Cl(e, t); fl(e, e.next), fl(n, n.next) } } function bl(t, e) { return El(t.prev, t, e.prev) < 0 && El(e.next, t, t.next) < 0 } function wl(t, e, n, i, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function Ml(t) { let e = t, n = t; do { (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next } while (e !== t); return n } function Tl(t, e, n, i, r, o, s, a) { return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0 } function Sl(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { let n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Pl(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 }(t, e) && (Ol(t, e) && Ol(e, t) && function (t, e) { let n = t, i = !1, r = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next } while (n !== t); return i }(t, e) && (El(t.prev, t, e.prev) || El(t, e.prev, e)) || Al(t, e) && El(t.prev, t, t.next) > 0 && El(e.prev, e, e.next) > 0) } function El(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function Al(t, e) { return t.x === e.x && t.y === e.y } function Pl(t, e, n, i) { const r = Rl(El(t, e, n)), o = Rl(El(t, e, i)), s = Rl(El(n, i, t)), a = Rl(El(n, i, e)); return r !== o && s !== a || (!(0 !== r || !Ll(t, n, e)) || (!(0 !== o || !Ll(t, i, e)) || (!(0 !== s || !Ll(n, t, i)) || !(0 !== a || !Ll(n, e, i))))) } function Ll(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function Rl(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function Ol(t, e) { return El(t.prev, t, t.next) < 0 ? El(t, e, t.next) >= 0 && El(t, t.prev, e) >= 0 : El(t, e, t.prev) < 0 || El(t, t.next, e) < 0 } function Cl(t, e) { let n = new Nl(t.i, t.x, t.y), i = new Nl(e.i, e.x, e.y), r = t.next, o = e.prev; return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i } function Il(t, e, n, i) { const r = new Nl(t, e, n); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r } function Dl(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Nl(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } const kl = { area: function (t) { const e = t.length; let n = 0; for (let i = e - 1, r = 0; r < e; i = r++)n += t[i].x * t[r].y - t[r].x * t[i].y; return .5 * n }, isClockWise: function (t) { return kl.area(t) < 0 }, triangulateShape: function (t, e) { const n = [], i = [], r = []; Bl(t), zl(n, t); let o = t.length; e.forEach(Bl); for (let t = 0; t < e.length; t++)i.push(o), o += e[t].length, zl(n, e[t]); const s = hl(n, i); for (let t = 0; t < s.length; t += 3)r.push(s.slice(t, t + 3)); return r } }; function Bl(t) { const e = t.length; e > 2 && t[e - 1].equals(t[0]) && t.pop() } function zl(t, e) { for (let n = 0; n < e.length; n++)t.push(e[n].x), t.push(e[n].y) } function Fl(t, e) { po.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new Ul(t, e)), this.mergeVertices() } function Ul(t, e) { Gr.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t]; const n = this, i = [], r = []; for (let e = 0, n = t.length; e < n; e++) { o(t[e]) } function o(t) { const o = [], s = void 0 !== e.curveSegments ? e.curveSegments : 12, a = void 0 !== e.steps ? e.steps : 1; let c = void 0 !== e.depth ? e.depth : 100, l = void 0 === e.bevelEnabled || e.bevelEnabled, u = void 0 !== e.bevelThickness ? e.bevelThickness : 6, h = void 0 !== e.bevelSize ? e.bevelSize : u - 2, d = void 0 !== e.bevelOffset ? e.bevelOffset : 0, f = void 0 !== e.bevelSegments ? e.bevelSegments : 3; const p = e.extrudePath, m = void 0 !== e.UVGenerator ? e.UVGenerator : Hl; void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount); let g, v, y, _, x, b = !1; p && (g = p.getSpacedPoints(a), b = !0, l = !1, v = p.computeFrenetFrames(a, !1), y = new Jn, _ = new Jn, x = new Jn), l || (f = 0, u = 0, h = 0, d = 0); const w = t.extractPoints(s); let M = w.shape; const T = w.holes; if (!kl.isClockWise(M)) { M = M.reverse(); for (let t = 0, e = T.length; t < e; t++) { const e = T[t]; kl.isClockWise(e) && (T[t] = e.reverse()) } } const S = kl.triangulateShape(M, T), E = M; for (let t = 0, e = T.length; t < e; t++) { const e = T[t]; M = M.concat(e) } function A(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) } const P = M.length, L = S.length; function R(t, e, n) { let i, r, o; const s = t.x - e.x, a = t.y - e.y, c = n.x - t.x, l = n.y - t.y, u = s * s + a * a, h = s * l - a * c; if (Math.abs(h) > Number.EPSILON) { const h = Math.sqrt(u), d = Math.sqrt(c * c + l * l), f = e.x - a / h, p = e.y + s / h, m = ((n.x - l / d - f) * l - (n.y + c / d - p) * c) / (s * l - a * c), g = (i = f + s * m - t.x) * i + (r = p + a * m - t.y) * r; if (g <= 2) return new zn(i, r); o = Math.sqrt(g / 2) } else { let t = !1; s > Number.EPSILON ? c > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(l) && (t = !0), t ? (i = -a, r = s, o = Math.sqrt(u)) : (i = s, r = a, o = Math.sqrt(u / 2)) } return new zn(i / o, r / o) } const O = []; for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++, n++, i++)n === e && (n = 0), i === e && (i = 0), O[t] = R(E[t], E[n], E[i]); const C = []; let I, D = O.concat(); for (let t = 0, e = T.length; t < e; t++) { const e = T[t]; I = []; for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++)i === n && (i = 0), r === n && (r = 0), I[t] = R(e[t], e[i], e[r]); C.push(I), D = D.concat(I) } for (let t = 0; t < f; t++) { const e = t / f, n = u * Math.cos(e * Math.PI / 2), i = h * Math.sin(e * Math.PI / 2) + d; for (let t = 0, e = E.length; t < e; t++) { const e = A(E[t], O[t], i); B(e.x, e.y, -n) } for (let t = 0, e = T.length; t < e; t++) { const e = T[t]; I = C[t]; for (let t = 0, r = e.length; t < r; t++) { const r = A(e[t], I[t], i); B(r.x, r.y, -n) } } } const N = h + d; for (let t = 0; t < P; t++) { const e = l ? A(M[t], D[t], N) : M[t]; b ? (_.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), x.copy(g[0]).add(_).add(y), B(x.x, x.y, x.z)) : B(e.x, e.y, 0) } for (let t = 1; t <= a; t++)for (let e = 0; e < P; e++) { const n = l ? A(M[e], D[e], N) : M[e]; b ? (_.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), x.copy(g[t]).add(_).add(y), B(x.x, x.y, x.z)) : B(n.x, n.y, c / a * t) } for (let t = f - 1; t >= 0; t--) { const e = t / f, n = u * Math.cos(e * Math.PI / 2), i = h * Math.sin(e * Math.PI / 2) + d; for (let t = 0, e = E.length; t < e; t++) { const e = A(E[t], O[t], i); B(e.x, e.y, c + n) } for (let t = 0, e = T.length; t < e; t++) { const e = T[t]; I = C[t]; for (let t = 0, r = e.length; t < r; t++) { const r = A(e[t], I[t], i); b ? B(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : B(r.x, r.y, c + n) } } } function k(t, e) { let n = t.length; for (; --n >= 0;) { const i = n; let r = n - 1; r < 0 && (r = t.length - 1); for (let t = 0, n = a + 2 * f; t < n; t++) { const n = P * t, o = P * (t + 1); F(e + i + n, e + r + n, e + r + o, e + i + o) } } } function B(t, e, n) { o.push(t), o.push(e), o.push(n) } function z(t, e, r) { U(t), U(e), U(r); const o = i.length / 3, s = m.generateTopUV(n, i, o - 3, o - 2, o - 1); H(s[0]), H(s[1]), H(s[2]) } function F(t, e, r, o) { U(t), U(e), U(o), U(e), U(r), U(o); const s = i.length / 3, a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1); H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3]) } function U(t) { i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2]) } function H(t) { r.push(t.x), r.push(t.y) } !function () { const t = i.length / 3; if (l) { let t = 0, e = P * t; for (let t = 0; t < L; t++) { const n = S[t]; z(n[2] + e, n[1] + e, n[0] + e) } e = P * (t = a + 2 * f); for (let t = 0; t < L; t++) { const n = S[t]; z(n[0] + e, n[1] + e, n[2] + e) } } else { for (let t = 0; t < L; t++) { const e = S[t]; z(e[2], e[1], e[0]) } for (let t = 0; t < L; t++) { const e = S[t]; z(e[0] + P * a, e[1] + P * a, e[2] + P * a) } } n.addGroup(t, i.length / 3 - t, 0) }(), function () { const t = i.length / 3; let e = 0; k(E, e), e += E.length; for (let t = 0, n = T.length; t < n; t++) { const n = T[t]; k(n, e), e += n.length } n.addGroup(t, i.length / 3 - t, 1) }() } this.setAttribute("position", new Or(i, 3)), this.setAttribute("uv", new Or(r, 2)), this.computeVertexNormals() } Fl.prototype = Object.create(po.prototype), Fl.prototype.constructor = Fl, Fl.prototype.toJSON = function () { const t = po.prototype.toJSON.call(this); return Gl(this.parameters.shapes, this.parameters.options, t) }, Ul.prototype = Object.create(Gr.prototype), Ul.prototype.constructor = Ul, Ul.prototype.toJSON = function () { const t = Gr.prototype.toJSON.call(this); return Gl(this.parameters.shapes, this.parameters.options, t) }; const Hl = { generateTopUV: function (t, e, n, i, r) { const o = e[3 * n], s = e[3 * n + 1], a = e[3 * i], c = e[3 * i + 1], l = e[3 * r], u = e[3 * r + 1]; return [new zn(o, s), new zn(a, c), new zn(l, u)] }, generateSideWallUV: function (t, e, n, i, r, o) { const s = e[3 * n], a = e[3 * n + 1], c = e[3 * n + 2], l = e[3 * i], u = e[3 * i + 1], h = e[3 * i + 2], d = e[3 * r], f = e[3 * r + 1], p = e[3 * r + 2], m = e[3 * o], g = e[3 * o + 1], v = e[3 * o + 2]; return Math.abs(a - u) < .01 ? [new zn(s, 1 - c), new zn(l, 1 - h), new zn(d, 1 - p), new zn(m, 1 - v)] : [new zn(a, 1 - c), new zn(u, 1 - h), new zn(f, 1 - p), new zn(g, 1 - v)] } }; function Gl(t, e, n) { if (n.shapes = [], Array.isArray(t)) for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; n.shapes.push(i.uuid) } else n.shapes.push(t.uuid); return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n } function jl(t, e) { po.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new Vl(t, e)), this.mergeVertices() } function Vl(t, e) { const n = (e = e || {}).font; if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new po; const i = n.generateShapes(t, e.size); e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Ul.call(this, i, e), this.type = "TextBufferGeometry" } function Wl(t, e, n, i, r, o, s) { po.call(this), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: o, thetaLength: s }, this.fromBufferGeometry(new ql(t, e, n, i, r, o, s)), this.mergeVertices() } function ql(t, e, n, i, r, o, s) { Gr.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: o, thetaLength: s }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : Math.PI; const a = Math.min(o + s, Math.PI); let c = 0; const l = [], u = new Jn, h = new Jn, d = [], f = [], p = [], m = []; for (let d = 0; d <= n; d++) { const g = [], v = d / n; let y = 0; 0 == d && 0 == o ? y = .5 / e : d == n && a == Math.PI && (y = -.5 / e); for (let n = 0; n <= e; n++) { const a = n / e; u.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s), u.y = t * Math.cos(o + v * s), u.z = t * Math.sin(i + a * r) * Math.sin(o + v * s), f.push(u.x, u.y, u.z), h.copy(u).normalize(), p.push(h.x, h.y, h.z), m.push(a + y, 1 - v), g.push(c++) } l.push(g) } for (let t = 0; t < n; t++)for (let i = 0; i < e; i++) { const e = l[t][i + 1], r = l[t][i], s = l[t + 1][i], c = l[t + 1][i + 1]; (0 !== t || o > 0) && d.push(e, r, c), (t !== n - 1 || a < Math.PI) && d.push(r, s, c) } this.setIndex(d), this.setAttribute("position", new Or(f, 3)), this.setAttribute("normal", new Or(p, 3)), this.setAttribute("uv", new Or(m, 2)) } function Xl(t, e, n, i, r, o) { po.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: o }, this.fromBufferGeometry(new Yl(t, e, n, i, r, o)), this.mergeVertices() } function Yl(t, e, n, i, r, o) { Gr.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: o }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8; const s = [], a = [], c = [], l = []; let u = t; const h = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1), d = new Jn, f = new zn; for (let t = 0; t <= i; t++) { for (let t = 0; t <= n; t++) { const i = r + t / n * o; d.x = u * Math.cos(i), d.y = u * Math.sin(i), a.push(d.x, d.y, d.z), c.push(0, 0, 1), f.x = (d.x / e + 1) / 2, f.y = (d.y / e + 1) / 2, l.push(f.x, f.y) } u += h } for (let t = 0; t < i; t++) { const e = t * (n + 1); for (let t = 0; t < n; t++) { const i = t + e, r = i, o = i + n + 1, a = i + n + 2, c = i + 1; s.push(r, o, c), s.push(o, a, c) } } this.setIndex(s), this.setAttribute("position", new Or(a, 3)), this.setAttribute("normal", new Or(c, 3)), this.setAttribute("uv", new Or(l, 2)) } function Zl(t, e, n, i) { po.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, this.fromBufferGeometry(new Jl(t, e, n, i)), this.mergeVertices() } function Jl(t, e, n, i) { Gr.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, e = Math.floor(e) || 12, n = n || 0, i = i || 2 * Math.PI, i = Bn.clamp(i, 0, 2 * Math.PI); const r = [], o = [], s = [], a = 1 / e, c = new Jn, l = new zn; for (let r = 0; r <= e; r++) { const u = n + r * a * i, h = Math.sin(u), d = Math.cos(u); for (let n = 0; n <= t.length - 1; n++)c.x = t[n].x * h, c.y = t[n].y, c.z = t[n].x * d, o.push(c.x, c.y, c.z), l.x = r / e, l.y = n / (t.length - 1), s.push(l.x, l.y) } for (let n = 0; n < e; n++)for (let e = 0; e < t.length - 1; e++) { const i = e + n * t.length, o = i, s = i + t.length, a = i + t.length + 1, c = i + 1; r.push(o, s, c), r.push(s, a, c) } if (this.setIndex(r), this.setAttribute("position", new Or(o, 3)), this.setAttribute("uv", new Or(s, 2)), this.computeVertexNormals(), i === 2 * Math.PI) { const n = this.attributes.normal.array, i = new Jn, r = new Jn, o = new Jn, s = e * t.length * 3; for (let e = 0, a = 0; e < t.length; e++, a += 3)i.x = n[a + 0], i.y = n[a + 1], i.z = n[a + 2], r.x = n[s + a + 0], r.y = n[s + a + 1], r.z = n[s + a + 2], o.addVectors(i, r).normalize(), n[a + 0] = n[s + a + 0] = o.x, n[a + 1] = n[s + a + 1] = o.y, n[a + 2] = n[s + a + 2] = o.z } } function Ql(t, e) { po.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new $l(t, e)), this.mergeVertices() } function $l(t, e) { Gr.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: e }, e = e || 12; const n = [], i = [], r = [], o = []; let s = 0, a = 0; if (!1 === Array.isArray(t)) c(t); else for (let e = 0; e < t.length; e++)c(t[e]), this.addGroup(s, a, e), s += a, a = 0; function c(t) { const s = i.length / 3, c = t.extractPoints(e); let l = c.shape; const u = c.holes; !1 === kl.isClockWise(l) && (l = l.reverse()); for (let t = 0, e = u.length; t < e; t++) { const e = u[t]; !0 === kl.isClockWise(e) && (u[t] = e.reverse()) } const h = kl.triangulateShape(l, u); for (let t = 0, e = u.length; t < e; t++) { const e = u[t]; l = l.concat(e) } for (let t = 0, e = l.length; t < e; t++) { const e = l[t]; i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y) } for (let t = 0, e = h.length; t < e; t++) { const e = h[t], i = e[0] + s, r = e[1] + s, o = e[2] + s; n.push(i, r, o), a += 3 } } this.setIndex(n), this.setAttribute("position", new Or(i, 3)), this.setAttribute("normal", new Or(r, 3)), this.setAttribute("uv", new Or(o, 2)) } function Kl(t, e) { if (e.shapes = [], Array.isArray(t)) for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.shapes.push(i.uuid) } else e.shapes.push(t.uuid); return e } function tu(t, e) { Gr.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e }, e = void 0 !== e ? e : 1; const n = [], i = Math.cos(Bn.DEG2RAD * e), r = [0, 0], o = {}; let s, a, c; const l = ["a", "b", "c"]; let u; t.isBufferGeometry ? (u = new po).fromBufferGeometry(t) : u = t.clone(), u.mergeVertices(), u.computeFaceNormals(); const h = u.vertices, d = u.faces; for (let t = 0, e = d.length; t < e; t++) { const e = d[t]; for (let n = 0; n < 3; n++)s = e[l[n]], a = e[l[(n + 1) % 3]], r[0] = Math.min(s, a), r[1] = Math.max(s, a), void 0 === o[c = r[0] + "," + r[1]] ? o[c] = { index1: r[0], index2: r[1], face1: t, face2: void 0 } : o[c].face2 = t } for (c in o) { const t = o[c]; if (void 0 === t.face2 || d[t.face1].normal.dot(d[t.face2].normal) <= i) { let e = h[t.index1]; n.push(e.x, e.y, e.z), e = h[t.index2], n.push(e.x, e.y, e.z) } } this.setAttribute("position", new Or(n, 3)) } function eu(t, e, n, i, r, o, s, a) { po.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: o, thetaStart: s, thetaLength: a }, this.fromBufferGeometry(new nu(t, e, n, i, r, o, s, a)), this.mergeVertices() } function nu(t, e, n, i, r, o, s, a) { Gr.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: o, thetaStart: s, thetaLength: a }; const c = this; t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, i = Math.floor(i) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : 2 * Math.PI; const l = [], u = [], h = [], d = []; let f = 0; const p = [], m = n / 2; let g = 0; function v(n) { let r, o; const p = new zn, v = new Jn; let y = 0; const _ = !0 === n ? t : e, x = !0 === n ? 1 : -1; r = f; for (let t = 1; t <= i; t++)u.push(0, m * x, 0), h.push(0, x, 0), d.push(.5, .5), f++; o = f; for (let t = 0; t <= i; t++) { const e = t / i * a + s, n = Math.cos(e), r = Math.sin(e); v.x = _ * r, v.y = m * x, v.z = _ * n, u.push(v.x, v.y, v.z), h.push(0, x, 0), p.x = .5 * n + .5, p.y = .5 * r * x + .5, d.push(p.x, p.y), f++ } for (let t = 0; t < i; t++) { const e = r + t, i = o + t; !0 === n ? l.push(i, i + 1, e) : l.push(i + 1, i, e), y += 3 } c.addGroup(g, y, !0 === n ? 1 : 2), g += y } !function () { const o = new Jn, v = new Jn; let y = 0; const _ = (e - t) / n; for (let c = 0; c <= r; c++) { const l = [], g = c / r, y = g * (e - t) + t; for (let t = 0; t <= i; t++) { const e = t / i, r = e * a + s, c = Math.sin(r), p = Math.cos(r); v.x = y * c, v.y = -g * n + m, v.z = y * p, u.push(v.x, v.y, v.z), o.set(c, _, p).normalize(), h.push(o.x, o.y, o.z), d.push(e, 1 - g), l.push(f++) } p.push(l) } for (let t = 0; t < i; t++)for (let e = 0; e < r; e++) { const n = p[e][t], i = p[e + 1][t], r = p[e + 1][t + 1], o = p[e][t + 1]; l.push(n, i, o), l.push(i, r, o), y += 6 } c.addGroup(g, y, 0), g += y }(), !1 === o && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(l), this.setAttribute("position", new Or(u, 3)), this.setAttribute("normal", new Or(h, 3)), this.setAttribute("uv", new Or(d, 2)) } function iu(t, e, n, i, r, o, s) { eu.call(this, 0, t, e, n, i, r, o, s), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: o, thetaLength: s } } function ru(t, e, n, i, r, o, s) { nu.call(this, 0, t, e, n, i, r, o, s), this.type = "ConeBufferGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: o, thetaLength: s } } function ou(t, e, n, i) { po.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, this.fromBufferGeometry(new su(t, e, n, i)), this.mergeVertices() } function su(t, e, n, i) { Gr.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI; const r = [], o = [], s = [], a = [], c = new Jn, l = new zn; o.push(0, 0, 0), s.push(0, 0, 1), a.push(.5, .5); for (let r = 0, u = 3; r <= e; r++, u += 3) { const h = n + r / e * i; c.x = t * Math.cos(h), c.y = t * Math.sin(h), o.push(c.x, c.y, c.z), s.push(0, 0, 1), l.x = (o[u] / t + 1) / 2, l.y = (o[u + 1] / t + 1) / 2, a.push(l.x, l.y) } for (let t = 1; t <= e; t++)r.push(t, t + 1, 0); this.setIndex(r), this.setAttribute("position", new Or(o, 3)), this.setAttribute("normal", new Or(s, 3)), this.setAttribute("uv", new Or(a, 2)) } jl.prototype = Object.create(po.prototype), jl.prototype.constructor = jl, Vl.prototype = Object.create(Ul.prototype), Vl.prototype.constructor = Vl, Wl.prototype = Object.create(po.prototype), Wl.prototype.constructor = Wl, ql.prototype = Object.create(Gr.prototype), ql.prototype.constructor = ql, Xl.prototype = Object.create(po.prototype), Xl.prototype.constructor = Xl, Yl.prototype = Object.create(Gr.prototype), Yl.prototype.constructor = Yl, Zl.prototype = Object.create(po.prototype), Zl.prototype.constructor = Zl, Jl.prototype = Object.create(Gr.prototype), Jl.prototype.constructor = Jl, Ql.prototype = Object.create(po.prototype), Ql.prototype.constructor = Ql, Ql.prototype.toJSON = function () { const t = po.prototype.toJSON.call(this); return Kl(this.parameters.shapes, t) }, $l.prototype = Object.create(Gr.prototype), $l.prototype.constructor = $l, $l.prototype.toJSON = function () { const t = Gr.prototype.toJSON.call(this); return Kl(this.parameters.shapes, t) }, tu.prototype = Object.create(Gr.prototype), tu.prototype.constructor = tu, eu.prototype = Object.create(po.prototype), eu.prototype.constructor = eu, nu.prototype = Object.create(Gr.prototype), nu.prototype.constructor = nu, iu.prototype = Object.create(eu.prototype), iu.prototype.constructor = iu, ru.prototype = Object.create(nu.prototype), ru.prototype.constructor = ru, ou.prototype = Object.create(po.prototype), ou.prototype.constructor = ou, su.prototype = Object.create(Gr.prototype), su.prototype.constructor = su; var au = Object.freeze({ __proto__: null, WireframeGeometry: qc, ParametricGeometry: Xc, ParametricBufferGeometry: Yc, TetrahedronGeometry: Qc, TetrahedronBufferGeometry: $c, OctahedronGeometry: Kc, OctahedronBufferGeometry: tl, IcosahedronGeometry: el, IcosahedronBufferGeometry: nl, DodecahedronGeometry: il, DodecahedronBufferGeometry: rl, PolyhedronGeometry: Zc, PolyhedronBufferGeometry: Jc, TubeGeometry: ol, TubeBufferGeometry: sl, TorusKnotGeometry: al, TorusKnotBufferGeometry: cl, TorusGeometry: ll, TorusBufferGeometry: ul, TextGeometry: jl, TextBufferGeometry: Vl, SphereGeometry: Wl, SphereBufferGeometry: ql, RingGeometry: Xl, RingBufferGeometry: Yl, PlaneGeometry: ko, PlaneBufferGeometry: Bo, LatheGeometry: Zl, LatheBufferGeometry: Jl, ShapeGeometry: Ql, ShapeBufferGeometry: $l, ExtrudeGeometry: Fl, ExtrudeBufferGeometry: Ul, EdgesGeometry: tu, ConeGeometry: iu, ConeBufferGeometry: ru, CylinderGeometry: eu, CylinderBufferGeometry: nu, CircleGeometry: ou, CircleBufferGeometry: su, BoxGeometry: mo, BoxBufferGeometry: go }); function cu(t) { _r.call(this), this.type = "ShadowMaterial", this.color = new fr(0), this.transparent = !0, this.setValues(t) } function lu(t) { wo.call(this, t), this.type = "RawShaderMaterial" } function uu(t) { _r.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new fr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new fr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t) } function hu(t) { uu.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new zn(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t) } function du(t) { _r.call(this), this.type = "MeshPhongMaterial", this.color = new fr(16777215), this.specular = new fr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new fr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function fu(t) { _r.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new fr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new fr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function pu(t) { _r.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function mu(t) { _r.call(this), this.type = "MeshLambertMaterial", this.color = new fr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new fr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Z, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function gu(t) { _r.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new fr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = an, this.normalScale = new zn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function vu(t) { Tc.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) } cu.prototype = Object.create(_r.prototype), cu.prototype.constructor = cu, cu.prototype.isShadowMaterial = !0, cu.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.color.copy(t.color), this }, lu.prototype = Object.create(wo.prototype), lu.prototype.constructor = lu, lu.prototype.isRawShaderMaterial = !0, uu.prototype = Object.create(_r.prototype), uu.prototype.constructor = uu, uu.prototype.isMeshStandardMaterial = !0, uu.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this }, hu.prototype = Object.create(uu.prototype), hu.prototype.constructor = hu, hu.prototype.isMeshPhysicalMaterial = !0, hu.prototype.copy = function (t) { return uu.prototype.copy.call(this, t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new fr).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this }, du.prototype = Object.create(_r.prototype), du.prototype.constructor = du, du.prototype.isMeshPhongMaterial = !0, du.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, fu.prototype = Object.create(_r.prototype), fu.prototype.constructor = fu, fu.prototype.isMeshToonMaterial = !0, fu.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, pu.prototype = Object.create(_r.prototype), pu.prototype.constructor = pu, pu.prototype.isMeshNormalMaterial = !0, pu.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, mu.prototype = Object.create(_r.prototype), mu.prototype.constructor = mu, mu.prototype.isMeshLambertMaterial = !0, mu.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, gu.prototype = Object.create(_r.prototype), gu.prototype.constructor = gu, gu.prototype.isMeshMatcapMaterial = !0, gu.prototype.copy = function (t) { return _r.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, vu.prototype = Object.create(Tc.prototype), vu.prototype.constructor = vu, vu.prototype.isLineDashedMaterial = !0, vu.prototype.copy = function (t) { return Tc.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }; var yu = Object.freeze({ __proto__: null, ShadowMaterial: cu, SpriteMaterial: Za, RawShaderMaterial: lu, ShaderMaterial: wo, PointsMaterial: Nc, MeshPhysicalMaterial: hu, MeshStandardMaterial: uu, MeshPhongMaterial: du, MeshToonMaterial: fu, MeshNormalMaterial: pu, MeshLambertMaterial: mu, MeshDepthMaterial: La, MeshDistanceMaterial: Ra, MeshBasicMaterial: xr, MeshMatcapMaterial: gu, LineDashedMaterial: vu, LineBasicMaterial: Tc, Material: _r }); const _u = { arraySlice: function (t, e, n) { return _u.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) }, convertArray: function (t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { const e = t.length, n = new Array(e); for (let t = 0; t !== e; ++t)n[t] = t; return n.sort((function (e, n) { return t[e] - t[n] })), n }, sortedArray: function (t, e, n) { const i = t.length, r = new t.constructor(i); for (let o = 0, s = 0; s !== i; ++o) { const i = n[o] * e; for (let n = 0; n !== e; ++n)r[s++] = t[i + n] } return r }, flattenJSON: function (t, e, n, i) { let r = 1, o = t[0]; for (; void 0 !== o && void 0 === o[i];)o = t[r++]; if (void 0 === o) return; let s = o[i]; if (void 0 !== s) if (Array.isArray(s)) do { void 0 !== (s = o[i]) && (e.push(o.time), n.push.apply(n, s)), o = t[r++] } while (void 0 !== o); else if (void 0 !== s.toArray) do { void 0 !== (s = o[i]) && (e.push(o.time), s.toArray(n, n.length)), o = t[r++] } while (void 0 !== o); else do { void 0 !== (s = o[i]) && (e.push(o.time), n.push(s)), o = t[r++] } while (void 0 !== o) }, subclip: function (t, e, n, i, r) { r = r || 30; const o = t.clone(); o.name = e; const s = []; for (let t = 0; t < o.tracks.length; ++t) { const e = o.tracks[t], a = e.getValueSize(), c = [], l = []; for (let t = 0; t < e.times.length; ++t) { const o = e.times[t] * r; if (!(o < n || o >= i)) { c.push(e.times[t]); for (let n = 0; n < a; ++n)l.push(e.values[t * a + n]) } } 0 !== c.length && (e.times = _u.convertArray(c, e.times.constructor), e.values = _u.convertArray(l, e.values.constructor), s.push(e)) } o.tracks = s; let a = 1 / 0; for (let t = 0; t < o.tracks.length; ++t)a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]); for (let t = 0; t < o.tracks.length; ++t)o.tracks[t].shift(-1 * a); return o.resetDuration(), o }, makeClipAdditive: function (t, e, n, i) { void 0 === e && (e = 0), void 0 === n && (n = t), (void 0 === i || i <= 0) && (i = 30); const r = t.tracks.length, o = e / i; for (let e = 0; e < r; ++e) { const i = n.tracks[e], r = i.ValueTypeName; if ("bool" === r || "string" === r) continue; const s = t.tracks.find((function (t) { return t.name === i.name && t.ValueTypeName === r })); if (void 0 === s) continue; const a = i.getValueSize(), c = i.times.length - 1; let l; if (o <= i.times[0]) l = _u.arraySlice(i.values, 0, i.valueSize); else if (o >= i.times[c]) { const t = c * a; l = _u.arraySlice(i.values, t) } else { const t = i.createInterpolant(); t.evaluate(o), l = t.resultBuffer } if ("quaternion" === r) { new Xn(l[0], l[1], l[2], l[3]).normalize().conjugate().toArray(l) } const u = s.times.length; for (let t = 0; t < u; ++t) { const e = t * a; if ("quaternion" === r) Xn.multiplyQuaternionsFlat(s.values, e, l, 0, s.values, e); else for (let t = 0; t < a; ++t)s.values[e + t] -= l[t] } } return t.blendMode = qe, t } }; function xu(t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n } function bu(t, e, n, i) { xu.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function wu(t, e, n, i) { xu.call(this, t, e, n, i) } function Mu(t, e, n, i) { xu.call(this, t, e, n, i) } function Tu(t, e, n, i) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = _u.convertArray(e, this.TimeBufferType), this.values = _u.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } function Su(t, e, n) { Tu.call(this, t, e, n) } function Eu(t, e, n, i) { Tu.call(this, t, e, n, i) } function Au(t, e, n, i) { Tu.call(this, t, e, n, i) } function Pu(t, e, n, i) { xu.call(this, t, e, n, i) } function Lu(t, e, n, i) { Tu.call(this, t, e, n, i) } function Ru(t, e, n, i) { Tu.call(this, t, e, n, i) } function Ou(t, e, n, i) { Tu.call(this, t, e, n, i) } function Cu(t, e, n, i) { this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== i ? i : We, this.uuid = Bn.generateUUID(), this.duration < 0 && this.resetDuration() } function Iu(t) { if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Au; case "vector": case "vector2": case "vector3": case "vector4": return Ou; case "color": return Eu; case "quaternion": return Lu; case "bool": case "boolean": return Su; case "string": return Ru }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) }(t.type); if (void 0 === t.times) { const e = [], n = []; _u.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } Object.assign(xu.prototype, { evaluate: function (t) { let e = this.parameterPositions, n = this._cachedIndex, i = e[n], r = e[n - 1]; t: { e: { let o; n: { i: if (!(t < i)) { for (let o = n + 2; ;) { if (void 0 === i) { if (t < r) break i; return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r) } if (n === o) break; if (r = i, t < (i = e[++n])) break e } o = e.length; break n } if (t >= r) break t; { const s = e[1]; t < s && (n = 2, r = s); for (let o = n - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (n === o) break; if (i = r, t >= (r = e[--n - 1])) break e } o = n, n = 0 } } for (; n < o;) { const i = n + o >>> 1; t < e[i] ? o = i : n = i + 1 } if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t) } this._cachedIndex = n, this.intervalChanged_(n, r, i) } return this.interpolate_(n, r, t, i) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { const e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i; for (let t = 0; t !== i; ++t)e[t] = n[r + t]; return e }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(xu.prototype, { beforeStart_: xu.prototype.copySampleValue_, afterEnd_: xu.prototype.copySampleValue_ }), bu.prototype = Object.assign(Object.create(xu.prototype), { constructor: bu, DefaultSettings_: { endingStart: Ge, endingEnd: Ge }, intervalChanged_: function (t, e, n) { let i = this.parameterPositions, r = t - 2, o = t + 1, s = i[r], a = i[o]; if (void 0 === s) switch (this.getSettings_().endingStart) { case je: r = t, s = 2 * e - n; break; case Ve: s = e + i[r = i.length - 2] - i[r + 1]; break; default: r = t, s = n }if (void 0 === a) switch (this.getSettings_().endingEnd) { case je: o = t, a = 2 * n - e; break; case Ve: o = 1, a = n + i[1] - i[0]; break; default: o = t - 1, a = e }const c = .5 * (n - e), l = this.valueSize; this._weightPrev = c / (e - s), this._weightNext = c / (a - n), this._offsetPrev = r * l, this._offsetNext = o * l }, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, f = (n - e) / (i - e), p = f * f, m = p * f, g = -h * m + 2 * h * p - h * f, v = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1, y = (-1 - d) * m + (1.5 + d) * p + .5 * f, _ = d * m - d * p; for (let t = 0; t !== s; ++t)r[t] = g * o[l + t] + v * o[c + t] + y * o[a + t] + _ * o[u + t]; return r } }), wu.prototype = Object.assign(Object.create(xu.prototype), { constructor: wu, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s, l = (n - e) / (i - e), u = 1 - l; for (let t = 0; t !== s; ++t)r[t] = o[c + t] * u + o[a + t] * l; return r } }), Mu.prototype = Object.assign(Object.create(xu.prototype), { constructor: Mu, interpolate_: function (t) { return this.copySampleValue_(t - 1) } }), Object.assign(Tu, { toJSON: function (t) { const e = t.constructor; let n; if (void 0 !== e.toJSON) n = e.toJSON(t); else { n = { name: t.name, times: _u.convertArray(t.times, Array), values: _u.convertArray(t.values, Array) }; const e = t.getInterpolation(); e !== t.DefaultInterpolation && (n.interpolation = e) } return n.type = t.ValueTypeName, n } }), Object.assign(Tu.prototype, { constructor: Tu, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: Ue, InterpolantFactoryMethodDiscrete: function (t) { return new Mu(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new wu(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new bu(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { let e; switch (t) { case Fe: e = this.InterpolantFactoryMethodDiscrete; break; case Ue: e = this.InterpolantFactoryMethodLinear; break; case He: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(e); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", e), this } return this.createInterpolant = e, this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return Fe; case this.InterpolantFactoryMethodLinear: return Ue; case this.InterpolantFactoryMethodSmooth: return He } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (0 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n)e[n] += t } return this }, scale: function (t) { if (1 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n)e[n] *= t } return this }, trim: function (t, e) { const n = this.times, i = n.length; let r = 0, o = i - 1; for (; r !== i && n[r] < t;)++r; for (; -1 !== o && n[o] > e;)--o; if (++o, 0 !== r || o !== i) { r >= o && (r = (o = Math.max(o, 1)) - 1); const t = this.getValueSize(); this.times = _u.arraySlice(n, r, o), this.values = _u.arraySlice(this.values, r * t, o * t) } return this }, validate: function () { let t = !0; const e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); const n = this.times, i = this.values, r = n.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); let o = null; for (let e = 0; e !== r; e++) { const i = n[e]; if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1; break } if (null !== o && o > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, o), t = !1; break } o = i } if (void 0 !== i && _u.isTypedArray(i)) for (let e = 0, n = i.length; e !== n; ++e) { const n = i[e]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1; break } } return t }, optimize: function () { const t = _u.arraySlice(this.times), e = _u.arraySlice(this.values), n = this.getValueSize(), i = this.getInterpolation() === He, r = t.length - 1; let o = 1; for (let s = 1; s < r; ++s) { let r = !1; const a = t[s]; if (a !== t[s + 1] && (1 !== s || a !== a[0])) if (i) r = !0; else { const t = s * n, i = t - n, o = t + n; for (let s = 0; s !== n; ++s) { const n = e[t + s]; if (n !== e[i + s] || n !== e[o + s]) { r = !0; break } } } if (r) { if (s !== o) { t[o] = t[s]; const i = s * n, r = o * n; for (let t = 0; t !== n; ++t)e[r + t] = e[i + t] } ++o } } if (r > 0) { t[o] = t[r]; for (let t = r * n, i = o * n, s = 0; s !== n; ++s)e[i + s] = e[t + s]; ++o } return o !== t.length ? (this.times = _u.arraySlice(t, 0, o), this.values = _u.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this }, clone: function () { const t = _u.arraySlice(this.times, 0), e = _u.arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, t, e); return n.createInterpolant = this.createInterpolant, n } }), Su.prototype = Object.assign(Object.create(Tu.prototype), { constructor: Su, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: Fe, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Eu.prototype = Object.assign(Object.create(Tu.prototype), { constructor: Eu, ValueTypeName: "color" }), Au.prototype = Object.assign(Object.create(Tu.prototype), { constructor: Au, ValueTypeName: "number" }), Pu.prototype = Object.assign(Object.create(xu.prototype), { constructor: Pu, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = (n - e) / (i - e); let c = t * s; for (let t = c + s; c !== t; c += 4)Xn.slerpFlat(r, 0, o, c - s, o, c, a); return r } }), Lu.prototype = Object.assign(Object.create(Tu.prototype), { constructor: Lu, ValueTypeName: "quaternion", DefaultInterpolation: Ue, InterpolantFactoryMethodLinear: function (t) { return new Pu(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), Ru.prototype = Object.assign(Object.create(Tu.prototype), { constructor: Ru, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: Fe, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Ou.prototype = Object.assign(Object.create(Tu.prototype), { constructor: Ou, ValueTypeName: "vector" }), Object.assign(Cu, { parse: function (t) { const e = [], n = t.tracks, i = 1 / (t.fps || 1); for (let t = 0, r = n.length; t !== r; ++t)e.push(Iu(n[t]).scale(i)); return new Cu(t.name, t.duration, e, t.blendMode) }, toJSON: function (t) { const e = [], n = t.tracks, i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }; for (let t = 0, i = n.length; t !== i; ++t)e.push(Tu.toJSON(n[t])); return i }, CreateFromMorphTargetSequence: function (t, e, n, i) { const r = e.length, o = []; for (let t = 0; t < r; t++) { let s = [], a = []; s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0); const c = _u.getKeyframeOrder(s); s = _u.sortedArray(s, 1, c), a = _u.sortedArray(a, 1, c), i || 0 !== s[0] || (s.push(r), a.push(a[0])), o.push(new Au(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / n)) } return new Cu(t, -1, o) }, findByName: function (t, e) { let n = t; if (!Array.isArray(t)) { const e = t; n = e.geometry && e.geometry.animations || e.animations } for (let t = 0; t < n.length; t++)if (n[t].name === e) return n[t]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, n) { const i = {}, r = /^([\w-]*?)([\d]+)$/; for (let e = 0, n = t.length; e < n; e++) { const n = t[e], o = n.name.match(r); if (o && o.length > 1) { const t = o[1]; let e = i[t]; e || (i[t] = e = []), e.push(n) } } const o = []; for (const t in i) o.push(Cu.CreateFromMorphTargetSequence(t, i[t], e, n)); return o }, parseAnimation: function (t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (t, e, n, i, r) { if (0 !== n.length) { const o = [], s = []; _u.flattenJSON(n, o, s, i), 0 !== o.length && r.push(new t(e, o, s)) } }, i = [], r = t.name || "default", o = t.fps || 30, s = t.blendMode; let a = t.length || -1; const c = t.hierarchy || []; for (let t = 0; t < c.length; t++) { const r = c[t].keys; if (r && 0 !== r.length) if (r[0].morphTargets) { const t = {}; let e; for (e = 0; e < r.length; e++)if (r[e].morphTargets) for (let n = 0; n < r[e].morphTargets.length; n++)t[r[e].morphTargets[n]] = -1; for (const n in t) { const t = [], o = []; for (let i = 0; i !== r[e].morphTargets.length; ++i) { const i = r[e]; t.push(i.time), o.push(i.morphTarget === n ? 1 : 0) } i.push(new Au(".morphTargetInfluence[" + n + "]", t, o)) } a = t.length * (o || 1) } else { const o = ".bones[" + e[t].name + "]"; n(Ou, o + ".position", r, "pos", i), n(Lu, o + ".quaternion", r, "rot", i), n(Ou, o + ".scale", r, "scl", i) } } return 0 === i.length ? null : new Cu(r, a, i, s) } }), Object.assign(Cu.prototype, { resetDuration: function () { let t = 0; for (let e = 0, n = this.tracks.length; e !== n; ++e) { const n = this.tracks[e]; t = Math.max(t, n.times[n.times.length - 1]) } return this.duration = t, this }, trim: function () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this }, validate: function () { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t }, optimize: function () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this }, clone: function () { const t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new Cu(this.name, this.duration, t, this.blendMode) } }); const Du = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; function Nu(t, e, n) { const i = this; let r = !1, o = 0, s = 0, a = void 0; const c = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) { s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), r = !0 }, this.itemEnd = function (t) { o++, void 0 !== i.onProgress && i.onProgress(t, o, s), o === s && (r = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function (t) { void 0 !== i.onError && i.onError(t) }, this.resolveURL = function (t) { return a ? a(t) : t }, this.setURLModifier = function (t) { return a = t, this }, this.addHandler = function (t, e) { return c.push(t, e), this }, this.removeHandler = function (t) { const e = c.indexOf(t); return -1 !== e && c.splice(e, 2), this }, this.getHandler = function (t) { for (let e = 0, n = c.length; e < n; e += 2) { const n = c[e], i = c[e + 1]; if (n.global && (n.lastIndex = 0), n.test(t)) return i } return null } } const ku = new Nu; function Bu(t) { this.manager = void 0 !== t ? t : ku, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {} } Object.assign(Bu.prototype, { load: function () { }, loadAsync: function (t, e) { const n = this; return new Promise((function (i, r) { n.load(t, i, e, r) })) }, parse: function () { }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this }, setResourcePath: function (t) { return this.resourcePath = t, this }, setRequestHeader: function (t) { return this.requestHeader = t, this } }); const zu = {}; function Fu(t) { Bu.call(this, t) } function Uu(t) { Bu.call(this, t) } function Hu(t) { Bu.call(this, t) } function Gu(t) { Bu.call(this, t) } function ju(t) { Bu.call(this, t) } function Vu(t) { Bu.call(this, t) } function Wu(t) { Bu.call(this, t) } function qu() { this.type = "Curve", this.arcLengthDivisions = 200 } function Xu(t, e, n, i, r, o, s, a) { qu.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = a || 0 } function Yu(t, e, n, i, r, o) { Xu.call(this, t, e, n, n, i, r, o), this.type = "ArcCurve" } function Zu() { let t = 0, e = 0, n = 0, i = 0; function r(r, o, s, a) { t = r, e = s, n = -3 * r + 3 * o - 2 * s - a, i = 2 * r - 2 * o + s + a } return { initCatmullRom: function (t, e, n, i, o) { r(e, n, o * (n - t), o * (i - e)) }, initNonuniformCatmullRom: function (t, e, n, i, o, s, a) { let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s, l = (n - e) / s - (i - e) / (s + a) + (i - n) / a; r(e, n, c *= s, l *= s) }, calc: function (r) { const o = r * r; return t + e * r + n * o + i * (o * r) } } } Fu.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Fu, load: function (t, e, n, i) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = Du.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () { e && e(o), r.manager.itemEnd(t) }), 0), o; if (void 0 !== zu[t]) return void zu[t].push({ onLoad: e, onProgress: n, onError: i }); const s = t.match(/^data:(.*?)(;base64)?,(.*)$/); let a; if (s) { const n = s[1], o = !!s[2]; let a = s[3]; a = decodeURIComponent(a), o && (a = atob(a)); try { let i; const o = (this.responseType || "").toLowerCase(); switch (o) { case "arraybuffer": case "blob": const t = new Uint8Array(a.length); for (let e = 0; e < a.length; e++)t[e] = a.charCodeAt(e); i = "blob" === o ? new Blob([t.buffer], { type: n }) : t.buffer; break; case "document": const e = new DOMParser; i = e.parseFromString(a, n); break; case "json": i = JSON.parse(a); break; default: i = a }setTimeout((function () { e && e(i), r.manager.itemEnd(t) }), 0) } catch (e) { setTimeout((function () { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }), 0) } } else { zu[t] = [], zu[t].push({ onLoad: e, onProgress: n, onError: i }), (a = new XMLHttpRequest).open("GET", t, !0), a.addEventListener("load", (function (e) { const n = this.response, i = zu[t]; if (delete zu[t], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Du.add(t, n); for (let t = 0, e = i.length; t < e; t++) { const e = i[t]; e.onLoad && e.onLoad(n) } r.manager.itemEnd(t) } else { for (let t = 0, n = i.length; t < n; t++) { const n = i[t]; n.onError && n.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) } }), !1), a.addEventListener("progress", (function (e) { const n = zu[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onProgress && i.onProgress(e) } }), !1), a.addEventListener("error", (function (e) { const n = zu[t]; delete zu[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onError && i.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) }), !1), a.addEventListener("abort", (function (e) { const n = zu[t]; delete zu[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onError && i.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]); a.send(null) } return r.manager.itemStart(t), a }, setResponseType: function (t) { return this.responseType = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setMimeType: function (t) { return this.mimeType = t, this } }), Uu.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Uu, load: function (t, e, n, i) { const r = this, o = new Fu(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.load(t, (function (n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i) }, parse: function (t) { const e = []; for (let n = 0; n < t.length; n++) { const i = Cu.parse(t[n]); e.push(i) } return e } }), Hu.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Hu, load: function (t, e, n, i) { const r = this, o = [], s = new jc; s.image = o; const a = new Fu(this.manager); a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader); let c = 0; function l(l) { a.load(t[l], (function (t) { const n = r.parse(t, !0); o[l] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, 6 === (c += 1) && (1 === n.mipmapCount && (s.minFilter = _t), s.format = n.format, s.needsUpdate = !0, e && e(s)) }), n, i) } if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e)l(e); else a.load(t, (function (t) { const n = r.parse(t, !0); if (n.isCubemap) { const t = n.mipmaps.length / n.mipmapCount; for (let e = 0; e < t; e++) { o[e] = { mipmaps: [] }; for (let t = 0; t < n.mipmapCount; t++)o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), o[e].format = n.format, o[e].width = n.width, o[e].height = n.height } } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps; 1 === n.mipmapCount && (s.minFilter = _t), s.format = n.format, s.needsUpdate = !0, e && e(s) }), n, i); return s } }), Gu.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Gu, load: function (t, e, n, i) { const r = this, o = new Lo, s = new Fu(this.manager); return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.load(t, (function (t) { const n = r.parse(t); n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : dt, o.wrapT = void 0 !== n.wrapT ? n.wrapT : dt, o.magFilter = void 0 !== n.magFilter ? n.magFilter : _t, o.minFilter = void 0 !== n.minFilter ? n.minFilter : _t, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = wt), 1 === n.mipmapCount && (o.minFilter = _t), o.needsUpdate = !0, e && e(o, n)) }), n, i), o } }), ju.prototype = Object.assign(Object.create(Bu.prototype), { constructor: ju, load: function (t, e, n, i) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = Du.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () { e && e(o), r.manager.itemEnd(t) }), 0), o; const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function a() { s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), Du.add(t, this), e && e(this), r.manager.itemEnd(t) } function c(e) { s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) } return s.addEventListener("load", a, !1), s.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s } }), Vu.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Vu, load: function (t, e, n, i) { const r = new Ko, o = new ju(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); let s = 0; function a(n) { o.load(t[n], (function (t) { r.images[n] = t, 6 === ++s && (r.needsUpdate = !0, e && e(r)) }), void 0, i) } for (let e = 0; e < t.length; ++e)a(e); return r } }), Wu.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Wu, load: function (t, e, n, i) { const r = new jn, o = new ju(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (n) { r.image = n; const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/); r.format = i ? Bt : zt, r.needsUpdate = !0, void 0 !== e && e(r) }), n, i), r } }), Object.assign(qu.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (t, e) { const n = this.getUtoTmapping(t); return this.getPoint(n, e) }, getPoints: function (t) { void 0 === t && (t = 5); const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return e }, getSpacedPoints: function (t) { void 0 === t && (t = 5); const e = []; for (let n = 0; n <= t; n++)e.push(this.getPointAt(n / t)); return e }, getLength: function () { const t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const e = []; let n, i = this.getPoint(0), r = 0; e.push(0); for (let o = 1; o <= t; o++)r += (n = this.getPoint(o / t)).distanceTo(i), e.push(r), i = n; return this.cacheArcLengths = e, e }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (t, e) { const n = this.getLengths(); let i, r = 0, o = n.length; i = e || t * n[o - 1]; let s, a = 0, c = o - 1; for (; a <= c;)if ((s = n[r = Math.floor(a + (c - a) / 2)] - i) < 0) a = r + 1; else { if (!(s > 0)) { c = r; break } c = r - 1 } if (n[r = c] === i) return r / (o - 1); const l = n[r]; return (r + (i - l) / (n[r + 1] - l)) / (o - 1) }, getTangent: function (t, e) { let n = t - 1e-4, i = t + 1e-4; n < 0 && (n = 0), i > 1 && (i = 1); const r = this.getPoint(n), o = this.getPoint(i), s = e || (r.isVector2 ? new zn : new Jn); return s.copy(o).sub(r).normalize(), s }, getTangentAt: function (t, e) { const n = this.getUtoTmapping(t); return this.getTangent(n, e) }, computeFrenetFrames: function (t, e) { const n = new Jn, i = [], r = [], o = [], s = new Jn, a = new ri; for (let e = 0; e <= t; e++) { const n = e / t; i[e] = this.getTangentAt(n, new Jn), i[e].normalize() } r[0] = new Jn, o[0] = new Jn; let c = Number.MAX_VALUE; const l = Math.abs(i[0].x), u = Math.abs(i[0].y), h = Math.abs(i[0].z); l <= c && (c = l, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), o[0].crossVectors(i[0], r[0]); for (let e = 1; e <= t; e++) { if (r[e] = r[e - 1].clone(), o[e] = o[e - 1].clone(), s.crossVectors(i[e - 1], i[e]), s.length() > Number.EPSILON) { s.normalize(); const t = Math.acos(Bn.clamp(i[e - 1].dot(i[e]), -1, 1)); r[e].applyMatrix4(a.makeRotationAxis(s, t)) } o[e].crossVectors(i[e], r[e]) } if (!0 === e) { let e = Math.acos(Bn.clamp(r[0].dot(r[t]), -1, 1)); e /= t, i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e); for (let n = 1; n <= t; n++)r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), o[n].crossVectors(i[n], r[n]) } return { tangents: i, normals: r, binormals: o } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }, toJSON: function () { const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }, fromJSON: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } }), Xu.prototype = Object.create(qu.prototype), Xu.prototype.constructor = Xu, Xu.prototype.isEllipseCurve = !0, Xu.prototype.getPoint = function (t, e) { const n = e || new zn, i = 2 * Math.PI; let r = this.aEndAngle - this.aStartAngle; const o = Math.abs(r) < Number.EPSILON; for (; r < 0;)r += i; for (; r > i;)r -= i; r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i); const s = this.aStartAngle + t * r; let a = this.aX + this.xRadius * Math.cos(s), c = this.aY + this.yRadius * Math.sin(s); if (0 !== this.aRotation) { const t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), n = a - this.aX, i = c - this.aY; a = n * t - i * e + this.aX, c = n * e + i * t + this.aY } return n.set(a, c) }, Xu.prototype.copy = function (t) { return qu.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Xu.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }, Xu.prototype.fromJSON = function (t) { return qu.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Yu.prototype = Object.create(Xu.prototype), Yu.prototype.constructor = Yu, Yu.prototype.isArcCurve = !0; const Ju = new Jn, Qu = new Zu, $u = new Zu, Ku = new Zu; function th(t, e, n, i) { qu.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = void 0 !== i ? i : .5 } function eh(t, e, n, i, r) { const o = .5 * (i - e), s = .5 * (r - n), a = t * t; return (2 * n - 2 * i + o + s) * (t * a) + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n } function nh(t, e, n, i) { return function (t, e) { const n = 1 - t; return n * n * e }(t, e) + function (t, e) { return 2 * (1 - t) * t * e }(t, n) + function (t, e) { return t * t * e }(t, i) } function ih(t, e, n, i, r) { return function (t, e) { const n = 1 - t; return n * n * n * e }(t, e) + function (t, e) { const n = 1 - t; return 3 * n * n * t * e }(t, n) + function (t, e) { return 3 * (1 - t) * t * t * e }(t, i) + function (t, e) { return t * t * t * e }(t, r) } function rh(t, e, n, i) { qu.call(this), this.type = "CubicBezierCurve", this.v0 = t || new zn, this.v1 = e || new zn, this.v2 = n || new zn, this.v3 = i || new zn } function oh(t, e, n, i) { qu.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Jn, this.v1 = e || new Jn, this.v2 = n || new Jn, this.v3 = i || new Jn } function sh(t, e) { qu.call(this), this.type = "LineCurve", this.v1 = t || new zn, this.v2 = e || new zn } function ah(t, e) { qu.call(this), this.type = "LineCurve3", this.v1 = t || new Jn, this.v2 = e || new Jn } function ch(t, e, n) { qu.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new zn, this.v1 = e || new zn, this.v2 = n || new zn } function lh(t, e, n) { qu.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Jn, this.v1 = e || new Jn, this.v2 = n || new Jn } function uh(t) { qu.call(this), this.type = "SplineCurve", this.points = t || [] } th.prototype = Object.create(qu.prototype), th.prototype.constructor = th, th.prototype.isCatmullRomCurve3 = !0, th.prototype.getPoint = function (t, e) { const n = e || new Jn, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * t; let s, a, c, l, u = Math.floor(o), h = o - u; if (this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / r) + 1) * r : 0 === h && u === r - 1 && (u = r - 2, h = 1), this.closed || u > 0 ? s = i[(u - 1) % r] : (Ju.subVectors(i[0], i[1]).add(i[0]), s = Ju), a = i[u % r], c = i[(u + 1) % r], this.closed || u + 2 < r ? l = i[(u + 2) % r] : (Ju.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), l = Ju), "centripetal" === this.curveType || "chordal" === this.curveType) { const t = "chordal" === this.curveType ? .5 : .25; let e = Math.pow(s.distanceToSquared(a), t), n = Math.pow(a.distanceToSquared(c), t), i = Math.pow(c.distanceToSquared(l), t); n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Qu.initNonuniformCatmullRom(s.x, a.x, c.x, l.x, e, n, i), $u.initNonuniformCatmullRom(s.y, a.y, c.y, l.y, e, n, i), Ku.initNonuniformCatmullRom(s.z, a.z, c.z, l.z, e, n, i) } else "catmullrom" === this.curveType && (Qu.initCatmullRom(s.x, a.x, c.x, l.x, this.tension), $u.initCatmullRom(s.y, a.y, c.y, l.y, this.tension), Ku.initCatmullRom(s.z, a.z, c.z, l.z, this.tension)); return n.set(Qu.calc(h), $u.calc(h), Ku.calc(h)), n }, th.prototype.copy = function (t) { qu.prototype.copy.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push(n.clone()) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, th.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { const n = this.points[e]; t.points.push(n.toArray()) } return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t }, th.prototype.fromJSON = function (t) { qu.prototype.fromJSON.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new Jn).fromArray(n)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, rh.prototype = Object.create(qu.prototype), rh.prototype.constructor = rh, rh.prototype.isCubicBezierCurve = !0, rh.prototype.getPoint = function (t, e) { const n = e || new zn, i = this.v0, r = this.v1, o = this.v2, s = this.v3; return n.set(ih(t, i.x, r.x, o.x, s.x), ih(t, i.y, r.y, o.y, s.y)), n }, rh.prototype.copy = function (t) { return qu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, rh.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, rh.prototype.fromJSON = function (t) { return qu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, oh.prototype = Object.create(qu.prototype), oh.prototype.constructor = oh, oh.prototype.isCubicBezierCurve3 = !0, oh.prototype.getPoint = function (t, e) { const n = e || new Jn, i = this.v0, r = this.v1, o = this.v2, s = this.v3; return n.set(ih(t, i.x, r.x, o.x, s.x), ih(t, i.y, r.y, o.y, s.y), ih(t, i.z, r.z, o.z, s.z)), n }, oh.prototype.copy = function (t) { return qu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, oh.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, oh.prototype.fromJSON = function (t) { return qu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, sh.prototype = Object.create(qu.prototype), sh.prototype.constructor = sh, sh.prototype.isLineCurve = !0, sh.prototype.getPoint = function (t, e) { const n = e || new zn; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }, sh.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, sh.prototype.getTangent = function (t, e) { const n = e || new zn; return n.copy(this.v2).sub(this.v1).normalize(), n }, sh.prototype.copy = function (t) { return qu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, sh.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, sh.prototype.fromJSON = function (t) { return qu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ah.prototype = Object.create(qu.prototype), ah.prototype.constructor = ah, ah.prototype.isLineCurve3 = !0, ah.prototype.getPoint = function (t, e) { const n = e || new Jn; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }, ah.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, ah.prototype.copy = function (t) { return qu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, ah.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, ah.prototype.fromJSON = function (t) { return qu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, ch.prototype = Object.create(qu.prototype), ch.prototype.constructor = ch, ch.prototype.isQuadraticBezierCurve = !0, ch.prototype.getPoint = function (t, e) { const n = e || new zn, i = this.v0, r = this.v1, o = this.v2; return n.set(nh(t, i.x, r.x, o.x), nh(t, i.y, r.y, o.y)), n }, ch.prototype.copy = function (t) { return qu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, ch.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, ch.prototype.fromJSON = function (t) { return qu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, lh.prototype = Object.create(qu.prototype), lh.prototype.constructor = lh, lh.prototype.isQuadraticBezierCurve3 = !0, lh.prototype.getPoint = function (t, e) { const n = e || new Jn, i = this.v0, r = this.v1, o = this.v2; return n.set(nh(t, i.x, r.x, o.x), nh(t, i.y, r.y, o.y), nh(t, i.z, r.z, o.z)), n }, lh.prototype.copy = function (t) { return qu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, lh.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, lh.prototype.fromJSON = function (t) { return qu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, uh.prototype = Object.create(qu.prototype), uh.prototype.constructor = uh, uh.prototype.isSplineCurve = !0, uh.prototype.getPoint = function (t, e) { const n = e || new zn, i = this.points, r = (i.length - 1) * t, o = Math.floor(r), s = r - o, a = i[0 === o ? o : o - 1], c = i[o], l = i[o > i.length - 2 ? i.length - 1 : o + 1], u = i[o > i.length - 3 ? i.length - 1 : o + 2]; return n.set(eh(s, a.x, c.x, l.x, u.x), eh(s, a.y, c.y, l.y, u.y)), n }, uh.prototype.copy = function (t) { qu.prototype.copy.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push(n.clone()) } return this }, uh.prototype.toJSON = function () { const t = qu.prototype.toJSON.call(this); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { const n = this.points[e]; t.points.push(n.toArray()) } return t }, uh.prototype.fromJSON = function (t) { qu.prototype.fromJSON.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new zn).fromArray(n)) } return this }; var hh = Object.freeze({ __proto__: null, ArcCurve: Yu, CatmullRomCurve3: th, CubicBezierCurve: rh, CubicBezierCurve3: oh, EllipseCurve: Xu, LineCurve: sh, LineCurve3: ah, QuadraticBezierCurve: ch, QuadraticBezierCurve3: lh, SplineCurve: uh }); function dh() { qu.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } function fh(t) { dh.call(this), this.type = "Path", this.currentPoint = new zn, t && this.setFromPoints(t) } function ph(t) { fh.call(this, t), this.uuid = Bn.generateUUID(), this.type = "Shape", this.holes = [] } function mh(t, e) { wi.call(this), this.type = "Light", this.color = new fr(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 } function gh(t, e, n) { mh.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(wi.DefaultUp), this.updateMatrix(), this.groundColor = new fr(e) } function vh(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new zn(512, 512), this.map = null, this.mapPass = null, this.matrix = new ri, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Co, this._frameExtents = new zn(1, 1), this._viewportCount = 1, this._viewports = [new Vn(0, 0, 1, 1)] } function yh() { vh.call(this, new To(50, 1, .5, 500)) } function _h(t, e, n, i, r, o) { mh.call(this, t, e), this.type = "SpotLight", this.position.copy(wi.DefaultUp), this.updateMatrix(), this.target = new wi, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new yh } function xh() { vh.call(this, new To(90, 1, .5, 500)), this._frameExtents = new zn(4, 2), this._viewportCount = 6, this._viewports = [new Vn(2, 1, 1, 1), new Vn(0, 1, 1, 1), new Vn(3, 1, 1, 1), new Vn(1, 1, 1, 1), new Vn(3, 0, 1, 1), new Vn(1, 0, 1, 1)], this._cubeDirections = [new Jn(1, 0, 0), new Jn(-1, 0, 0), new Jn(0, 0, 1), new Jn(0, 0, -1), new Jn(0, 1, 0), new Jn(0, -1, 0)], this._cubeUps = [new Jn(0, 1, 0), new Jn(0, 1, 0), new Jn(0, 1, 0), new Jn(0, 1, 0), new Jn(0, 0, 1), new Jn(0, 0, -1)] } function bh(t, e, n, i) { mh.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new xh } function wh(t, e, n, i, r, o) { Mo.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix() } function Mh() { vh.call(this, new wh(-5, 5, 5, -5, .5, 500)) } function Th(t, e) { mh.call(this, t, e), this.type = "DirectionalLight", this.position.copy(wi.DefaultUp), this.updateMatrix(), this.target = new wi, this.shadow = new Mh } function Sh(t, e) { mh.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0 } function Eh(t, e, n, i) { mh.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10 } function Ah() { this.coefficients = []; for (let t = 0; t < 9; t++)this.coefficients.push(new Jn) } function Ph(t, e) { mh.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new Ah } function Lh(t) { Bu.call(this, t), this.textures = {} } dh.prototype = Object.assign(Object.create(qu.prototype), { constructor: dh, add: function (t) { this.curves.push(t) }, closePath: function () { const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new sh(e, t)) }, getPoint: function (t) { const e = t * this.getLength(), n = this.getCurveLengths(); let i = 0; for (; i < n.length;) { if (n[i] >= e) { const t = n[i] - e, r = this.curves[i], o = r.getLength(), s = 0 === o ? 0 : 1 - t / o; return r.getPointAt(s) } i++ } return null }, getLength: function () { const t = this.getCurveLengths(); return t[t.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const t = []; let e = 0; for (let n = 0, i = this.curves.length; n < i; n++)e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t, t }, getSpacedPoints: function (t) { void 0 === t && (t = 40); const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e }, getPoints: function (t) { t = t || 12; const e = []; let n; for (let i = 0, r = this.curves; i < r.length; i++) { const o = r[i], s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, a = o.getPoints(s); for (let t = 0; t < a.length; t++) { const i = a[t]; n && n.equals(i) || (e.push(i), n = i) } } return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e }, copy: function (t) { qu.prototype.copy.call(this, t), this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { const n = t.curves[e]; this.curves.push(n.clone()) } return this.autoClose = t.autoClose, this }, toJSON: function () { const t = qu.prototype.toJSON.call(this); t.autoClose = this.autoClose, t.curves = []; for (let e = 0, n = this.curves.length; e < n; e++) { const n = this.curves[e]; t.curves.push(n.toJSON()) } return t }, fromJSON: function (t) { qu.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { const n = t.curves[e]; this.curves.push((new hh[n.type]).fromJSON(n)) } return this } }), fh.prototype = Object.assign(Object.create(dh.prototype), { constructor: fh, setFromPoints: function (t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++)this.lineTo(t[e].x, t[e].y); return this }, moveTo: function (t, e) { return this.currentPoint.set(t, e), this }, lineTo: function (t, e) { const n = new sh(this.currentPoint.clone(), new zn(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this }, quadraticCurveTo: function (t, e, n, i) { const r = new ch(this.currentPoint.clone(), new zn(t, e), new zn(n, i)); return this.curves.push(r), this.currentPoint.set(n, i), this }, bezierCurveTo: function (t, e, n, i, r, o) { const s = new rh(this.currentPoint.clone(), new zn(t, e), new zn(n, i), new zn(r, o)); return this.curves.push(s), this.currentPoint.set(r, o), this }, splineThru: function (t) { const e = new uh([this.currentPoint.clone()].concat(t)); return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this }, arc: function (t, e, n, i, r, o) { const s = this.currentPoint.x, a = this.currentPoint.y; return this.absarc(t + s, e + a, n, i, r, o), this }, absarc: function (t, e, n, i, r, o) { return this.absellipse(t, e, n, n, i, r, o), this }, ellipse: function (t, e, n, i, r, o, s, a) { const c = this.currentPoint.x, l = this.currentPoint.y; return this.absellipse(t + c, e + l, n, i, r, o, s, a), this }, absellipse: function (t, e, n, i, r, o, s, a) { const c = new Xu(t, e, n, i, r, o, s, a); if (this.curves.length > 0) { const t = c.getPoint(0); t.equals(this.currentPoint) || this.lineTo(t.x, t.y) } this.curves.push(c); const l = c.getPoint(1); return this.currentPoint.copy(l), this }, copy: function (t) { return dh.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this }, toJSON: function () { const t = dh.prototype.toJSON.call(this); return t.currentPoint = this.currentPoint.toArray(), t }, fromJSON: function (t) { return dh.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this } }), ph.prototype = Object.assign(Object.create(fh.prototype), { constructor: ph, getPointsHoles: function (t) { const e = []; for (let n = 0, i = this.holes.length; n < i; n++)e[n] = this.holes[n].getPoints(t); return e }, extractPoints: function (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }, copy: function (t) { fh.prototype.copy.call(this, t), this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { const n = t.holes[e]; this.holes.push(n.clone()) } return this }, toJSON: function () { const t = fh.prototype.toJSON.call(this); t.uuid = this.uuid, t.holes = []; for (let e = 0, n = this.holes.length; e < n; e++) { const n = this.holes[e]; t.holes.push(n.toJSON()) } return t }, fromJSON: function (t) { fh.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { const n = t.holes[e]; this.holes.push((new fh).fromJSON(n)) } return this } }), mh.prototype = Object.assign(Object.create(wi.prototype), { constructor: mh, isLight: !0, copy: function (t) { return wi.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { const e = wi.prototype.toJSON.call(this, t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } }), gh.prototype = Object.assign(Object.create(mh.prototype), { constructor: gh, isHemisphereLight: !0, copy: function (t) { return mh.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign(vh.prototype, { _projScreenMatrix: new ri, _lightPositionWorld: new Jn, _lookTarget: new Jn, getViewportCount: function () { return this._viewportCount }, getFrustum: function () { return this._frustum }, updateMatrices: function (t) { const e = this.camera, n = this.matrix, i = this._projScreenMatrix, r = this._lookTarget, o = this._lightPositionWorld; o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse) }, getViewport: function (t) { return this._viewports[t] }, getFrameExtents: function () { return this._frameExtents }, copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), yh.prototype = Object.assign(Object.create(vh.prototype), { constructor: yh, isSpotLightShadow: !0, updateMatrices: function (t) { const e = this.camera, n = 2 * Bn.RAD2DEG * t.angle, i = this.mapSize.width / this.mapSize.height, r = t.distance || e.far; n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), vh.prototype.updateMatrices.call(this, t) } }), _h.prototype = Object.assign(Object.create(mh.prototype), { constructor: _h, isSpotLight: !0, copy: function (t) { return mh.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), xh.prototype = Object.assign(Object.create(vh.prototype), { constructor: xh, isPointLightShadow: !0, updateMatrices: function (t, e) { void 0 === e && (e = 0); const n = this.camera, i = this.matrix, r = this._lightPositionWorld, o = this._lookTarget, s = this._projScreenMatrix; r.setFromMatrixPosition(t.matrixWorld), n.position.copy(r), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s) } }), bh.prototype = Object.assign(Object.create(mh.prototype), { constructor: bh, isPointLight: !0, copy: function (t) { return mh.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), wh.prototype = Object.assign(Object.create(Mo.prototype), { constructor: wh, isOrthographicCamera: !0, copy: function (t, e) { return Mo.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, n, i, r, o) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let r = n - t, o = n + t, s = i + e, a = i - e; if (null !== this.view && this.view.enabled) { const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom; o = (r += t * this.view.offsetX) + t * this.view.width, a = (s -= e * this.view.offsetY) - e * this.view.height } this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { const e = wi.prototype.toJSON.call(this, t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } }), Mh.prototype = Object.assign(Object.create(vh.prototype), { constructor: Mh, isDirectionalLightShadow: !0, updateMatrices: function (t) { vh.prototype.updateMatrices.call(this, t) } }), Th.prototype = Object.assign(Object.create(mh.prototype), { constructor: Th, isDirectionalLight: !0, copy: function (t) { return mh.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), Sh.prototype = Object.assign(Object.create(mh.prototype), { constructor: Sh, isAmbientLight: !0 }), Eh.prototype = Object.assign(Object.create(mh.prototype), { constructor: Eh, isRectAreaLight: !0, copy: function (t) { return mh.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this }, toJSON: function (t) { const e = mh.prototype.toJSON.call(this, t); return e.object.width = this.width, e.object.height = this.height, e } }), Object.assign(Ah.prototype, { isSphericalHarmonics3: !0, set: function (t) { for (let e = 0; e < 9; e++)this.coefficients[e].copy(t[e]); return this }, zero: function () { for (let t = 0; t < 9; t++)this.coefficients[t].set(0, 0, 0); return this }, getAt: function (t, e) { const n = t.x, i = t.y, r = t.z, o = this.coefficients; return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * i), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * i * 1.092548), e.addScaledVector(o[5], i * r * 1.092548), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], n * r * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - i * i)), e }, getIrradianceAt: function (t, e) { const n = t.x, i = t.y, r = t.z, o = this.coefficients; return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * i), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * i), e.addScaledVector(o[5], .858086 * i * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], .858086 * n * r), e.addScaledVector(o[8], .429043 * (n * n - i * i)), e }, add: function (t) { for (let e = 0; e < 9; e++)this.coefficients[e].add(t.coefficients[e]); return this }, addScaledSH: function (t, e) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(t.coefficients[n], e); return this }, scale: function (t) { for (let e = 0; e < 9; e++)this.coefficients[e].multiplyScalar(t); return this }, lerp: function (t, e) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(t.coefficients[n], e); return this }, equals: function (t) { for (let e = 0; e < 9; e++)if (!this.coefficients[e].equals(t.coefficients[e])) return !1; return !0 }, copy: function (t) { return this.set(t.coefficients) }, clone: function () { return (new this.constructor).copy(this) }, fromArray: function (t, e) { void 0 === e && (e = 0); const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].fromArray(t, e + 3 * i); return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].toArray(t, e + 3 * i); return t } }), Object.assign(Ah, { getBasisAt: function (t, e) { const n = t.x, i = t.y, r = t.z; e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i) } }), Ph.prototype = Object.assign(Object.create(mh.prototype), { constructor: Ph, isLightProbe: !0, copy: function (t) { return mh.prototype.copy.call(this, t), this.sh.copy(t.sh), this }, fromJSON: function (t) { return this.intensity = t.intensity, this.sh.fromArray(t.sh), this }, toJSON: function (t) { const e = mh.prototype.toJSON.call(this, t); return e.object.sh = this.sh.toArray(), e } }), Lh.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Lh, load: function (t, e, n, i) { const r = this, o = new Fu(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.load(t, (function (n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i) }, parse: function (t) { const e = this.textures; function n(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] } const i = new yu[t.type]; if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new fr).setHex(t.sheen)), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms) for (const e in t.uniforms) { const r = t.uniforms[e]; switch (i.uniforms[e] = {}, r.type) { case "t": i.uniforms[e].value = n(r.value); break; case "c": i.uniforms[e].value = (new fr).setHex(r.value); break; case "v2": i.uniforms[e].value = (new zn).fromArray(r.value); break; case "v3": i.uniforms[e].value = (new Jn).fromArray(r.value); break; case "v4": i.uniforms[e].value = (new Vn).fromArray(r.value); break; case "m3": i.uniforms[e].value = (new Fn).fromArray(r.value); case "m4": i.uniforms[e].value = (new ri).fromArray(r.value); break; default: i.uniforms[e].value = r.value } } if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (const e in t.extensions) i.extensions[e] = t.extensions[e]; if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) { let e = t.normalScale; !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new zn).fromArray(e) } return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new zn).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), i }, setTextures: function (t) { return this.textures = t, this } }); const Rh = { decodeText: function (t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let n = 0, i = t.length; n < i; n++)e += String.fromCharCode(t[n]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }, extractUrlBase: function (t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) } }; function Oh() { Gr.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } function Ch(t, e, n, i) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Mr.call(this, t, e, n), this.meshPerAttribute = i || 1 } function Ih(t) { Bu.call(this, t) } Oh.prototype = Object.assign(Object.create(Gr.prototype), { constructor: Oh, isInstancedBufferGeometry: !0, copy: function (t) { return Gr.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { const t = Gr.prototype.toJSON.call(this); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t } }), Ch.prototype = Object.assign(Object.create(Mr.prototype), { constructor: Ch, isInstancedBufferAttribute: !0, copy: function (t) { return Mr.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, toJSON: function () { const t = Mr.prototype.toJSON.call(this); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } }), Ih.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Ih, load: function (t, e, n, i) { const r = this, o = new Fu(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.load(t, (function (n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i) }, parse: function (t) { const e = {}, n = {}; function i(t, i) { if (void 0 !== e[i]) return e[i]; const r = t.interleavedBuffers[i], o = function (t, e) { if (void 0 !== n[e]) return n[e]; const i = t.arrayBuffers[e], r = new Uint32Array(i).buffer; return n[e] = r, r }(t, r.buffer), s = new qa(new Dh[r.type](o), r.stride); return s.uuid = r.uuid, e[i] = s, s } const r = t.isInstancedBufferGeometry ? new Oh : new Gr, o = t.data.index; if (void 0 !== o) { const t = new Dh[o.type](o.array); r.setIndex(new Mr(t, 1)) } const s = t.data.attributes; for (const e in s) { const n = s[e]; let o; if (n.isInterleavedBufferAttribute) { o = new Ya(i(t.data, n.data), n.itemSize, n.offset, n.normalized) } else { const t = new Dh[n.type](n.array); o = new (n.isInstancedBufferAttribute ? Ch : Mr)(t, n.itemSize, n.normalized) } void 0 !== n.name && (o.name = n.name), r.setAttribute(e, o) } const a = t.data.morphAttributes; if (a) for (const e in a) { const n = a[e], o = []; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; let s; if (r.isInterleavedBufferAttribute) { s = new Ya(i(t.data, r.data), r.itemSize, r.offset, r.normalized) } else { s = new Mr(new Dh[r.type](r.array), r.itemSize, r.normalized) } void 0 !== r.name && (s.name = r.name), o.push(s) } r.morphAttributes[e] = o } t.data.morphTargetsRelative && (r.morphTargetsRelative = !0); const c = t.data.groups || t.data.drawcalls || t.data.offsets; if (void 0 !== c) for (let t = 0, e = c.length; t !== e; ++t) { const e = c[t]; r.addGroup(e.start, e.count, e.materialIndex) } const l = t.data.boundingSphere; if (void 0 !== l) { const t = new Jn; void 0 !== l.center && t.fromArray(l.center), r.boundingSphere = new Ui(t, l.radius) } return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r } }); const Dh = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function Nh(t) { Bu.call(this, t) } Nh.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Nh, load: function (t, e, n, i) { const r = this, o = "" === this.path ? Rh.extractUrlBase(t) : this.path; this.resourcePath = this.resourcePath || o; const s = new Fu(r.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.load(t, (function (n) { let o = null; try { o = JSON.parse(n) } catch (e) { return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message) } const s = o.metadata; void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t) }), n, i) }, parse: function (t, e) { const n = this.parseShape(t.shapes), i = this.parseGeometries(t.geometries, n), r = this.parseImages(t.images, (function () { void 0 !== e && e(a) })), o = this.parseTextures(t.textures, r), s = this.parseMaterials(t.materials, o), a = this.parseObject(t.object, i, s); return t.animations && (a.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a), a }, parseShape: function (t) { const e = {}; if (void 0 !== t) for (let n = 0, i = t.length; n < i; n++) { const i = (new ph).fromJSON(t[n]); e[i.uuid] = i } return e }, parseGeometries: function (t, e) { const n = {}; let i; if (void 0 !== t) { const r = new Ih; for (let o = 0, s = t.length; o < s; o++) { let s; const a = t[o]; switch (a.type) { case "PlaneGeometry": case "PlaneBufferGeometry": s = new au[a.type](a.width, a.height, a.widthSegments, a.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": s = new au[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": s = new au[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": s = new au[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": s = new au[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": s = new au[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": s = new au[a.type](a.radius, a.detail); break; case "RingGeometry": case "RingBufferGeometry": s = new au[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": s = new au[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": s = new au[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q); break; case "TubeGeometry": case "TubeBufferGeometry": s = new au[a.type]((new hh[a.path.type]).fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed); break; case "LatheGeometry": case "LatheBufferGeometry": s = new au[a.type](a.points, a.segments, a.phiStart, a.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": s = new au[a.type](a.vertices, a.indices, a.radius, a.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": i = []; for (let t = 0, n = a.shapes.length; t < n; t++) { const n = e[a.shapes[t]]; i.push(n) } s = new au[a.type](i, a.curveSegments); break; case "ExtrudeGeometry": case "ExtrudeBufferGeometry": i = []; for (let t = 0, n = a.shapes.length; t < n; t++) { const n = e[a.shapes[t]]; i.push(n) } const t = a.options.extrudePath; void 0 !== t && (a.options.extrudePath = (new hh[t.type]).fromJSON(t)), s = new au[a.type](i, a.options); break; case "BufferGeometry": case "InstancedBufferGeometry": s = r.parse(a); break; case "Geometry": console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'); break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"'); continue }s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s } } return n }, parseMaterials: function (t, e) { const n = {}, i = {}; if (void 0 !== t) { const r = new Lh; r.setTextures(e); for (let e = 0, o = t.length; e < o; e++) { const o = t[e]; if ("MultiMaterial" === o.type) { const t = []; for (let e = 0; e < o.materials.length; e++) { const i = o.materials[e]; void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid]) } i[o.uuid] = t } else void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)), i[o.uuid] = n[o.uuid] } } return i }, parseAnimations: function (t) { const e = []; for (let n = 0; n < t.length; n++) { const i = t[n], r = Cu.parse(i); void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r) } return e }, parseImages: function (t, e) { const n = this, i = {}; let r; function o(t) { return n.manager.itemStart(t), r.load(t, (function () { n.manager.itemEnd(t) }), void 0, (function () { n.manager.itemError(t), n.manager.itemEnd(t) })) } if (void 0 !== t && t.length > 0) { const s = new Nu(e); (r = new ju(s)).setCrossOrigin(this.crossOrigin); for (let e = 0, r = t.length; e < r; e++) { const r = t[e], s = r.url; if (Array.isArray(s)) { i[r.uuid] = []; for (let t = 0, e = s.length; t < e; t++) { const e = s[t], a = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e; i[r.uuid].push(o(a)) } } else { const t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r.url) ? r.url : n.resourcePath + r.url; i[r.uuid] = o(t) } } } return i }, parseTextures: function (t, e) { function n(t, e) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]) } const i = {}; if (void 0 !== t) for (let r = 0, o = t.length; r < o; r++) { const o = t[r]; let s; void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image), (s = Array.isArray(e[o.image]) ? new Ko(e[o.image]) : new jn(e[o.image])).needsUpdate = !0, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, kh)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], Bh), s.wrapT = n(o.wrap[1], Bh)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, zh)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, zh)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), i[o.uuid] = s } return i }, parseObject: function (t, e, n) { let i, r, o; function s(t) { return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t] } function a(t) { if (void 0 !== t) { if (Array.isArray(t)) { const e = []; for (let i = 0, r = t.length; i < r; i++) { const r = t[i]; void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(n[r]) } return e } return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t] } } switch (t.type) { case "Scene": i = new Mi, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new fr(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new Wa(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new Va(t.fog.color, t.fog.density))); break; case "PerspectiveCamera": i = new To(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view)); break; case "OrthographicCamera": i = new wh(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view)); break; case "AmbientLight": i = new Sh(t.color, t.intensity); break; case "DirectionalLight": i = new Th(t.color, t.intensity); break; case "PointLight": i = new bh(t.color, t.intensity, t.distance, t.decay); break; case "RectAreaLight": i = new Eh(t.color, t.intensity, t.width, t.height); break; case "SpotLight": i = new _h(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay); break; case "HemisphereLight": i = new gh(t.color, t.groundColor, t.intensity); break; case "LightProbe": i = (new Ph).fromJSON(t); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."); case "Mesh": i = new so(r = s(t.geometry), o = a(t.material)); break; case "InstancedMesh": r = s(t.geometry), o = a(t.material); const e = t.count, n = t.instanceMatrix; (i = new Mc(r, o, e)).instanceMatrix = new Mr(new Float32Array(n.array), 16); break; case "LOD": i = new fc; break; case "Line": i = new Rc(s(t.geometry), a(t.material), t.mode); break; case "LineLoop": i = new Dc(s(t.geometry), a(t.material)); break; case "LineSegments": i = new Ic(s(t.geometry), a(t.material)); break; case "PointCloud": case "Points": i = new Uc(s(t.geometry), a(t.material)); break; case "Sprite": i = new lc(a(t.material)); break; case "Group": i = new za; break; default: i = new wi }if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (i.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children) { const r = t.children; for (let t = 0; t < r.length; t++)i.add(this.parseObject(r[t], e, n)) } if ("LOD" === t.type) { void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate); const e = t.levels; for (let t = 0; t < e.length; t++) { const n = e[t], r = i.getObjectByProperty("uuid", n.object); void 0 !== r && i.addLevel(r, n.distance) } } return i } }); const kh = { UVMapping: rt, CubeReflectionMapping: ot, CubeRefractionMapping: st, EquirectangularReflectionMapping: at, EquirectangularRefractionMapping: ct, CubeUVReflectionMapping: lt, CubeUVRefractionMapping: ut }, Bh = { RepeatWrapping: ht, ClampToEdgeWrapping: dt, MirroredRepeatWrapping: ft }, zh = { NearestFilter: pt, NearestMipmapNearestFilter: mt, NearestMipmapLinearFilter: vt, LinearFilter: _t, LinearMipmapNearestFilter: xt, LinearMipmapLinearFilter: wt }; function Fh(t) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Bu.call(this, t), this.options = { premultiplyAlpha: "none" } } function Uh() { this.type = "ShapePath", this.color = new fr, this.subPaths = [], this.currentPath = null } function Hh(t) { this.type = "Font", this.data = t } function Gh(t, e, n, i, r) { const o = r.glyphs[t] || r.glyphs["?"]; if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + "."); const s = new Uh; let a, c, l, u, h, d, f, p; if (o.o) { const t = o._cachedOutline || (o._cachedOutline = o.o.split(" ")); for (let r = 0, o = t.length; r < o;) { switch (t[r++]) { case "m": a = t[r++] * e + n, c = t[r++] * e + i, s.moveTo(a, c); break; case "l": a = t[r++] * e + n, c = t[r++] * e + i, s.lineTo(a, c); break; case "q": l = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, d = t[r++] * e + i, s.quadraticCurveTo(h, d, l, u); break; case "b": l = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, d = t[r++] * e + i, f = t[r++] * e + n, p = t[r++] * e + i, s.bezierCurveTo(h, d, f, p, l, u) } } } return { offsetX: o.ha * e, path: s } } function jh(t) { Bu.call(this, t) } let Vh; Fh.prototype = Object.assign(Object.create(Bu.prototype), { constructor: Fh, isImageBitmapLoader: !0, setOptions: function (t) { return this.options = t, this }, load: function (t, e, n, i) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = Du.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () { e && e(o), r.manager.itemEnd(t) }), 0), o; fetch(t).then((function (t) { return t.blob() })).then((function (t) { return createImageBitmap(t, r.options) })).then((function (n) { Du.add(t, n), e && e(n), r.manager.itemEnd(t) })).catch((function (e) { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) })), r.manager.itemStart(t) } }), Object.assign(Uh.prototype, { moveTo: function (t, e) { return this.currentPath = new fh, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this }, lineTo: function (t, e) { return this.currentPath.lineTo(t, e), this }, quadraticCurveTo: function (t, e, n, i) { return this.currentPath.quadraticCurveTo(t, e, n, i), this }, bezierCurveTo: function (t, e, n, i, r, o) { return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this }, splineThru: function (t) { return this.currentPath.splineThru(t), this }, toShapes: function (t, e) { function n(t) { const e = []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n], r = new ph; r.curves = i.curves, e.push(r) } return e } function i(t, e) { const n = e.length; let i = !1; for (let r = n - 1, o = 0; o < n; r = o++) { let n = e[r], s = e[o], a = s.x - n.x, c = s.y - n.y; if (Math.abs(c) > Number.EPSILON) { if (c < 0 && (n = e[o], a = -a, s = e[r], c = -c), t.y < n.y || t.y > s.y) continue; if (t.y === n.y) { if (t.x === n.x) return !0 } else { const e = c * (t.x - n.x) - a * (t.y - n.y); if (0 === e) return !0; if (e < 0) continue; i = !i } } else { if (t.y !== n.y) continue; if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x) return !0 } } return i } const r = kl.isClockWise, o = this.subPaths; if (0 === o.length) return []; if (!0 === e) return n(o); let s, a, c, l = []; if (1 === o.length) return a = o[0], (c = new ph).curves = a.curves, l.push(c), l; let u = !r(o[0].getPoints()); u = t ? !u : u; const h = [], d = []; let f, p, m = [], g = 0; d[g] = void 0, m[g] = []; for (let e = 0, n = o.length; e < n; e++)s = r(f = (a = o[e]).getPoints()), (s = t ? !s : s) ? (!u && d[g] && g++, d[g] = { s: new ph, p: f }, d[g].s.curves = a.curves, u && g++, m[g] = []) : m[g].push({ h: a, p: f[0] }); if (!d[0]) return n(o); if (d.length > 1) { let t = !1; const e = []; for (let t = 0, e = d.length; t < e; t++)h[t] = []; for (let n = 0, r = d.length; n < r; n++) { const r = m[n]; for (let o = 0; o < r.length; o++) { const s = r[o]; let a = !0; for (let r = 0; r < d.length; r++)i(s.p, d[r].p) && (n !== r && e.push({ froms: n, tos: r, hole: o }), a ? (a = !1, h[r].push(s)) : t = !0); a && h[n].push(s) } } e.length > 0 && (t || (m = h)) } for (let t = 0, e = d.length; t < e; t++) { c = d[t].s, l.push(c); for (let e = 0, n = (p = m[t]).length; e < n; e++)c.holes.push(p[e].h) } return l } }), Object.assign(Hh.prototype, { isFont: !0, generateShapes: function (t, e) { void 0 === e && (e = 100); const n = [], i = function (t, e, n) { const i = Array.from ? Array.from(t) : String(t).split(""), r = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, s = []; let a = 0, c = 0; for (let t = 0; t < i.length; t++) { const e = i[t]; if ("\n" === e) a = 0, c -= o; else { const t = Gh(e, r, a, c, n); a += t.offsetX, s.push(t.path) } } return s }(t, e, this.data); for (let t = 0, e = i.length; t < e; t++)Array.prototype.push.apply(n, i[t].toShapes()); return n } }), jh.prototype = Object.assign(Object.create(Bu.prototype), { constructor: jh, load: function (t, e, n, i) { const r = this, o = new Fu(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.load(t, (function (t) { let n; try { n = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2)) } const i = r.parse(n); e && e(i) }), n, i) }, parse: function (t) { return new Hh(t) } }); const Wh = { getContext: function () { return void 0 === Vh && (Vh = new (window.AudioContext || window.webkitAudioContext)), Vh }, setContext: function (t) { Vh = t } }; function qh(t) { Bu.call(this, t) } function Xh(t, e, n) { Ph.call(this, void 0, n); const i = (new fr).set(t), r = (new fr).set(e), o = new Jn(i.r, i.g, i.b), s = new Jn(r.r, r.g, r.b), a = Math.sqrt(Math.PI), c = a * Math.sqrt(.75); this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c) } function Yh(t, e) { Ph.call(this, void 0, e); const n = (new fr).set(t); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } qh.prototype = Object.assign(Object.create(Bu.prototype), { constructor: qh, load: function (t, e, n, i) { const r = this, o = new Fu(r.manager); o.setResponseType("arraybuffer"), o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.load(t, (function (n) { try { const t = n.slice(0); Wh.getContext().decodeAudioData(t, (function (t) { e(t) })) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }), n, i) } }), Xh.prototype = Object.assign(Object.create(Ph.prototype), { constructor: Xh, isHemisphereLightProbe: !0, copy: function (t) { return Ph.prototype.copy.call(this, t), this }, toJSON: function (t) { return Ph.prototype.toJSON.call(this, t) } }), Yh.prototype = Object.assign(Object.create(Ph.prototype), { constructor: Yh, isAmbientLightProbe: !0, copy: function (t) { return Ph.prototype.copy.call(this, t), this }, toJSON: function (t) { return Ph.prototype.toJSON.call(this, t) } }); const Zh = new ri, Jh = new ri; function Qh() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new To, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new To, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } function $h(t) { this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } Object.assign(Qh.prototype, { update: function (t) { const e = this._cache; if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) { e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep; const n = t.projectionMatrix.clone(), i = e.eyeSep / 2, r = i * e.near / e.focus, o = e.near * Math.tan(Bn.DEG2RAD * e.fov * .5) / e.zoom; let s, a; Jh.elements[12] = -i, Zh.elements[12] = i, s = -o * e.aspect + r, a = o * e.aspect + r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(n), s = -o * e.aspect - r, a = o * e.aspect - r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(n) } this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Jh), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Zh) } }), Object.assign($h.prototype, { start: function () { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }, stop: function () { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { let t = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const e = ("undefined" == typeof performance ? Date : performance).now(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } }); const Kh = new Jn, td = new Xn, ed = new Jn, nd = new Jn; function id() { wi.call(this), this.type = "AudioListener", this.context = Wh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new $h } function rd(t) { wi.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this.filters = [] } id.prototype = Object.assign(Object.create(wi.prototype), { constructor: id, getInput: function () { return this.gain }, removeFilter: function () { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, getFilter: function () { return this.filter }, setFilter: function (t) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }, updateMatrixWorld: function (t) { wi.prototype.updateMatrixWorld.call(this, t); const e = this.context.listener, n = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Kh, td, ed), nd.set(0, 0, -1).applyQuaternion(td), e.positionX) { const t = this.context.currentTime + this.timeDelta; e.positionX.linearRampToValueAtTime(Kh.x, t), e.positionY.linearRampToValueAtTime(Kh.y, t), e.positionZ.linearRampToValueAtTime(Kh.z, t), e.forwardX.linearRampToValueAtTime(nd.x, t), e.forwardY.linearRampToValueAtTime(nd.y, t), e.forwardZ.linearRampToValueAtTime(nd.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t) } else e.setPosition(Kh.x, Kh.y, Kh.z), e.setOrientation(nd.x, nd.y, nd.z, n.x, n.y, n.z) } }), rd.prototype = Object.assign(Object.create(wi.prototype), { constructor: rd, getOutput: function () { return this.gain }, setNodeSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }, setMediaElementSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }, setMediaStreamSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this }, setBuffer: function (t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function (t) { if (void 0 === t && (t = 0), !0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + t; const e = this.context.createBufferSource(); return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() }, pause: function () { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function () { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function () { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (t) { return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this }, setDetune: function (t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, getDetune: function () { return this.detune }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (t) { return this.setFilters(t ? [t] : []) }, setPlaybackRate: function (t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function (t) { if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") }, setLoopStart: function (t) { return this.loopStart = t, this }, setLoopEnd: function (t) { return this.loopEnd = t, this }, getVolume: function () { return this.gain.gain.value }, setVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this } }); const od = new Jn, sd = new Xn, ad = new Jn, cd = new Jn; function ld(t) { rd.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } function ud(t, e) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) } function hd(t, e, n) { let i, r, o; switch (this.binding = t, this.valueSize = n, e) { case "quaternion": i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } ld.prototype = Object.assign(Object.create(rd.prototype), { constructor: ld, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (t) { return this.panner.refDistance = t, this }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (t) { return this.panner.rolloffFactor = t, this }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (t) { return this.panner.distanceModel = t, this }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (t) { return this.panner.maxDistance = t, this }, setDirectionalCone: function (t, e, n) { return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this }, updateMatrixWorld: function (t) { if (wi.prototype.updateMatrixWorld.call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return; this.matrixWorld.decompose(od, sd, ad), cd.set(0, 0, 1).applyQuaternion(sd); const e = this.panner; if (e.positionX) { const t = this.context.currentTime + this.listener.timeDelta; e.positionX.linearRampToValueAtTime(od.x, t), e.positionY.linearRampToValueAtTime(od.y, t), e.positionZ.linearRampToValueAtTime(od.z, t), e.orientationX.linearRampToValueAtTime(cd.x, t), e.orientationY.linearRampToValueAtTime(cd.y, t), e.orientationZ.linearRampToValueAtTime(cd.z, t) } else e.setPosition(od.x, od.y, od.z), e.setOrientation(cd.x, cd.y, cd.z) } }), Object.assign(ud.prototype, { getFrequencyData: function () { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function () { let t = 0; const e = this.getFrequencyData(); for (let n = 0; n < e.length; n++)t += e[n]; return t / e.length } }), Object.assign(hd.prototype, { accumulate: function (t, e) { const n = this.buffer, i = this.valueSize, r = t * i + i; let o = this.cumulativeWeight; if (0 === o) { for (let t = 0; t !== i; ++t)n[r + t] = n[t]; o = e } else { const t = e / (o += e); this._mixBufferRegion(n, r, 0, t, i) } this.cumulativeWeight = o }, accumulateAdditive: function (t) { const e = this.buffer, n = this.valueSize, i = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t }, apply: function (t) { const e = this.valueSize, n = this.buffer, i = t * e + e, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, s = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) { const t = e * this._origIndex; this._mixBufferRegion(n, i, t, 1 - r, e) } o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e); for (let t = e, r = e + e; t !== r; ++t)if (n[t] !== n[t + e]) { s.setValue(n, i); break } }, saveOriginalState: function () { const t = this.binding, e = this.buffer, n = this.valueSize, i = n * this._origIndex; t.getValue(e, i); for (let t = n, r = i; t !== r; ++t)e[t] = e[i + t % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 }, restoreOriginalState: function () { const t = 3 * this.valueSize; this.binding.setValue(this.buffer, t) }, _setAdditiveIdentityNumeric: function () { const t = this._addIndex * this.valueSize, e = t + this.valueSize; for (let n = t; n < e; n++)this.buffer[n] = 0 }, _setAdditiveIdentityQuaternion: function () { this._setAdditiveIdentityNumeric(), this.buffer[4 * this._addIndex + 3] = 1 }, _setAdditiveIdentityOther: function () { const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[e + n] = this.buffer[t + n] }, _select: function (t, e, n, i, r) { if (i >= .5) for (let i = 0; i !== r; ++i)t[e + i] = t[n + i] }, _slerp: function (t, e, n, i) { Xn.slerpFlat(t, e, t, e, t, n, i) }, _slerpAdditive: function (t, e, n, i, r) { const o = this._workIndex * r; Xn.multiplyQuaternionsFlat(t, o, t, e, t, n), Xn.slerpFlat(t, e, t, e, t, o, i) }, _lerp: function (t, e, n, i, r) { const o = 1 - i; for (let s = 0; s !== r; ++s) { const r = e + s; t[r] = t[r] * o + t[n + s] * i } }, _lerpAdditive: function (t, e, n, i, r) { for (let o = 0; o !== r; ++o) { const r = e + o; t[r] = t[r] + t[n + o] * i } } }); const dd = new RegExp("[\\[\\]\\.:\\/]", "g"), fd = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", pd = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), md = /(WCOD+)?/.source.replace("WCOD", fd), gd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), vd = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), yd = new RegExp("^" + pd + md + gd + vd + "$"), _d = ["material", "materials", "bones"]; function xd(t, e, n) { const i = n || bd.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, i) } function bd(t, e, n) { this.path = e, this.parsedPath = n || bd.parseTrackName(e), this.node = bd.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } function wd() { this.uuid = Bn.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const t = {}; this._indicesByUUID = t; for (let e = 0, n = arguments.length; e !== n; ++e)t[arguments[e].uuid] = e; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const e = this; this.stats = { objects: { get total() { return e._objects.length }, get inUse() { return this.total - e.nCachedObjects_ } }, get bindingsPerObject() { return e._bindings.length } } } function Md(t, e, n, i) { this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = i || e.blendMode; const r = e.tracks, o = r.length, s = new Array(o), a = { endingStart: Ge, endingEnd: Ge }; for (let t = 0; t !== o; ++t) { const e = r[t].createInterpolant(null); s[t] = e, e.settings = a } this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Be, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } function Td(t) { this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } function Sd(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t } function Ed(t, e, n) { qa.call(this, t, e), this.meshPerAttribute = n || 1 } function Ad(t, e, n, i) { this.ray = new Yi(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new ci, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) } function Pd(t, e) { return t.distance - e.distance } function Ld(t, e, n, i) { if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) { const i = t.children; for (let t = 0, r = i.length; t < r; t++)Ld(i[t], e, n, !0) } } Object.assign(xd.prototype, { getValue: function (t, e) { this.bind(); const n = this._targetGroup.nCachedObjects_, i = this._bindings[n]; void 0 !== i && i.getValue(t, e) }, setValue: function (t, e) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(t, e) }, bind: function () { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() }, unbind: function () { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } }), Object.assign(bd, { Composite: xd, create: function (t, e, n) { return t && t.isAnimationObjectGroup ? new bd.Composite(t, e, n) : new bd(t, e, n) }, sanitizeNodeName: function (t) { return t.replace(/\s/g, "_").replace(dd, "") }, parseTrackName: function (t) { const e = yd.exec(t); if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, i = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i) { const t = n.nodeName.substring(i + 1); -1 !== _d.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return n }, findNode: function (t, e) { if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n } if (t.children) { const n = function (t) { for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.name === e || r.uuid === e) return r; const o = n(r.children); if (o) return o } return null }, i = n(t.children); if (i) return i } return null } }), Object.assign(bd.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)t[e++] = n[i] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.targetObject[this.propertyName] = t[e] }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++] }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { let t = this.node, e = this.parsedPath, n = e.objectName, i = e.propertyName, r = e.propertyIndex; if (t || (t = bd.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (n) { let i = e.objectIndex; switch (n) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); t = t.skeleton.bones; for (let e = 0; e < t.length; e++)if (t[e].name === i) { i = e; break } break; default: if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[n] }if (void 0 !== i) { if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[i] } } const o = t[i]; if (void 0 === o) { const n = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t) } let s = this.Versioning.None; this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate); let a = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === i) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]) } a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i; this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s] }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(bd.prototype, { _getValue_unbound: bd.prototype.getValue, _setValue_unbound: bd.prototype.setValue }), Object.assign(wd.prototype, { isAnimationObjectGroup: !0, add: function () { const t = this._objects, e = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, o = r.length; let s = void 0, a = t.length, c = this.nCachedObjects_; for (let l = 0, u = arguments.length; l !== u; ++l) { const u = arguments[l], h = u.uuid; let d = e[h]; if (void 0 === d) { d = a++, e[h] = d, t.push(u); for (let t = 0, e = o; t !== e; ++t)r[t].push(new bd(u, n[t], i[t])) } else if (d < c) { s = t[d]; const a = --c, l = t[a]; e[l.uuid] = d, t[d] = l, e[h] = a, t[a] = u; for (let t = 0, e = o; t !== e; ++t) { const e = r[t], o = e[a]; let s = e[d]; e[d] = o, void 0 === s && (s = new bd(u, n[t], i[t])), e[a] = s } } else t[d] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = c }, remove: function () { const t = this._objects, e = this._indicesByUUID, n = this._bindings, i = n.length; let r = this.nCachedObjects_; for (let o = 0, s = arguments.length; o !== s; ++o) { const s = arguments[o], a = s.uuid, c = e[a]; if (void 0 !== c && c >= r) { const o = r++, l = t[o]; e[l.uuid] = c, t[c] = l, e[a] = o, t[o] = s; for (let t = 0, e = i; t !== e; ++t) { const e = n[t], i = e[o], r = e[c]; e[c] = i, e[o] = r } } } this.nCachedObjects_ = r }, uncache: function () { const t = this._objects, e = this._indicesByUUID, n = this._bindings, i = n.length; let r = this.nCachedObjects_, o = t.length; for (let s = 0, a = arguments.length; s !== a; ++s) { const a = arguments[s].uuid, c = e[a]; if (void 0 !== c) if (delete e[a], c < r) { const s = --r, a = t[s], l = --o, u = t[l]; e[a.uuid] = c, t[c] = a, e[u.uuid] = s, t[s] = u, t.pop(); for (let t = 0, e = i; t !== e; ++t) { const e = n[t], i = e[s], r = e[l]; e[c] = i, e[s] = r, e.pop() } } else { const r = --o, s = t[r]; e[s.uuid] = c, t[c] = s, t.pop(); for (let t = 0, e = i; t !== e; ++t) { const e = n[t]; e[c] = e[r], e.pop() } } } this.nCachedObjects_ = r }, subscribe_: function (t, e) { let n = this._bindingsIndicesByPath, i = n[t], r = this._bindings; if (void 0 !== i) return r[i]; const o = this._paths, s = this._parsedPaths, a = this._objects, c = a.length, l = this.nCachedObjects_, u = new Array(c); i = r.length, n[t] = i, o.push(t), s.push(e), r.push(u); for (let n = l, i = a.length; n !== i; ++n) { const i = a[n]; u[n] = new bd(i, t, e) } return u }, unsubscribe_: function (t) { const e = this._bindingsIndicesByPath, n = e[t]; if (void 0 !== n) { const i = this._paths, r = this._parsedPaths, o = this._bindings, s = o.length - 1, a = o[s]; e[t[s]] = n, o[n] = a, o.pop(), r[n] = r[s], r.pop(), i[n] = i[s], i.pop() } } }), Object.assign(Md.prototype, { play: function () { return this._mixer._activateAction(this), this }, stop: function () { return this._mixer._deactivateAction(this), this.reset() }, reset: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (t) { return this._startTime = t, this }, setLoop: function (t, e) { return this.loop = t, this.repetitions = e, this }, setEffectiveWeight: function (t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (t) { return this._scheduleFading(t, 0, 1) }, fadeOut: function (t) { return this._scheduleFading(t, 1, 0) }, crossFadeFrom: function (t, e, n) { if (t.fadeOut(e), this.fadeIn(e), n) { const n = this._clip.duration, i = t._clip.duration, r = i / n, o = n / i; t.warp(1, r, e), this.warp(o, 1, e) } return this }, crossFadeTo: function (t, e, n) { return t.crossFadeFrom(this, e, n) }, stopFading: function () { let t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, setEffectiveTimeScale: function (t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }, syncWith: function (t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }, halt: function (t) { return this.warp(this._effectiveTimeScale, 0, t) }, warp: function (t, e, n) { const i = this._mixer, r = i.time, o = this.timeScale; let s = this._timeScaleInterpolant; null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s); const a = s.parameterPositions, c = s.sampleValues; return a[0] = r, a[1] = r + n, c[0] = t / o, c[1] = e / o, this }, stopWarping: function () { let t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (t, e, n, i) { if (!this.enabled) return void this._updateWeight(t); const r = this._startTime; if (null !== r) { const i = (t - r) * n; if (i < 0 || 0 === n) return; this._startTime = null, e = n * i } e *= this._updateTimeScale(t); const o = this._updateTime(e), s = this._updateWeight(t); if (s > 0) { const t = this._interpolants, e = this._propertyBindings; switch (this.blendMode) { case qe: for (let n = 0, i = t.length; n !== i; ++n)t[n].evaluate(o), e[n].accumulateAdditive(s); break; case We: default: for (let n = 0, r = t.length; n !== r; ++n)t[n].evaluate(o), e[n].accumulate(i, s) } } }, _updateWeight: function (t) { let e = 0; if (this.enabled) { e = this.weight; const n = this._weightInterpolant; if (null !== n) { const i = n.evaluate(t)[0]; e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)) } } return this._effectiveWeight = e, e }, _updateTimeScale: function (t) { let e = 0; if (!this.paused) { e = this.timeScale; const n = this._timeScaleInterpolant; if (null !== n) { e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e) } } return this._effectiveTimeScale = e, e }, _updateTime: function (t) { const e = this._clip.duration, n = this.loop; let i = this.time + t, r = this._loopCount; const o = n === ze; if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i; if (n === ke) { -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)); t: { if (i >= e) i = e; else { if (!(i < 0)) { this.time = i; break t } i = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 }) } } else { if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), i >= e || i < 0) { const n = Math.floor(i / e); i -= e * n, r += Math.abs(n); const s = this.repetitions - r; if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 }); else { if (1 === s) { const e = t < 0; this._setEndings(e, !e, o) } else this._setEndings(!1, !1, o); this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = i; if (o && 1 == (1 & r)) return e - i } return i }, _setEndings: function (t, e, n) { const i = this._interpolantSettings; n ? (i.endingStart = je, i.endingEnd = je) : (i.endingStart = t ? this.zeroSlopeAtStart ? je : Ge : Ve, i.endingEnd = e ? this.zeroSlopeAtEnd ? je : Ge : Ve) }, _scheduleFading: function (t, e, n) { const i = this._mixer, r = i.time; let o = this._weightInterpolant; null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o); const s = o.parameterPositions, a = o.sampleValues; return s[0] = r, a[0] = e, s[1] = r + t, a[1] = n, this } }), Td.prototype = Object.assign(Object.create(Dn.prototype), { constructor: Td, _bindAction: function (t, e) { const n = t._localRoot || this._root, i = t._clip.tracks, r = i.length, o = t._propertyBindings, s = t._interpolants, a = n.uuid, c = this._bindingsByRootAndName; let l = c[a]; void 0 === l && (l = {}, c[a] = l); for (let t = 0; t !== r; ++t) { const r = i[t], c = r.name; let u = l[c]; if (void 0 !== u) o[t] = u; else { if (void 0 !== (u = o[t])) { null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, c)); continue } const i = e && e._propertyBindings[t].binding.parsedPath; ++(u = new hd(bd.create(n, c, i), r.ValueTypeName, r.getValueSize())).referenceCount, this._addInactiveBinding(u, a, c), o[t] = u } s[t].resultBuffer = u.buffer } }, _activateAction: function (t) { if (!this._isActiveAction(t)) { if (null === t._cacheIndex) { const e = (t._localRoot || this._root).uuid, n = t._clip.uuid, i = this._actionsByClip[n]; this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e) } const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(t) } }, _deactivateAction: function (t) { if (this._isActiveAction(t)) { const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(t) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const t = this; this.stats = { actions: { get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: { get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: { get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } } }, _isActiveAction: function (t) { const e = t._cacheIndex; return null !== e && e < this._nActiveActions }, _addInactiveAction: function (t, e, n) { const i = this._actions, r = this._actionsByClip; let o = r[e]; if (void 0 === o) o = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = o; else { const e = o.knownActions; t._byClipCacheIndex = e.length, e.push(t) } t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t }, _removeInactiveAction: function (t) { const e = this._actions, n = e[e.length - 1], i = t._cacheIndex; n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null; const r = t._clip.uuid, o = this._actionsByClip, s = o[r], a = s.knownActions, c = a[a.length - 1], l = t._byClipCacheIndex; c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null, delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t) }, _removeInactiveBindingsForAction: function (t) { const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == --n.referenceCount && this._removeInactiveBinding(n) } }, _lendAction: function (t) { const e = this._actions, n = t._cacheIndex, i = this._nActiveActions++, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _takeBackAction: function (t) { const e = this._actions, n = t._cacheIndex, i = --this._nActiveActions, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _addInactiveBinding: function (t, e, n) { const i = this._bindingsByRootAndName, r = this._bindings; let o = i[e]; void 0 === o && (o = {}, i[e] = o), o[n] = t, t._cacheIndex = r.length, r.push(t) }, _removeInactiveBinding: function (t) { const e = this._bindings, n = t.binding, i = n.rootNode.uuid, r = n.path, o = this._bindingsByRootAndName, s = o[i], a = e[e.length - 1], c = t._cacheIndex; a._cacheIndex = c, e[c] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[i] }, _lendBinding: function (t) { const e = this._bindings, n = t._cacheIndex, i = this._nActiveBindings++, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _takeBackBinding: function (t) { const e = this._bindings, n = t._cacheIndex, i = --this._nActiveBindings, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _lendControlInterpolant: function () { const t = this._controlInterpolants, e = this._nActiveControlInterpolants++; let n = t[e]; return void 0 === n && ((n = new wu(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n }, _takeBackControlInterpolant: function (t) { const e = this._controlInterpolants, n = t.__cacheIndex, i = --this._nActiveControlInterpolants, r = e[i]; t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e, n) { const i = e || this._root, r = i.uuid; let o = "string" == typeof t ? Cu.findByName(i, t) : t; const s = null !== o ? o.uuid : t; let a = this._actionsByClip[s], c = null; if (void 0 === n && (n = null !== o ? o.blendMode : We), void 0 !== a) { const t = a.actionByRoot[r]; if (void 0 !== t && t.blendMode === n) return t; c = a.knownActions[0], null === o && (o = c._clip) } if (null === o) return null; const l = new Md(this, o, e, n); return this._bindAction(l, c), this._addInactiveAction(l, s, r), l }, existingAction: function (t, e) { const n = e || this._root, i = n.uuid, r = "string" == typeof t ? Cu.findByName(n, t) : t, o = r ? r.uuid : t, s = this._actionsByClip[o]; return void 0 !== s && s.actionByRoot[i] || null }, stopAllAction: function () { const t = this._actions; for (let e = this._nActiveActions - 1; e >= 0; --e)t[e].stop(); return this }, update: function (t) { t *= this.timeScale; const e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1; for (let s = 0; s !== n; ++s) { e[s]._update(i, t, r, o) } const s = this._bindings, a = this._nActiveBindings; for (let t = 0; t !== a; ++t)s[t].apply(o); return this }, setTime: function (t) { this.time = 0; for (let t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(t) }, getRoot: function () { return this._root }, uncacheClip: function (t) { const e = this._actions, n = t.uuid, i = this._actionsByClip, r = i[n]; if (void 0 !== r) { const t = r.knownActions; for (let n = 0, i = t.length; n !== i; ++n) { const i = t[n]; this._deactivateAction(i); const r = i._cacheIndex, o = e[e.length - 1]; i._cacheIndex = null, i._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(i) } delete i[n] } }, uncacheRoot: function (t) { const e = t.uuid, n = this._actionsByClip; for (const t in n) { const i = n[t].actionByRoot[e]; void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } const i = this._bindingsByRootAndName[e]; if (void 0 !== i) for (const t in i) { const e = i[t]; e.restoreOriginalState(), this._removeInactiveBinding(e) } }, uncacheAction: function (t, e) { const n = this.existingAction(t, e); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } }), Sd.prototype.clone = function () { return new Sd(void 0 === this.value.clone ? this.value : this.value.clone()) }, Ed.prototype = Object.assign(Object.create(qa.prototype), { constructor: Ed, isInstancedInterleavedBuffer: !0, copy: function (t) { return qa.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, clone: function (t) { const e = qa.prototype.clone.call(this, t); return e.meshPerAttribute = this.meshPerAttribute, e }, toJSON: function (t) { const e = qa.prototype.toJSON.call(this, t); return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e } }), Object.assign(Ad.prototype, { set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (t, e, n) { const i = n || []; return Ld(t, this, i, e), i.sort(Pd), i }, intersectObjects: function (t, e, n) { const i = n || []; if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i; for (let n = 0, r = t.length; n < r; n++)Ld(t[n], this, i, e); return i.sort(Pd), i } }); class Rd { constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.phi = e, this.theta = n, this } set(t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) } setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Bn.clamp(e / this.radius, -1, 1))), this } } function Od(t, e, n) { return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this } Object.assign(Od.prototype, { set: function (t, e, n) { return this.radius = t, this.theta = e, this.y = n, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }, setFromVector3: function (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, setFromCartesianCoords: function (t, e, n) { return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this } }); const Cd = new zn; function Id(t, e) { this.min = void 0 !== t ? t : new zn(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new zn(-1 / 0, -1 / 0) } Object.assign(Id.prototype, { set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function (t, e) { const n = Cd.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new zn), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new zn), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new zn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new zn), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: function (t) { return Cd.copy(t).clamp(this.min, this.max).sub(t).length() }, intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }); const Dd = new Jn, Nd = new Jn; function kd(t, e) { this.start = void 0 !== t ? t : new Jn, this.end = void 0 !== e ? e : new Jn } function Bd(t) { wi.call(this), this.material = t, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } Object.assign(kd.prototype, { set: function (t, e) { return this.start.copy(t), this.end.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new Jn), t.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (t) { return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new Jn), t.subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new Jn), this.delta(e).multiplyScalar(t).add(this.start) }, closestPointToPointParameter: function (t, e) { Dd.subVectors(t, this.start), Nd.subVectors(this.end, this.start); const n = Nd.dot(Nd); let i = Nd.dot(Dd) / n; return e && (i = Bn.clamp(i, 0, 1)), i }, closestPointToPoint: function (t, e, n) { const i = this.closestPointToPointParameter(t, e); return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Jn), this.delta(n).multiplyScalar(i).add(this.start) }, applyMatrix4: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, equals: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) } }), Bd.prototype = Object.create(wi.prototype), Bd.prototype.constructor = Bd, Bd.prototype.isImmediateRenderObject = !0; const zd = new Jn; function Fd(t, e) { wi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e; const n = new Gr, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let t = 0, e = 1, n = 32; t < n; t++, e++) { const r = t / n * Math.PI * 2, o = e / n * Math.PI * 2; i.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1) } n.setAttribute("position", new Or(i, 3)); const r = new Tc({ fog: !1, toneMapped: !1 }); this.cone = new Ic(n, r), this.add(this.cone), this.update() } Fd.prototype = Object.create(wi.prototype), Fd.prototype.constructor = Fd, Fd.prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, Fd.prototype.update = function () { this.light.updateMatrixWorld(); const t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle); this.cone.scale.set(e, e, t), zd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(zd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) }; const Ud = new Jn, Hd = new ri, Gd = new ri; function jd(t) { const e = function t(e) { const n = []; e && e.isBone && n.push(e); for (let i = 0; i < e.children.length; i++)n.push.apply(n, t(e.children[i])); return n }(t), n = new Gr, i = [], r = [], o = new fr(0, 0, 1), s = new fr(0, 1, 0); for (let t = 0; t < e.length; t++) { const n = e[t]; n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b)) } n.setAttribute("position", new Or(i, 3)), n.setAttribute("color", new Or(r, 3)); const a = new Tc({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); Ic.call(this, n, a), this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } function Vd(t, e, n) { this.light = t, this.light.updateMatrixWorld(), this.color = n; const i = new ql(e, 4, 2), r = new xr({ wireframe: !0, fog: !1, toneMapped: !1 }); so.call(this, i, r), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } jd.prototype = Object.create(Ic.prototype), jd.prototype.constructor = jd, jd.prototype.isSkeletonHelper = !0, jd.prototype.updateMatrixWorld = function (t) { const e = this.bones, n = this.geometry, i = n.getAttribute("position"); Gd.getInverse(this.root.matrixWorld); for (let t = 0, n = 0; t < e.length; t++) { const r = e[t]; r.parent && r.parent.isBone && (Hd.multiplyMatrices(Gd, r.matrixWorld), Ud.setFromMatrixPosition(Hd), i.setXYZ(n, Ud.x, Ud.y, Ud.z), Hd.multiplyMatrices(Gd, r.parent.matrixWorld), Ud.setFromMatrixPosition(Hd), i.setXYZ(n + 1, Ud.x, Ud.y, Ud.z), n += 2) } n.getAttribute("position").needsUpdate = !0, wi.prototype.updateMatrixWorld.call(this, t) }, Vd.prototype = Object.create(so.prototype), Vd.prototype.constructor = Vd, Vd.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, Vd.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }; const Wd = new Jn, qd = new fr, Xd = new fr; function Yd(t, e, n) { wi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n; const i = new tl(e); i.rotateY(.5 * Math.PI), this.material = new xr({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0); const r = i.getAttribute("position"), o = new Float32Array(3 * r.count); i.setAttribute("color", new Mr(o, 3)), this.add(new so(i, this.material)), this.update() } function Zd(t, e, n, i) { t = t || 10, e = e || 10, n = new fr(void 0 !== n ? n : 4473924), i = new fr(void 0 !== i ? i : 8947848); const r = e / 2, o = t / e, s = t / 2, a = [], c = []; for (let t = 0, l = 0, u = -s; t <= e; t++, u += o) { a.push(-s, 0, u, s, 0, u), a.push(u, 0, -s, u, 0, s); const e = t === r ? n : i; e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3 } const l = new Gr; l.setAttribute("position", new Or(a, 3)), l.setAttribute("color", new Or(c, 3)); const u = new Tc({ vertexColors: !0, toneMapped: !1 }); Ic.call(this, l, u), this.type = "GridHelper" } function Jd(t, e, n, i, r, o) { t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new fr(void 0 !== r ? r : 4473924), o = new fr(void 0 !== o ? o : 8947848); const s = [], a = []; for (let n = 0; n <= e; n++) { const i = n / e * (2 * Math.PI), c = Math.sin(i) * t, l = Math.cos(i) * t; s.push(0, 0, 0), s.push(c, 0, l); const u = 1 & n ? r : o; a.push(u.r, u.g, u.b), a.push(u.r, u.g, u.b) } for (let e = 0; e <= n; e++) { const c = 1 & e ? r : o, l = t - t / n * e; for (let t = 0; t < i; t++) { let e = t / i * (2 * Math.PI), n = Math.sin(e) * l, r = Math.cos(e) * l; s.push(n, 0, r), a.push(c.r, c.g, c.b), e = (t + 1) / i * (2 * Math.PI), n = Math.sin(e) * l, r = Math.cos(e) * l, s.push(n, 0, r), a.push(c.r, c.g, c.b) } } const c = new Gr; c.setAttribute("position", new Or(s, 3)), c.setAttribute("color", new Or(a, 3)); const l = new Tc({ vertexColors: !0, toneMapped: !1 }); Ic.call(this, c, l), this.type = "PolarGridHelper" } Yd.prototype = Object.create(wi.prototype), Yd.prototype.constructor = Yd, Yd.prototype.dispose = function () { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, Yd.prototype.update = function () { const t = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { const e = t.geometry.getAttribute("color"); qd.copy(this.light.color), Xd.copy(this.light.groundColor); for (let t = 0, n = e.count; t < n; t++) { const i = t < n / 2 ? qd : Xd; e.setXYZ(t, i.r, i.g, i.b) } e.needsUpdate = !0 } t.lookAt(Wd.setFromMatrixPosition(this.light.matrixWorld).negate()) }, Zd.prototype = Object.create(Ic.prototype), Zd.prototype.constructor = Zd, Jd.prototype = Object.create(Ic.prototype), Jd.prototype.constructor = Jd; const Qd = new Jn, $d = new Jn, Kd = new Jn; function tf(t, e, n) { wi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1); let i = new Gr; i.setAttribute("position", new Or([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)); const r = new Tc({ fog: !1, toneMapped: !1 }); this.lightPlane = new Rc(i, r), this.add(this.lightPlane), (i = new Gr).setAttribute("position", new Or([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Rc(i, r), this.add(this.targetLine), this.update() } tf.prototype = Object.create(wi.prototype), tf.prototype.constructor = tf, tf.prototype.dispose = function () { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, tf.prototype.update = function () { Qd.setFromMatrixPosition(this.light.matrixWorld), $d.setFromMatrixPosition(this.light.target.matrixWorld), Kd.subVectors($d, Qd), this.lightPlane.lookAt($d), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt($d), this.targetLine.scale.z = Kd.length() }; const ef = new Jn, nf = new Mo; function rf(t) { const e = new Gr, n = new Tc({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], o = {}, s = new fr(16755200), a = new fr(16711680), c = new fr(43775), l = new fr(16777215), u = new fr(3355443); function h(t, e, n) { d(t, n), d(e, n) } function d(t, e) { i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(i.length / 3 - 1) } h("n1", "n2", s), h("n2", "n4", s), h("n4", "n3", s), h("n3", "n1", s), h("f1", "f2", s), h("f2", "f4", s), h("f4", "f3", s), h("f3", "f1", s), h("n1", "f1", s), h("n2", "f2", s), h("n3", "f3", s), h("n4", "f4", s), h("p", "n1", a), h("p", "n2", a), h("p", "n3", a), h("p", "n4", a), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", l), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), e.setAttribute("position", new Or(i, 3)), e.setAttribute("color", new Or(r, 3)), Ic.call(this, e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update() } function of(t, e, n, i, r, o, s) { ef.set(r, o, s).unproject(i); const a = e[t]; if (void 0 !== a) { const t = n.getAttribute("position"); for (let e = 0, n = a.length; e < n; e++)t.setXYZ(a[e], ef.x, ef.y, ef.z) } } rf.prototype = Object.create(Ic.prototype), rf.prototype.constructor = rf, rf.prototype.update = function () { const t = this.geometry, e = this.pointMap; nf.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), of("c", e, t, nf, 0, 0, -1), of("t", e, t, nf, 0, 0, 1), of("n1", e, t, nf, -1, -1, -1), of("n2", e, t, nf, 1, -1, -1), of("n3", e, t, nf, -1, 1, -1), of("n4", e, t, nf, 1, 1, -1), of("f1", e, t, nf, -1, -1, 1), of("f2", e, t, nf, 1, -1, 1), of("f3", e, t, nf, -1, 1, 1), of("f4", e, t, nf, 1, 1, 1), of("u1", e, t, nf, .7, 1.1, -1), of("u2", e, t, nf, -.7, 1.1, -1), of("u3", e, t, nf, 0, 2, -1), of("cf1", e, t, nf, -1, 0, 1), of("cf2", e, t, nf, 1, 0, 1), of("cf3", e, t, nf, 0, -1, 1), of("cf4", e, t, nf, 0, 1, 1), of("cn1", e, t, nf, -1, 0, -1), of("cn2", e, t, nf, 1, 0, -1), of("cn3", e, t, nf, 0, -1, -1), of("cn4", e, t, nf, 0, 1, -1), t.getAttribute("position").needsUpdate = !0 }; const sf = new Bi; function af(t, e) { this.object = t, void 0 === e && (e = 16776960); const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), r = new Gr; r.setIndex(new Mr(n, 1)), r.setAttribute("position", new Mr(i, 3)), Ic.call(this, r, new Tc({ color: e, toneMapped: !1 })), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } function cf(t, e) { this.type = "Box3Helper", this.box = t, void 0 === e && (e = 16776960); const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Gr; i.setIndex(new Mr(n, 1)), i.setAttribute("position", new Or([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ic.call(this, i, new Tc({ color: e, toneMapped: !1 })), this.type = "Box3Helper", this.geometry.computeBoundingSphere() } function lf(t, e, n) { this.plane = t, this.size = void 0 === e ? 1 : e; const i = void 0 !== n ? n : 16776960, r = new Gr; r.setAttribute("position", new Or([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), Rc.call(this, r, new Tc({ color: i, toneMapped: !1 })), this.type = "PlaneHelper"; const o = new Gr; o.setAttribute("position", new Or([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new so(o, new xr({ color: i, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } af.prototype = Object.create(Ic.prototype), af.prototype.constructor = af, af.prototype.update = function (t) { if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && sf.setFromObject(this.object), sf.isEmpty()) return; const e = sf.min, n = sf.max, i = this.geometry.attributes.position, r = i.array; r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere() }, af.prototype.setFromObject = function (t) { return this.object = t, this.update(), this }, af.prototype.copy = function (t) { return Ic.prototype.copy.call(this, t), this.object = t.object, this }, cf.prototype = Object.create(Ic.prototype), cf.prototype.constructor = cf, cf.prototype.updateMatrixWorld = function (t) { const e = this.box; e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), wi.prototype.updateMatrixWorld.call(this, t)) }, lf.prototype = Object.create(Rc.prototype), lf.prototype.constructor = lf, lf.prototype.updateMatrixWorld = function (t) { let e = -this.plane.constant; Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? m : p, this.lookAt(this.plane.normal), wi.prototype.updateMatrixWorld.call(this, t) }; const uf = new Jn; let hf, df; function ff(t, e, n, i, r, o) { wi.call(this), this.type = "ArrowHelper", void 0 === t && (t = new Jn(0, 0, 1)), void 0 === e && (e = new Jn(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === hf && ((hf = new Gr).setAttribute("position", new Or([0, 0, 0, 0, 1, 0], 3)), (df = new nu(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Rc(hf, new Tc({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new so(df, new xr({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o) } function pf(t) { const e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], n = new Gr; n.setAttribute("position", new Or(e, 3)), n.setAttribute("color", new Or([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); const i = new Tc({ vertexColors: !0, toneMapped: !1 }); Ic.call(this, n, i), this.type = "AxesHelper" } ff.prototype = Object.create(wi.prototype), ff.prototype.constructor = ff, ff.prototype.setDirection = function (t) { if (t.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { uf.set(t.z, 0, -t.x).normalize(); const e = Math.acos(t.y); this.quaternion.setFromAxisAngle(uf, e) } }, ff.prototype.setLength = function (t, e, n) { void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix() }, ff.prototype.setColor = function (t) { this.line.material.color.set(t), this.cone.material.color.set(t) }, ff.prototype.copy = function (t) { return wi.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this }, pf.prototype = Object.create(Ic.prototype), pf.prototype.constructor = pf; const mf = 4, gf = 8, vf = Math.pow(2, gf), yf = [.125, .215, .35, .446, .526, .582], _f = gf - mf + 1 + yf.length, xf = 20, bf = { [Je]: 0, [Qe]: 1, [Ke]: 2, [en]: 3, [nn]: 4, [rn]: 5, [$e]: 6 }, wf = new wh, { _lodPlanes: Mf, _sizeLods: Tf, _sigmas: Sf } = function () { const t = [], e = [], n = []; let i = gf; for (let r = 0; r < _f; r++) { const o = Math.pow(2, i); e.push(o); let s = 1 / o; r > gf - mf ? s = yf[r - gf + mf - 1] : 0 == r && (s = 0), n.push(s); const a = 1 / (o - 1), c = -a / 2, l = 1 + a / 2, u = [c, c, l, c, l, l, c, c, l, l, c, l], h = 6, d = 6, f = 3, p = 2, m = 1, g = new Float32Array(f * d * h), v = new Float32Array(p * d * h), y = new Float32Array(m * d * h); for (let t = 0; t < h; t++) { const e = t % 3 * 2 / 3 - 1, n = t > 2 ? 0 : -1, i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0]; g.set(i, f * d * t), v.set(u, p * d * t); const r = [t, t, t, t, t, t]; y.set(r, m * d * t) } const _ = new Gr; _.setAttribute("position", new Mr(g, f)), _.setAttribute("uv", new Mr(v, p)), _.setAttribute("faceIndex", new Mr(y, m)), t.push(_), i > mf && i-- } return { _lodPlanes: t, _sizeLods: e, _sigmas: n } }(); let Ef = null; const Af = (1 + Math.sqrt(5)) / 2, Pf = 1 / Af, Lf = [new Jn(1, 1, 1), new Jn(-1, 1, 1), new Jn(1, 1, -1), new Jn(-1, 1, -1), new Jn(0, Af, Pf), new Jn(0, Af, -Pf), new Jn(Pf, 0, Af), new Jn(-Pf, 0, Af), new Jn(Af, Pf, 0), new Jn(-Af, Pf, 0)]; function Rf(t) { this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function (t) { const e = new Float32Array(t), n = new Jn(0, 1, 0); return new lu({ name: "SphericalGaussianBlur", defines: { n: t }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n }, inputEncoding: { value: bf[Je] }, outputEncoding: { value: bf[Je] } }, vertexShader: kf(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Bf()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: _, depthTest: !1, depthWrite: !1 }) }(xf), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial) } function Of(t) { return void 0 !== t && t.type === Tt && (t.encoding === Je || t.encoding === Qe || t.encoding === $e) } function Cf(t) { const e = new Wn(3 * vf, 3 * vf, t); return e.texture.mapping = lt, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e } function If(t, e, n, i, r) { t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r) } function Df() { return new lu({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: new zn(1, 1) }, inputEncoding: { value: bf[Je] }, outputEncoding: { value: bf[Je] } }, vertexShader: kf(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Bf()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: _, depthTest: !1, depthWrite: !1 }) } function Nf() { return new lu({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: bf[Je] }, outputEncoding: { value: bf[Je] } }, vertexShader: kf(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Bf()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: _, depthTest: !1, depthWrite: !1 }) } function kf() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function Bf() { return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t" } function zf(t, e, n, i, r, o, s) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new vr(t, e, n, r, o, s) } Rf.prototype = { constructor: Rf, fromScene: function (t, e = 0, n = .1, i = 100) { Ef = this._renderer.getRenderTarget(); const r = this._allocateTargets(); return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r }, fromEquirectangular: function (t) { return this._fromTexture(t) }, fromCubemap: function (t) { return this._fromTexture(t) }, compileCubemapShader: function () { null === this._cubemapShader && (this._cubemapShader = Nf(), this._compileMaterial(this._cubemapShader)) }, compileEquirectangularShader: function () { null === this._equirectShader && (this._equirectShader = Df(), this._compileMaterial(this._equirectShader)) }, dispose: function () { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (let t = 0; t < Mf.length; t++)Mf[t].dispose() }, _cleanup: function (t) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Ef), t.scissorTest = !1, If(t, 0, 0, t.width, t.height) }, _fromTexture: function (t) { Ef = this._renderer.getRenderTarget(); const e = this._allocateTargets(t); return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e }, _allocateTargets: function (t) { const e = { magFilter: pt, minFilter: pt, generateMipmaps: !1, type: Tt, format: Ht, encoding: Of(t) ? t.encoding : Ke, depthBuffer: !1, stencilBuffer: !1 }, n = Cf(e); return n.depthBuffer = !t, this._pingPongRenderTarget = Cf(e), n }, _compileMaterial: function (t) { const e = new so(Mf[0], t); this._renderer.compile(e, wf) }, _sceneToCubeUV: function (t, e, n, i) { const r = new To(90, 1, e, n), o = [1, -1, 1, 1, 1, 1], s = [1, 1, 1, -1, -1, -1], a = this._renderer, c = a.outputEncoding, l = a.toneMapping, u = a.getClearColor(), h = a.getClearAlpha(); a.toneMapping = $, a.outputEncoding = Je; let d = t.background; if (d && d.isColor) { d.convertSRGBToLinear(); const e = Math.max(d.r, d.g, d.b), n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127); d = d.multiplyScalar(Math.pow(2, -n)); const i = (n + 128) / 255; a.setClearColor(d, i), t.background = null } for (let e = 0; e < 6; e++) { const n = e % 3; 0 == n ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0)) : 1 == n ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0)) : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])), If(i, n * vf, e > 2 ? vf : 0, vf, vf), a.setRenderTarget(i), a.render(t, r) } a.toneMapping = l, a.outputEncoding = c, a.setClearColor(u, h) }, _textureToCubeUV: function (t, e) { const n = this._renderer; t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Nf()) : null == this._equirectShader && (this._equirectShader = Df()); const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader, r = new so(Mf[0], i), o = i.uniforms; o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = bf[t.encoding], o.outputEncoding.value = bf[e.texture.encoding], If(e, 0, 0, 3 * vf, 2 * vf), n.setRenderTarget(e), n.render(r, wf) }, _applyPMREM: function (t) { const e = this._renderer, n = e.autoClear; e.autoClear = !1; for (let e = 1; e < _f; e++) { const n = Math.sqrt(Sf[e] * Sf[e] - Sf[e - 1] * Sf[e - 1]), i = Lf[(e - 1) % Lf.length]; this._blur(t, e - 1, e, n, i) } e.autoClear = n }, _blur: function (t, e, n, i, r) { const o = this._pingPongRenderTarget; this._halfBlur(t, o, e, n, i, "latitudinal", r), this._halfBlur(o, t, n, n, i, "longitudinal", r) }, _halfBlur: function (t, e, n, i, r, o, s) { const a = this._renderer, c = this._blurMaterial; "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!"); const l = new so(Mf[i], c), u = c.uniforms, h = Tf[n] - 1, d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / (2 * xf - 1), f = r / d, p = isFinite(r) ? 1 + Math.floor(3 * f) : xf; p > xf && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to ${xf}`); const m = []; let g = 0; for (let t = 0; t < xf; ++t) { const e = t / f, n = Math.exp(-e * e / 2); m.push(n), 0 == t ? g += n : t < p && (g += 2 * n) } for (let t = 0; t < m.length; t++)m[t] = m[t] / g; u.envMap.value = t.texture, u.samples.value = p, u.weights.value = m, u.latitudinal.value = "latitudinal" === o, s && (u.poleAxis.value = s), u.dTheta.value = d, u.mipInt.value = gf - n, u.inputEncoding.value = bf[t.texture.encoding], u.outputEncoding.value = bf[t.texture.encoding]; const v = Tf[i]; If(e, 3 * Math.max(0, vf - 2 * v), (0 === i ? 0 : 2 * vf) + 2 * v * (i > gf - mf ? i - gf + mf : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(l, wf) } }; const Ff = 0, Uf = 1, Hf = 0, Gf = 1, jf = 2; function Vf(t) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t } function Wf(t) { return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function () { return t.slice() }, t } function qf(t, e) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Uc(t, e) } function Xf(t) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new lc(t) } function Yf(t, e) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Uc(t, e) } function Zf(t) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Nc(t) } function Jf(t) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Nc(t) } function Qf(t) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Nc(t) } function $f(t, e, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Jn(t, e, n) } function Kf(t, e) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Mr(t, e).setUsage(En) } function tp(t, e) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Tr(t, e) } function ep(t, e) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Sr(t, e) } function np(t, e) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Er(t, e) } function ip(t, e) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ar(t, e) } function rp(t, e) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Pr(t, e) } function op(t, e) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Lr(t, e) } function sp(t, e) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Rr(t, e) } function ap(t, e) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Or(t, e) } function cp(t, e) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Cr(t, e) } function lp(t) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), th.call(this, t), this.type = "catmullrom", this.closed = !0 } function up(t) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), th.call(this, t), this.type = "catmullrom" } function hp(t) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), th.call(this, t), this.type = "catmullrom" } function dp(t) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new pf(t) } function fp(t, e) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new af(t, e) } function pp(t, e) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ic(new tu(t.geometry), new Tc({ color: void 0 !== e ? e : 16777215 })) } function mp(t, e) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ic(new qc(t.geometry), new Tc({ color: void 0 !== e ? e : 16777215 })) } function gp(t) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Fu(t) } function vp(t) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Gu(t) } function yp(t, e, n) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Po(t, n) } qu.create = function (t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(qu.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, Object.assign(dh.prototype, { createPointsGeometry: function (t) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); const e = this.getPoints(t); return this.createGeometry(e) }, createSpacedPointsGeometry: function (t) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); const e = this.getSpacedPoints(t); return this.createGeometry(e) }, createGeometry: function (t) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); const e = new po; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.vertices.push(new Jn(i.x, i.y, i.z || 0)) } return e } }), Object.assign(fh.prototype, { fromPoints: function (t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) } }), lp.prototype = Object.create(th.prototype), up.prototype = Object.create(th.prototype), hp.prototype = Object.create(th.prototype), Object.assign(hp.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), Zd.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, jd.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(Bu.prototype, { extractUrlBase: function (t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Rh.extractUrlBase(t) } }), Bu.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Object.assign(Nh.prototype, { setTexturePath: function (t) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t) } }), Object.assign(Id.prototype, { center: function (t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, size: function (t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(Bi.prototype, { center: function (t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, size: function (t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(Ui.prototype, { empty: function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() } }), Co.prototype.setFromMatrix = function (t) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t) }, kd.prototype.center = function (t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Object.assign(Bn, { random16: function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function (t) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Bn.floorPowerOfTwo(t) }, nextPowerOfTwo: function (t) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Bn.ceilPowerOfTwo(t) } }), Object.assign(Fn.prototype, { flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, multiplyVector3: function (t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBufferAttribute: function (t) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(ri.prototype, { extractPosition: function (t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, getPosition: function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Jn).setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function (t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector4: function (t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function (t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBufferAttribute: function (t) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (t, e, n, i, r, o) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o) } }), $i.prototype.isIntersectionLine = function (t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, Xn.prototype.multiplyVector3 = function (t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, Object.assign(Yi.prototype, { isIntersectionBox: function (t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionPlane: function (t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(lr.prototype, { area: function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function (t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, midpoint: function (t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, normal: function (t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, plane: function (t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) } }), Object.assign(lr, { barycoordFromPoint: function (t, e, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), lr.getBarycoord(t, e, n, i, r) }, normal: function (t, e, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), lr.getNormal(t, e, n, i) } }), Object.assign(ph.prototype, { extractAllPoints: function (t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, extrude: function (t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Fl(this, t) }, makeGeometry: function (t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ql(this, t) } }), Object.assign(zn.prototype, { fromAttribute: function (t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Jn.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, applyProjection: function (t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, fromAttribute: function (t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Vn.prototype, { fromAttribute: function (t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, lengthManhattan: function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(po.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") }, applyMatrix: function (t) { return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.assign(wi.prototype, { getChildByName: function (t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, applyMatrix: function (t) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.defineProperties(wi.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.assign(so.prototype, { setDrawMode: function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } }), Object.defineProperties(so.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Xe }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Object.defineProperties(fc.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(vc.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), pc.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(qu.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (t) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t } }), To.prototype.setLens = function (t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(mh.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(Mr.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === En }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(En) } } }), Object.assign(Mr.prototype, { setDynamic: function (t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? En : Sn), this }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, setArray: function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(Gr.prototype, { addIndex: function (t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, addAttribute: function (t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Mr(arguments[1], arguments[2]))) }, addDrawCall: function (t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, removeAttribute: function (t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) }, applyMatrix: function (t) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.defineProperties(Gr.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(Oh.prototype, { maxInstancedCount: { get: function () { return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount }, set: function (t) { console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t } } }), Object.defineProperties(Ad.prototype, { linePrecision: { get: function () { return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold }, set: function (t) { console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t } } }), Object.defineProperties(qa.prototype, { dynamic: { get: function () { return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === En }, set: function (t) { console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t) } } }), Object.assign(qa.prototype, { setDynamic: function (t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? En : Sn), this }, setArray: function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(Ul.prototype, { getArrays: function () { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function () { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function () { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(Sd.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(_r.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new fr } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === v } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } } }), Object.defineProperties(du.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(hu.prototype, { transparency: { get: function () { return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission }, set: function (t) { console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t } } }), Object.defineProperties(wo.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), Object.assign(Ga.prototype, { clearTarget: function (t, e, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i) }, animate: function (t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, getCurrentRenderTarget: function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, getActiveMipMapLevel: function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() } }), Object.defineProperties(Ga.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (t) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Qe : Je } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(Ia.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Wn.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Object.defineProperties(rd.prototype, { load: { value: function (t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const e = this; return (new qh).load(t, (function (t) { e.setBuffer(t) })), this } }, startTime: { set: function () { console.warn("THREE.Audio: .startTime is now .play( delay ).") } } }), ud.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Ao.prototype.updateCubeMap = function (t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }; const _p = { merge: function (t, e, n) { let i; console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, n) }, center: function (t) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center() } }; function xp() { console.error("THREE.CanvasRenderer has been removed") } function bp() { console.error("THREE.JSONLoader has been removed.") } Hn.crossOrigin = void 0, Hn.loadTexture = function (t, e, n, i) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const r = new Wu; r.setCrossOrigin(this.crossOrigin); const o = r.load(t, n, void 0, i); return e && (o.mapping = e), o }, Hn.loadTextureCube = function (t, e, n, i) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const r = new Vu; r.setCrossOrigin(this.crossOrigin); const o = r.load(t, n, void 0, i); return e && (o.mapping = e), o }, Hn.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, Hn.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; const wp = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } }; function Mp() { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") } "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: i } })) }, function (t, e) { t.exports = "#define S(a,b,n) smoothstep(a,b,n)\r\n#define pi2 6.28318530718\r\n#define pi 3.14159265359\r\n  \r\nuniform float u_volatility;\r\n\r\nuniform vec2 u_res;\r\nuniform vec2 u_mouse;\r\nuniform vec2 u_directionMouse;\r\nuniform vec2 u_textureFactor;\r\n\r\nuniform sampler2D u_text0;\r\n\r\nvarying vec2 vUv;\r\n\r\nvec2 centeredAspectRatio(vec2 uvs, vec2 factor){\r\n  return uvs * factor - factor / 2. + 0.5;\r\n}\r\n  \r\nvoid main() {\r\n  vec2 uv = vUv;\r\n  vec2 st = (gl_FragCoord.xy - .5 * u_res) / min(u_res.x, u_res.y) * vec2(.4, 1.);\r\n  vec2 mouse_normalized = (u_mouse - .5 * u_res) / min(u_res.x, u_res.y) * vec2(.4, 1.);\r\n  \r\n  float volatility = u_volatility; \r\n  float dist = length(mouse_normalized - st);\r\n  float m_color = S(.2, .05, dist);\r\n     \r\n  vec4 tex1 = vec4(1.);\r\n  \r\n  volatility = clamp(volatility * 0.1, -1.0, 1.0); \r\n  \r\n\r\n  uv.x -= (sin(uv.y) * m_color * volatility / 100.) * u_directionMouse.x;\r\n  uv.y -= (sin(uv.x) * m_color * volatility / 100.) * u_directionMouse.y;\r\n  tex1.r = texture2D(u_text0, centeredAspectRatio(uv, u_textureFactor)).r;\r\n  \r\n  uv.x -= (sin(uv.y) * m_color * volatility / 150.) * u_directionMouse.x;\r\n  uv.y -= (sin(uv.x) * m_color * volatility / 150.) * u_directionMouse.y;\r\n  tex1.g = texture2D(u_text0, centeredAspectRatio(uv, u_textureFactor)).g;\r\n  \r\n  uv.x -= (sin(uv.y) * m_color * volatility / 200.) * u_directionMouse.x;\r\n  uv.y -= (sin(uv.x) * m_color * volatility / 200.) * u_directionMouse.y;\r\n  tex1.b = texture2D(u_text0, centeredAspectRatio(uv, u_textureFactor)).b;\r\n         \r\n  gl_FragColor = tex1;\r\n}\r\n  " }, function (t, e) { t.exports = "uniform float u_progress;\r\nuniform float u_direction;\r\nuniform float u_waveIntensity;\r\nuniform float u_offset;\r\nuniform float u_time;\r\n  \r\nvarying vec2 vUv;\r\n\r\nvoid main(){\r\n    \r\n  vec3 pos = position.xyz;\r\n  float dist = length(uv - .7); \r\n  float maxDist = length(vec2(.9)); \r\n  float normDist = dist / maxDist; \r\n    \r\n  float stickOut = normDist; \r\n  float stickIn = -normDist; \r\n  float stickEff = mix(stickOut, stickIn, u_direction); \r\n    \r\n  float stick = .3; \r\n    \r\n  float waveIn = u_progress * (1./stick); \r\n  float waveOut = -(u_progress - 1.) * (1./(1. - stick)); \r\n  float stickProg = min(waveIn, waveOut); \r\n    \r\n  float offIn = clamp(waveIn, 0., 1.); \r\n  float offOut = clamp(1. - waveOut, 0., 1.); \r\n  float offProg = mix(offIn, offOut, u_direction); \r\n\r\n  pos.z += stickEff * u_offset * stickProg - u_offset * offProg;\r\n  pos.z += sin(dist * 8. - u_time * 5.) * u_waveIntensity;\r\n    \r\n  vUv = uv;\r\n    \r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n}" }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.clickAnimation = void 0; var i = n(1); e.clickAnimation = function (t) { i.TweenLite.to(t.u_progress, 2, { value: 0, ease: i.Elastic.easeInOut.config(.1, .9) }), i.TweenLite.fromTo(t.u_direction, 2, { value: 1 === t.u_progress.value ? 1 : t.u_direction.value, ease: i.Elastic.easeInOut.config(.1, .9) }, { value: 1, ease: i.Elastic.easeInOut.config(.1, .9) }), i.TweenLite.to(t.u_waveIntensity, 2, { value: .005, ease: i.Elastic.easeInOut.config(.1, .9) }); var e = document.querySelector(".js-item.active"), n = e.getBoundingClientRect(), r = window.getComputedStyle(e), o = e.cloneNode(!0); o.style.cssText = "\n    position: fixed;\n    display: block;\n    top: " + (n.top - +r.marginTop.replace("px", "")) + "px;\n    left: " + n.left + "px;\n    z-index: 99;\n    opacity: 1;\n  ", o.classList.add("js-clonned"), document.body.appendChild(o), e.style.opacity = "0", i.TweenLite.to(document.querySelector(".js-wrapper"), 1, { opacity: 0, pointerEvents: "none" }), i.TweenLite.to(document.querySelector(".js-scroll-progress"), 1, { opacity: 0, pointerEvents: "none" }), i.TweenLite.to(o, 1, { left: window.innerWidth / 2, top: window.innerHeight / 2, y: "-50%", x: "-50%", marginTop: 0, delay: .5, ease: i.Elastic.easeInOut.config(.1, .9) }) } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.MouseMove = void 0; var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1), o = n(33); e.MouseMove = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.mouse = e.mouse, this.lastmouse = e.lastmouse, this.uniforms = e.uniforms, this.vec2 = new o.Vec2 } return i(t, [{ key: "onMouse", value: function (t) { var e = this.vec2.dist(this.lastmouse, this.mouse) / t; r.TweenLite.to(this.uniforms.u_volatility, 1, { value: Math.min(this.vec2.map(e, 0, 10, 10, 100), 1.4) }), r.TweenLite.to(this.uniforms.u_directionMouse.value, 1, { x: this.mouse.x - this.lastmouse.x, y: this.mouse.y - this.lastmouse.y }), this.lastmouse = { x: this.mouse.x, y: this.mouse.y } } }, { key: "mouseMoveHandler", value: function (t) { var e = t.clientX, n = t.clientY; this.mouse.x = e, this.mouse.y = innerHeight - n, r.TweenLite.to(this.uniforms.u_mouse.value, 1, { x: this.mouse.x, y: this.mouse.y }) } }]), t }() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); e.Vec2 = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.pi = Math.PI, this.pi2 = 2 * this.pi } return i(t, [{ key: "add", value: function (t, e) { var n = t.x + e.x, i = t.y + e.y; return this.set(n, i) } }, { key: "sub", value: function (t, e) { var n = t.x - e.x, i = t.y - e.y; return this.set(n, i) } }, { key: "div", value: function (t, e) { var n = t.x / e.x, i = t.y / e.y; return this.set(n, i) } }, { key: "mul", value: function (t, e) { var n = t.x * e.x, i = t.y * e.y; return this.set(n, i) } }, { key: "dist", value: function (t, e) { var n = this.sub(t, e), i = n.x, r = n.y; return Math.hypot(i, r) } }, { key: "radToDeg", value: function (t) { return 180 * t / this.pi } }, { key: "degToRad", value: function (t) { return t * this.pi / 180 } }, { key: "angle", value: function (t, e) { var n = this.sub(t, e), i = n.x, r = n.y; return Math.atan2(r, i) } }, { key: "scale", value: function (t, e) { var n = t.x * e, i = t.y * e; return this.set(n, i) } }, { key: "lerp", value: function (t, e, n) { return n * (e - t) + t } }, { key: "dot", value: function (t, e) { return t.x * e.x + t.y * e.y } }, { key: "cross", value: function (t, e) { var n = t.x * e.x - t.y * e.y; return this.set(0, 0, n) } }, { key: "rot2d", value: function (t, e, n) { var i = this.sub(t, e), r = i.x, o = i.y, s = Math.sin(n), a = Math.cos(n), c = r * a - o * s + e.x, l = r * s - o * a + e.y; return this.set(c, l) } }, { key: "length", value: function (t) { return Math.sqrt(t.x * t.x + t.y * t.y) } }, { key: "norm", value: function (t) { var e = t.x, n = t.y, i = e * e + n * n; i > 0 && (i = 1 / Math.sqrt(i)); var r = e * i, o = n * i; return this.set(r, o) } }, { key: "clamp", value: function (t, e, n) { return Math.max(e, Math.min(t, n)) } }, { key: "map", value: function (t, e, n, i, r) { return i + (r - i) * (t - e) / (n - e) } }, { key: "fract", value: function (t) { return t - Math.floor(t) } }, { key: "set", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; return { x: t, y: e, z: n } } }]), t }() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.MouseScroll = void 0; var i, r = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), o = n(1), s = n(11), a = (i = s) && i.__esModule ? i : { default: i }, c = n(35); e.MouseScroll = function () { function t(e, n, i) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.$items = e, this.$scroller = n, this.$wrapper = i, this.total = this.$items.length, this.step = 100 / this.total, this.init() } return r(t, [{ key: "init", value: function () { this.resizeHandler = this.resizeHandler.bind(this), this.resize = new a.default(this.resizeHandler), this.resize.init(), this.scrollAnimation = this.scrollAnimation.bind(this), this.handlers = new c.Handlers({ step: this.step, scrollAnimation: this.scrollAnimation, scroller: this.$scroller }), this.detectActiveItem = this.detectActiveItem.bind(this), this.detectActiveItem() } }, { key: "scrollAnimation", value: function (t) { this.handlers.distance >= 0 && (this.handlers.distance = 0), this.handlers.distance <= 100 * this.ofssetPercent - 100 && (this.handlers.distance = 100 * this.ofssetPercent - 100), this.onScroll(), o.TweenMax.to(this.$scroller, t, { y: this.handlers.distance + "%" }) } }, { key: "sizes", value: function (t) { return t.getBoundingClientRect() } }, { key: "onUpdate", value: function () { } }, { key: "onScroll", value: function () { } }, { key: "detectActiveItem", value: function () { var t = this; this.$items.forEach((function (e) { var n = t.sizes(e).y; n <= .6 * window.innerHeight && n > 0 ? (t.$items.forEach((function (t) { return t.classList.remove("active") })), e.classList.add("active"), t.$wrapper.setAttribute("href", e.getAttribute("data-link"))) : e.classList.remove("active") })), this.onUpdate(), this.raf = requestAnimationFrame(this.detectActiveItem) } }, { key: "resizeHandler", value: function () { this.itemHeight = this.sizes(this.$items[0]).height + 180, this.itemOffsetValue = window.innerHeight / 2 - this.itemHeight / 2, this.$scroller.style.top = this.itemOffsetValue + "px", this.ofssetPercent = this.itemHeight / this.sizes(this.$scroller).height } }, { key: "destroy", value: function () { cancelAnimationFrame(this.raf), this.resize.destroy(), this.handlers.destroy() } }]), t }() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Handlers = void 0; var i, r = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), o = n(36), s = (i = o) && i.__esModule ? i : { default: i }, a = n(37); e.Handlers = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.step = e.step, this.scrollAnimation = e.scrollAnimation, this.$scroller = e.scroller, this.distance = 0, this.init() } return r(t, [{ key: "init", value: function () { this.wheelHandler = this.wheelHandler.bind(this), this.keysHandler = this.keysHandler.bind(this), this.mouseEvent = new s.default(window, this.wheelHandler), this.touchEvents = new a.TouchEvents(this.touchHandler.bind(this)), document.addEventListener("keydown", this.keysHandler) } }, { key: "wheelHandler", value: function (t) { (t.deltaY || t.detail || t.wheelDelta) > 0 ? this.distance -= this.step : this.distance += this.step, this.scrollAnimation(.5), t.preventDefault() } }, { key: "touchHandler", value: function (t) { "down" === t ? this.distance -= this.step : "up" === t && (this.distance += this.step), this.scrollAnimation(.25) } }, { key: "keysHandler", value: function (t) { "ArrowDown" === t.key ? this.distance -= this.step : "ArrowUp" === t.key && (this.distance += this.step), this.scrollAnimation(.25) } }, { key: "destroy", value: function () { this.mouseEvent.destroy(), this.touchEvents.destroy(), document.removeEventListener("keydown", this.keysHandler) } }]), t }() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); var r = function () { function t(e, n) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.elem = e || window, this.handler = n || function () { }, this.init() } return i(t, [{ key: "init", value: function () { this.elem.addEventListener && ("onwheel" in document ? this.elem.addEventListener("wheel", this.handler, { passive: !1 }) : "onmousewheel" in document ? this.elem.addEventListener("mousewheel", this.handler, { passive: !1 }) : this.elem.addEventListener("MozMousePixelScroll", this.handler, { passive: !1 })) } }, { key: "destroy", value: function () { this.elem.removeEventListener && ("onwheel" in document ? this.elem.removeEventListener("wheel", this.handler, { passive: !1 }) : "onmousewheel" in document ? this.elem.removeEventListener("mousewheel", this.handler, { passive: !1 }) : this.elem.removeEventListener("MozMousePixelScroll", this.handler, { passive: !1 })) } }]), t }(); e.default = r }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(); e.TouchEvents = function () { function t(e) { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.posY, this.newPosY, this.dir, this.opts = { passive: !1 }, this.treshold = 75, this.cb = e, this.init() } return i(t, [{ key: "init", value: function () { this.ontouchstart = this.ontouchstart.bind(this), this.ontouchmove = this.ontouchmove.bind(this), this.ontouchend = this.ontouchend.bind(this), window.addEventListener("touchstart", this.ontouchstart, this.opts), window.addEventListener("touchend", this.ontouchend, this.opts) } }, { key: "ontouchstart", value: function (t) { this.posY = t.changedTouches[0].screenY, window.addEventListener("touchmove", this.ontouchmove, this.opts) } }, { key: "ontouchmove", value: function (t) { this.newPosY = t.changedTouches[0].screenY, this.newPosY > this.posY ? this.dir = "up" : this.dir = "down" } }, { key: "ontouchend", value: function () { (this.newPosY - this.posY >= this.treshold || this.posY - this.newPosY >= this.treshold) && this.cb(this.dir), window.removeEventListener("touchmove", this.ontouchmove, this.opts) } }, { key: "destroy", value: function () { window.removeEventListener("touchstart", this.ontouchstart, this.opts), window.removeEventListener("touchmove", this.ontouchmove, this.opts), window.removeEventListener("touchend", this.ontouchend, this.opts) } }]), t }() }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = c(n(2)); n(1); n(4), n(5); var o = c(n(12)), s = (c(n(8)), c(n(39))), a = c(n(3)); c(n(40)); function c(t) { return t && t.__esModule ? t : { default: t } } var l = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnterCompleted", value: function () { (0, a.default)(), (0, o.default)(), "0" === document.querySelector(".loader").style.opacity && (new s.default, document.body.style.position = "static"), window.addEventListener("load", (function () { new s.default })) } }]), e }(r.default.Renderer); e.default = l }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1); n(4), n(5); var o = c(n(8)), s = c(n(10)), a = n(9); function c(t) { return t && t.__esModule ? t : { default: t } } var l = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.h1 = document.querySelector("h1"), (0, s.default)({ target: this.h1, by: "words" }), (0, a.splitLines)(this.h1), this.h1Description = document.querySelector(".h1_description"), this.button = document.querySelector("header .button"), this.h1Splitter = document.querySelectorAll(".splitter"), (0, a.TextSplit)(this.h1Splitter, "chars"), this.load() } return i(t, [{ key: "load", value: function () { for (var t = 0; t < this.h1Splitter.length; t++) { this.h1.style.opacity = "1", this.splitterSpan = this.h1Splitter[t].querySelectorAll("span"), (new r.TimelineMax).staggerTo(this.splitterSpan, 1.2, { y: 0, opacity: 1, ease: r.Power2.easeOut }, .04, .1) } new r.TimelineMax({ onComplete: function () { (0, o.default)() } }).to(this.h1Description, 1, { opacity: 1, ease: r.Power1.easeInOut }, .8).to(this.button, 1, { opacity: 1, ease: r.Power1.easeInOut }, .8) } }]), t }(); e.default = l }, function (t, e, n) {
    var i, r;
/*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */!function (o, s) { "use strict"; i = [n(41)], void 0 === (r = function (t) { return function (t, e) { var n = t.jQuery, i = t.console; function r(t, e) { for (var n in e) t[n] = e[n]; return t } var o = Array.prototype.slice; function s(t, e, a) { if (!(this instanceof s)) return new s(t, e, a); var c, l = t; ("string" == typeof t && (l = document.querySelectorAll(t)), l) ? (this.elements = (c = l, Array.isArray(c) ? c : "object" == typeof c && "number" == typeof c.length ? o.call(c) : [c]), this.options = r({}, this.options), "function" == typeof e ? a = e : r(this.options, e), a && this.on("always", a), this.getImages(), n && (this.jqDeferred = new n.Deferred), setTimeout(this.check.bind(this))) : i.error("Bad element for imagesLoaded " + (l || t)) } s.prototype = Object.create(e.prototype), s.prototype.options = {}, s.prototype.getImages = function () { this.images = [], this.elements.forEach(this.addElementImages, this) }, s.prototype.addElementImages = function (t) { "IMG" == t.nodeName && this.addImage(t), !0 === this.options.background && this.addElementBackgroundImages(t); var e = t.nodeType; if (e && a[e]) { for (var n = t.querySelectorAll("img"), i = 0; i < n.length; i++) { var r = n[i]; this.addImage(r) } if ("string" == typeof this.options.background) { var o = t.querySelectorAll(this.options.background); for (i = 0; i < o.length; i++) { var s = o[i]; this.addElementBackgroundImages(s) } } } }; var a = { 1: !0, 9: !0, 11: !0 }; function c(t) { this.img = t } function l(t, e) { this.url = t, this.element = e, this.img = new Image } return s.prototype.addElementBackgroundImages = function (t) { var e = getComputedStyle(t); if (e) for (var n = /url\((['"])?(.*?)\1\)/gi, i = n.exec(e.backgroundImage); null !== i;) { var r = i && i[2]; r && this.addBackground(r, t), i = n.exec(e.backgroundImage) } }, s.prototype.addImage = function (t) { var e = new c(t); this.images.push(e) }, s.prototype.addBackground = function (t, e) { var n = new l(t, e); this.images.push(n) }, s.prototype.check = function () { var t = this; function e(e, n, i) { setTimeout((function () { t.progress(e, n, i) })) } this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? this.images.forEach((function (t) { t.once("progress", e), t.check() })) : this.complete() }, s.prototype.progress = function (t, e, n) { this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded, this.emitEvent("progress", [this, t, e]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, t), this.progressedCount == this.images.length && this.complete(), this.options.debug && i && i.log("progress: " + n, t, e) }, s.prototype.complete = function () { var t = this.hasAnyBroken ? "fail" : "done"; if (this.isComplete = !0, this.emitEvent(t, [this]), this.emitEvent("always", [this]), this.jqDeferred) { var e = this.hasAnyBroken ? "reject" : "resolve"; this.jqDeferred[e](this) } }, c.prototype = Object.create(e.prototype), c.prototype.check = function () { this.getIsImageComplete() ? this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.proxyImage.src = this.img.src) }, c.prototype.getIsImageComplete = function () { return this.img.complete && this.img.naturalWidth }, c.prototype.confirm = function (t, e) { this.isLoaded = t, this.emitEvent("progress", [this, this.img, e]) }, c.prototype.handleEvent = function (t) { var e = "on" + t.type; this[e] && this[e](t) }, c.prototype.onload = function () { this.confirm(!0, "onload"), this.unbindEvents() }, c.prototype.onerror = function () { this.confirm(!1, "onerror"), this.unbindEvents() }, c.prototype.unbindEvents = function () { this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, l.prototype = Object.create(c.prototype), l.prototype.check = function () { this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents()) }, l.prototype.unbindEvents = function () { this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, l.prototype.confirm = function (t, e) { this.isLoaded = t, this.emitEvent("progress", [this, this.element, e]) }, s.makeJQueryPlugin = function (e) { (e = e || t.jQuery) && ((n = e).fn.imagesLoaded = function (t, e) { return new s(this, t, e).jqDeferred.promise(n(this)) }) }, s.makeJQueryPlugin(), s }(o, t) }.apply(e, i)) || (t.exports = r) }("undefined" != typeof window ? window : this)
}, function (t, e, n) { var i, r; "undefined" != typeof window && window, void 0 === (r = "function" == typeof (i = function () { "use strict"; function t() { } var e = t.prototype; return e.on = function (t, e) { if (t && e) { var n = this._events = this._events || {}, i = n[t] = n[t] || []; return -1 == i.indexOf(e) && i.push(e), this } }, e.once = function (t, e) { if (t && e) { this.on(t, e); var n = this._onceEvents = this._onceEvents || {}; return (n[t] = n[t] || {})[e] = !0, this } }, e.off = function (t, e) { var n = this._events && this._events[t]; if (n && n.length) { var i = n.indexOf(e); return -1 != i && n.splice(i, 1), this } }, e.emitEvent = function (t, e) { var n = this._events && this._events[t]; if (n && n.length) { n = n.slice(0), e = e || []; for (var i = this._onceEvents && this._onceEvents[t], r = 0; r < n.length; r++) { var o = n[r]; i && i[o] && (this.off(t, o), delete i[o]), o.apply(this, e) } return this } }, e.allOff = function () { delete this._events, delete this._onceEvents }, t }) ? i.call(e, n, e, t) : i) || (t.exports = r) }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = a(n(2)), o = (a(n(13)), a(n(43))), s = a(n(3)); function a(t) { return t && t.__esModule ? t : { default: t } } var c = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnterCompleted", value: function () { (0, s.default)(), "0" === document.querySelector(".loader").style.opacity && (new o.default, document.body.style.position = "static"), window.addEventListener("load", (function () { new o.default, document.body.style.position = "static" })) } }]), e }(r.default.Renderer); e.default = c }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1); var o = n(6), s = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.h1 = document.querySelector("h1"), this.h2 = document.querySelectorAll("h2"), this.p = document.querySelectorAll("p"), this.price = document.querySelectorAll(".price"), this.button = document.querySelectorAll(".button"), this.buttons = document.querySelectorAll(".buttons"), this.lines = document.querySelectorAll(".service-item-line"), o(this.h1), this.h1Span = this.h1.querySelectorAll("span"), this.tl = new r.TimelineMax, this.load() } return i(t, [{ key: "load", value: function () { this.h1.style.opacity = "1", this.tl.staggerTo(this.h1Span, 1, { opacity: 1, y: 0, ease: r.Power2.easeOut }, .07).staggerTo(this.lines, 1.8, { width: "100%", ease: r.Power2.easeInOut }, .2, .1).to(this.h2, 1.8, { opacity: 1, ease: r.Power2.easeInOut }, .7).to(this.p, 1.8, { opacity: 1, ease: r.Power2.easeInOut }, 1.2).to(this.buttons, 1.8, { opacity: 1, ease: r.Power2.easeInOut }, .9).to(this.button, 1.8, { opacity: 1, ease: r.Power2.easeInOut }, .9).to(this.price, 1.8, { opacity: 1, ease: r.Power2.easeInOut }, .9) } }]), t }(); e.default = s }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = c(n(2)), o = c(n(45)), s = c(n(3)); n(4), n(5); var a = c(n(12)); function c(t) { return t && t.__esModule ? t : { default: t } } var l = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnterCompleted", value: function () { (0, s.default)(), "0" === document.querySelector(".loader").style.opacity && (new o.default, document.body.style.position = "static"), window.addEventListener("load", (function () { new o.default, document.body.style.position = "static", (0, a.default)() })) } }]), e }(r.default.Renderer); e.default = l }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1); n(4), n(5); var o, s = n(8), a = (o = s) && o.__esModule ? o : { default: o }; var c = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.h1 = document.querySelector("h1"), this.load() } return i(t, [{ key: "load", value: function () { new r.TimelineMax({ onComplete: function () { (0, a.default)() } }).to(this.h1, .5, { y: 0, opacity: 1, ease: r.Sine.easeOut }) } }]), t }(); e.default = c }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = l(n(2)), o = l(n(47)), s = n(7), a = l(n(3)), c = l(n(48)); function l(t) { return t && t.__esModule ? t : { default: t } } var u = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnterCompleted", value: function () { if (document.querySelector(".contacts-btn").classList.add("hide"), (0, a.default)(), (0, c.default)(), screen.width > 460 && (document.querySelector(".navbar").style.mixBlendMode = "normal"), "0" === document.querySelector(".loader").style.opacity && (document.body.style.position = "static", new o.default), window.addEventListener("load", (function () { document.body.style.position = "static" })), !1 === document.querySelector(".case-wrapper").hasChildNodes()) { var t = [document.querySelector("[data-texture]").getAttribute("data-texture")], e = document.createElement("div"), n = document.querySelector(".case-wrapper"); e.setAttribute("id", "app"), n.appendChild(e), this.distortion = new s.Distortion("#app", { fullScreen: !0, textures: t }), this.distortion.textureDidLoaded = function () { new o.default } } } }, { key: "onLeave", value: function () { this.distortion && this.distortion.destroy() } }]), e }(r.default.Renderer); e.default = u }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1); var o = n(6), s = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.h1 = document.querySelector("h1"), this.whiteBlock = document.querySelectorAll(".white-block"), this.tl = new r.TimelineMax, o(this.h1), this.h1Span = this.h1.querySelectorAll("span"), this.load() } return i(t, [{ key: "load", value: function () { this.h1.style.opacity = "1", this.tl.staggerTo(this.h1Span, 1, { opacity: 1, y: 0 }, .1).to(this.whiteBlock, 1, { y: 0, ease: r.Sine.easeInOut }, .1) } }]), t }(); e.default = s }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function () { var t = document.querySelector(".prev"), e = document.querySelector(".next"); function n() { var e = this.querySelector(".stroke-anim"), n = this.querySelector(".nav-arrow"), i = this === t ? -10 : 10, r = e.getTotalLength(); e.style.strokeDasharray = r, e.style.strokeDashoffset = r, n.style.transform = "translateX(" + i + "px)" } function i() { var t = this.querySelector(".stroke-anim"), e = this.querySelector(".nav-arrow"); t.style.strokeDashoffset = 0, e.style.transform = "translateX(0px)" } t.addEventListener("mouseenter", n), e.addEventListener("mouseenter", n), t.addEventListener("mouseleave", i), e.addEventListener("mouseleave", i) } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = c(n(2)), o = c(n(50)), s = n(7), a = c(n(3)); function c(t) { return t && t.__esModule ? t : { default: t } } var l = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnterCompleted", value: function () { if ((0, a.default)(), screen.width > 460 && (document.querySelector(".navbar").style.mixBlendMode = "normal"), "0" === document.querySelector(".loader").style.opacity && (document.body.style.position = "static"), window.addEventListener("load", (function () { document.body.style.position = "static" })), !1 === document.querySelector(".case-wrapper").hasChildNodes()) { var t = [document.querySelector("[data-texture]").getAttribute("data-texture")], e = document.createElement("div"), n = document.querySelector(".case-wrapper"); e.setAttribute("id", "app"), e.style.position = "absolute", n.appendChild(e), this.distortion = new s.Distortion("#app", { fullScreen: !0, textures: t }), this.distortion.textureDidLoaded = function () { new o.default } } } }, { key: "onLeave", value: function () { this.distortion.destroy() } }]), e }(r.default.Renderer); e.default = l }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1); var o = n(6), s = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.h1 = document.querySelector("h1"), this.canvas = document.querySelector("#app"), this.tl = new r.TimelineMax, o(this.h1), this.h1Span = this.h1.querySelectorAll("span"), this.load() } return i(t, [{ key: "load", value: function () { this.h1.style.opacity = "1", this.tl.delay(1.3).staggerTo(this.h1Span, 1, { opacity: 1, y: 0 }, .1).to(this.canvas, 1, { opacity: 1 }, .1) } }]), t }(); e.default = s }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = c(n(2)), o = (c(n(13)), c(n(52))), s = c(n(3)), a = c(n(53)); function c(t) { return t && t.__esModule ? t : { default: t } } var l = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnterCompleted", value: function () { (0, s.default)(), (0, a.default)(), document.querySelector(".navbar").style.mixBlendMode = "difference", document.querySelector(".visualizer-wrapper").style.mixBlendMode = "difference", "0" === document.querySelector(".loader").style.opacity && (new o.default, document.body.style.position = "static"), window.addEventListener("load", (function () { new o.default, document.body.style.position = "static" })) } }]), e }(r.default.Renderer); e.default = l }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = n(1); var o = function () { function t() { !function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, t), this.h1 = document.querySelector("h1"), this.h2 = document.querySelectorAll("h2"), this.p = document.querySelectorAll("p"), this.button = document.querySelectorAll(".faq-button"), this.lines = document.querySelectorAll(".faq-item-line"), this.tl = new r.TimelineMax, this.load() } return i(t, [{ key: "load", value: function () { this.tl.to(this.h1, 1, { opacity: 1 }, .1).staggerTo(this.lines, 1.8, { width: "100%", ease: r.Power2.easeInOut }, .2, .1).to(this.h2, 1.8, { opacity: 1, ease: r.Power2.easeInOut }, .7).to(this.p, 1.8, { opacity: 1, ease: r.Power2.easeInOut }, 1.2).to(this.button, 1.8, { opacity: 1, ease: r.Power2.easeInOut }, .9) } }]), t }(); e.default = o }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = function () { var t = document.querySelectorAll(".faq-item"), e = document.querySelectorAll(".faq-p"); function n() { var n = this.querySelector(".faq-p"); if (this.classList.contains("faq-active")) this.classList.remove("faq-active"), n.style.maxHeight = "0"; else { for (var i = 0; i < t.length; i++)t[i].classList.remove("faq-active"), e[i].style.maxHeight = "0"; this.classList.add("faq-active"), n.style.maxHeight = n.scrollHeight + "px" } } setTimeout((function () { t[0].classList.add("faq-active"), e[0].style.maxHeight = e[0].scrollHeight + "px" }), 0), t.forEach((function (t) { t.addEventListener("click", n) })) } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = c(n(2)), o = c(n(14)), s = (c(n(3)), c(n(15))), a = c(n(55)); function c(t) { return t && t.__esModule ? t : { default: t } } var l = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnterCompleted", value: function () { (0, a.default)(), document.querySelector(".navbar").style.mixBlendMode = "difference", document.querySelector(".visualizer-wrapper").style.mixBlendMode = "difference", setInterval((function () { (0, s.default)(document.querySelector(".date"), document.querySelector(".current-state")) }), 1e3), "0" === document.querySelector(".loader").style.opacity && (new o.default, document.body.style.position = "static"), window.addEventListener("load", (function () { new o.default, document.body.style.position = "static" })) } }]), e }(r.default.Renderer); e.default = l }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = function () { var t = new Date; document.querySelector(".year").innerHTML = t.getUTCFullYear() } }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), r = s(n(2)), o = (s(n(14)), s(n(3))); s(n(15)); function s(t) { return t && t.__esModule ? t : { default: t } } var a = function (t) { function e() { return function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }(this, e), function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)) } return function (t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), i(e, [{ key: "onEnterCompleted", value: function () { (0, o.default)(), document.body.style.position = "static" } }]), e }(r.default.Renderer); e.default = a }, function (t, e, n) { "use strict"; if (screen.width > 1140) { var i = function t() { s.removeEventListener("click", t), !0 === r.paused ? (r.play(), s.title = "ru" === document.documentElement.lang ? "Нажмите, чтобы выключить звук" : "Натисніть, щоб вимнути звук") : (r.pause(), s.title = "ru" === document.documentElement.lang ? "Нажмите, чтобы включить звук" : "Натисніть, щоб увімнути звук") }, r = new Audio, o = (document.querySelector(".button"), document.querySelector("#visualizer")), s = document.querySelector(".visualizer-wrapper"), a = [].concat(function (t) { if (Array.isArray(t)) { for (var e = 0, n = Array(t.length); e < t.length; e++)n[e] = t[e]; return n } return Array.from(t) }(document.querySelectorAll(".visualizer_line"))), c = document.querySelector("#audio"), l = (document.querySelector(".loader"), document.querySelector(".visualizer-tooltip")), u = void 0, h = void 0; r.controls = !1, r.autoplay = !1, r.loop = !0, r.src = c.getAttribute("data-src"), r.crossorigin = "anonymous", r.volume = "0.2", r.preload = "metadata", c.appendChild(r), setTimeout((function () { l.classList.remove("active") }), 15e3), l.onclick = function () { return l.classList.remove("active") }, s.onclick = function () { s.onclick = null, l.classList.remove("active"), u = new AudioContext, h = u.createMediaElementSource(r); var t = u.createAnalyser(); h.connect(t), t.connect(u.destination), t.fftSize = 256; var e = 5, n = new Uint8Array(e); !function i() { requestAnimationFrame(i), t.getByteFrequencyData(n); for (var r = 0; r < e; r++)a[r].style.height = n[r] / 9 + "px" }() }, s.addEventListener("click", i), o.addEventListener("click", i), window.addEventListener("click", (function t() { o.removeEventListener("click", t), window.addEventListener("blur", (function (t) { r.volume = "0" })), window.addEventListener("focus", (function (t) { r.volume = "0.2" })) })) } }, function (t, e, n) { "use strict"; document.body.style.position = "fixed", window.addEventListener("load", (function () { var t = document.querySelector(".line-loader"), e = document.querySelector(".loader"), n = document.querySelector(".visualizer-tooltip"); t.style.opacity = "0", e.style.opacity = "0", e.style.pointerEvents = "none", document.body.style.position = "static", setTimeout((function () { n.classList.add("active") }), 2e3) })), window.onbeforeunload = function () { window.scrollTo(0, 0) } }, function (t, e, n) { "use strict"; var i = n(1); function r(t) { if (Array.isArray(t)) { for (var e = 0, n = Array(t.length); e < t.length; e++)n[e] = t[e]; return n } return Array.from(t) } for (var o = n(6), s = document.querySelector(".burger-wrapper"), a = document.querySelector(".main_nav"), c = document.querySelector(".main_nav_bg"), l = [].concat(r(document.querySelectorAll(".main_nav .nav-wrapper .nav-item p"))), u = [].concat(r(document.querySelectorAll(".number"))), h = document.querySelector(".js-nav-btn"), d = 0; d < l.length; d++)o(l[d]); function f() { if ("flex" === a.style.display) { s.classList.remove("active"), h.classList.remove("active"), document.body.style.pointerEvents = "none", document.body.style.overflowY = "initial"; for (var t = 0; t < l.length; t++) { var e = [].concat(r(l[t].querySelectorAll(".main_nav .nav-wrapper .nav-item p span"))); new i.TimelineMax({ onComplete: function () { document.body.style.pointerEvents = "auto" } }).staggerTo(e, .7, { x: 20, opacity: 0 }, .01).to(u, .5, { opacity: 0, ease: i.Power1.easeOut }, 0).to(c, .8, { opacity: 0, ease: i.Sine.easeInOut }, .4).to(a, 0, { display: "none" }) } } else { s.classList.add("active"), h.classList.add("active"), document.body.style.pointerEvents = "none", document.body.style.overflowY = "hidden"; for (var n = 0; n < l.length; n++) { var o = [].concat(r(l[n].querySelectorAll(".main_nav .nav-wrapper .nav-item p span"))); new i.TimelineMax({ onComplete: function () { document.body.style.pointerEvents = "auto" } }).fromTo(a, 0, { display: "none" }, { display: "flex" }).fromTo(c, 0, { opacity: 0 }, { opacity: 1 }).fromTo(c, 1.3, { y: "-100%" }, { y: "0%", ease: i.Sine.easeInOut }).fromTo(u, .5, { opacity: 0 }, { opacity: .7, ease: i.Power1.easeOut }, .6).staggerFromTo(o, 1.2, { x: 20, opacity: 0 }, { x: 0, opacity: 1, ease: i.Power1.easeOut }, .06, .7) } } } s.addEventListener("click", f); for (var p = 0; p < l.length; p++)l[p].addEventListener("click", f) }, function (t, e, n) { "use strict"; var i = n(1); document.querySelector(".logo").getBoundingClientRect().width, document.querySelector("[data-router-view]"); !function t() { for (var e = document.querySelectorAll("section"), n = 0; n != e.length; n++) { if (e[n].getBoundingClientRect().top <= .75 * window.innerHeight && e[n].getBoundingClientRect().top > 0) (new i.TimelineMax).to(e[n].querySelectorAll("h2"), .8, { y: 0, opacity: 1, ease: Power1.easeOut }, .3).to(e[n].querySelectorAll("h3"), .8, { y: 0, opacity: 1, ease: Power1.easeOut }, .3).staggerTo(e[n].querySelectorAll(".founders"), .8, { y: 0, opacity: 1, ease: Power1.easeOut }, .08, .5).staggerTo(e[n].querySelectorAll("p"), .8, { y: 0, opacity: 1, ease: Power1.easeOut }, .08, .5).staggerTo(e[n].querySelectorAll(".cols-item-number"), .8, { y: 0, opacity: 1, ease: Power1.easeOut }, .08, .5).staggerTo(e[n].querySelectorAll(".site-types li"), .8, { y: 0, opacity: 1, ease: Power1.easeOut }, .1, .5) } window.requestAnimationFrame(t) }(), function t() { for (var e = document.querySelectorAll("footer"), n = 0; n != e.length; n++) { if (e[n].getBoundingClientRect().top <= .5 * window.innerHeight && e[n].getBoundingClientRect().top > 0) (new i.TimelineMax).to(e[n].querySelectorAll("h2"), .8, { y: 0, opacity: 1, ease: Power1.easeOut }).to(e[n].querySelectorAll("form"), .7, { y: 0, opacity: 1, ease: Power1.easeOut }, .1).staggerTo(e[n].querySelectorAll("p"), .8, { y: 0, opacity: 1, ease: Power1.easeOut }, .08, .1) } window.requestAnimationFrame(t) }(), function t() { document.documentElement.scrollTop / window.innerHeight * 100 < 10 || (document.querySelector(".navbar").style.mixBlendMode = "difference", document.querySelector(".visualizer-wrapper").style.mixBlendMode = "difference"), window.requestAnimationFrame(t) }() }, function (t, e, n) { "use strict"; var i = document.querySelector(".progress"); window.addEventListener("scroll", (function () { "portfolio" === document.querySelector("[data-router-view]").getAttribute("data-router-view") && (i.style.width = "0px"); var t = document.documentElement.scrollTop / (document.documentElement.scrollHeight - document.documentElement.clientHeight) * 100; i.style.width = t + "%" })) }, function (t, e, n) { "use strict"; var i = document.querySelector(".contacts-btn"), r = document.querySelector("[data-router-view]"); window.addEventListener("scroll", (function () { document.documentElement.scrollTop / (document.documentElement.scrollHeight - document.documentElement.clientHeight) * 100 > 80 ? i.classList.add("hide") : i.classList.remove("hide") })), "portfolioitem" === r.getAttribute("data-router-view") && i.classList.add("hide") }]);
